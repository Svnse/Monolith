diff --git a/ui/components/message_widget.py b/ui/components/message_widget.py
index 98703a04cd8478345835f413b1d0460ea25953d7..d68cbb22f133ec681f8baa073c14beb2457c5a86 100644
--- a/ui/components/message_widget.py
+++ b/ui/components/message_widget.py
@@ -20,65 +20,65 @@ class _IconAction(QPushButton):
                 font-size: 12px;
                 padding: 0;
             }}
             QPushButton:hover {{
                 color: {ACCENT_GOLD};
             }}
         """)
 
 
 class MessageWidget(QWidget):
     sig_delete = Signal(int)
     sig_edit = Signal(int)
     sig_regen = Signal(int)
 
     def __init__(self, index: int, role: str, text: str, timestamp: str):
         super().__init__()
         self._index = index
         self._role = role
         self._content = text or ""
 
         self.setAttribute(Qt.WA_Hover, True)
 
         is_assistant = role == "assistant"
         is_system = role == "system"
         border_color = ACCENT_GOLD if is_assistant else "#1a1a1a"
-        bg = "transparent"
         if is_system:
-            bg = "transparent"
             border_color = "#222"
+        bottom_border = "1px solid #1a1a1a" if is_assistant else "none"
 
         self.setStyleSheet(f"""
             MessageWidget {{
-                background: {bg};
+                background: #111;
                 border-left: 2px solid {border_color};
-                border-top: none; border-right: none; border-bottom: 1px solid #222;
+                border-top: none; border-right: none;
+                border-bottom: {bottom_border};
             }}
         """)
 
         root = QVBoxLayout(self)
-        root.setContentsMargins(10, 3, 10, 3)
+        root.setContentsMargins(10, 3, 10, 3 if not is_assistant else 8)
         root.setSpacing(4)
 
         # --- Header row ---
         head = QHBoxLayout()
         head.setSpacing(6)
 
         role_color = ACCENT_GOLD if is_assistant else FG_TEXT
         if is_system:
             role_color = FG_DIM
         self.lbl_role = QLabel((role or "").upper())
         self.lbl_role.setStyleSheet(
             f"color: {role_color}; font-size: 9px; font-weight: bold; letter-spacing: 1px;"
         )
         head.addWidget(self.lbl_role)
 
         pretty_ts = (timestamp or "")
         if "T" in pretty_ts and len(pretty_ts) >= 16:
             pretty_ts = pretty_ts[11:16]
         self.lbl_time = QLabel(pretty_ts)
         self.lbl_time.setStyleSheet(f"color: #444; font-size: 9px;")
         head.addWidget(self.lbl_time)
         head.addStretch()
 
         # --- Hover action icons ---
         self.actions = QWidget()
diff --git a/ui/pages/chat.py b/ui/pages/chat.py
index c145c159e5b2ab58de02ca102bbc6f610fe5ddb7..ae74f91741588f60a7b483d310b7761eb063bb10 100644
--- a/ui/pages/chat.py
+++ b/ui/pages/chat.py
@@ -1,32 +1,32 @@
 import json
 import re
 from datetime import datetime, timezone
 from pathlib import Path
 
 from PySide6.QtWidgets import (
-    QWidget, QVBoxLayout, QHBoxLayout, QPlainTextEdit,
+    QWidget, QVBoxLayout, QHBoxLayout, QTextEdit,
     QLineEdit, QPushButton, QLabel, QFileDialog,
     QSplitter, QListWidget, QListWidgetItem, QStackedWidget,
     QMessageBox, QButtonGroup, QMenu
 )
 from PySide6.QtCore import Signal, Qt, QTimer, QDateTime
 from PySide6.QtGui import QActionGroup
 
 from core.state import SystemStatus
 from core.style import BG_INPUT, FG_DIM, FG_TEXT, ACCENT_GOLD, FG_ERROR, SCROLLBAR_STYLE
 from ui.components.atoms import SkeetGroupBox, SkeetButton, SkeetSlider
 from ui.components.complex import BehaviorTagInput
 from ui.components.message_widget import MessageWidget
 from core.llm_config import DEFAULT_CONFIG, MASTER_PROMPT, load_config, save_config
 from core.paths import ARCHIVE_DIR
 
 class PageChat(QWidget):
     sig_generate = Signal(str, bool)
     sig_load = Signal()
     sig_unload = Signal()
     sig_stop = Signal()
     sig_sync_history = Signal(list)
     sig_set_model_path = Signal(str)
     sig_set_ctx_limit = Signal(int)
     sig_operator_loaded = Signal(str)
 
@@ -344,61 +344,61 @@ class PageChat(QWidget):
             QPushButton {{
                 background: {bg};
                 border: 1px solid {color};
                 color: {color};
                 padding: 8px;
                 font-size: 11px;
                 font-weight: bold;
                 border-radius: 2px;
             }}
             QPushButton:hover {{ background: {color}; color: black; }}
             QPushButton:pressed {{ background: #b08d2b; }}
         """
         self._set_send_button_state(is_running=False)
         self.btn_send.clicked.connect(self.handle_send_click)
 
         input_row.addWidget(self.input)
         input_row.addWidget(self.btn_send)
         chat_layout.addLayout(input_row)
         
         chat_group.add_layout(chat_layout)
 
         right_stack = QSplitter(Qt.Vertical)
         right_stack.setChildrenCollapsible(False)
 
         trace_group = SkeetGroupBox("REASONING TRACE")
-        self.trace = QPlainTextEdit()
+        self.trace = QTextEdit()
         self.trace.setReadOnly(True)
         self.trace.setStyleSheet(f"""
-            QPlainTextEdit {{
+            QTextEdit {{
                 background-color: {BG_INPUT};
                 color: {FG_TEXT};
                 border: 1px solid #222;
                 font-family: 'Consolas', monospace;
                 font-size: 10px;
             }}
-            QPlainTextEdit::viewport {{
+            QTextEdit::viewport {{
                 background-color: {BG_INPUT};
             }}
             {SCROLLBAR_STYLE}
         """)
         self.lbl_config_update = QLabel("")
         self.lbl_config_update.setStyleSheet(f"color: {ACCENT_GOLD}; font-size: 10px; font-weight: bold;")
         self.lbl_config_update.hide()
         self._config_update_fade = QTimer(self)
         self._config_update_fade.setSingleShot(True)
         self._config_update_fade.timeout.connect(self.lbl_config_update.hide)
         trace_group.add_widget(self.trace)
         trace_group.add_widget(self.lbl_config_update)
 
         right_stack.addWidget(trace_group)
         right_stack.addWidget(operations_group)
         right_stack.setStretchFactor(0, 1)
         right_stack.setStretchFactor(1, 1)
         right_stack.setSizes([200, 200])
 
         main_split.addWidget(chat_group)
         main_split.addWidget(right_stack)
         main_split.setStretchFactor(0, 3)
         main_split.setStretchFactor(1, 2)
 
         self._sync_path_display()
@@ -571,52 +571,57 @@ Continue from the interruption point. Do not repeat earlier content.
                 return
 
         # Categorize what we show
         if "system online" in lowered:
             self._is_model_loaded = True
         elif "model unloaded" in lowered:
             self._is_model_loaded = False
 
         if "error" in lowered:
             state = "ERROR"
         elif "token" in lowered:
             state = "TOKENIZING"
         elif "inference started" in lowered:
             state = "INFERENCE"
         elif "inference" in lowered and ("complete" in lowered or "aborted" in lowered):
             state = "COMPLETE"
         elif "init backend" in lowered or "system online" in lowered:
             state = "MODEL"
         elif "unload" in lowered or "cancel" in lowered:
             state = "MODEL"
         elif "ctx" in lowered or "context" in lowered:
             state = "CTX"
         else:
             state = "INFO"
 
-        indent = "" if state == "ERROR" else "    "
-        self.trace.appendPlainText(f"{indent}[{state}] {trace_msg}")
+        display_msg = trace_msg
+        if "→" in display_msg:
+            display_msg = display_msg[display_msg.index("→") + 1:].strip()
+        elif display_msg.startswith("ERROR"):
+            display_msg = display_msg.replace("ERROR:", "").strip()
+
+        self._trace_html(display_msg, state, error=(state == "ERROR"))
 
     def clear_chat(self):
         self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
 
     def _sync_path_display(self):
         gguf_path = self.config.get("gguf_path")
         if gguf_path:
             self.path_display.setText(gguf_path)
             self.path_display.setToolTip(str(gguf_path))
         else:
             self.path_display.clear()
             self.path_display.setToolTip("")
 
     def _set_config_dirty(self, dirty=True):
         self._config_dirty = dirty
         self.lbl_config_state.setText("UNSAVED" if dirty else "SAVED")
         self.lbl_config_state.setStyleSheet(
             f"color: {ACCENT_GOLD if dirty else FG_DIM}; font-size: 10px; font-weight: bold;"
         )
         # Save button: gold when dirty (action needed), gray when clean
         if dirty:
             self.btn_save_config.setStyleSheet(f"""
                 QPushButton {{ background: #181818; border: 1px solid {ACCENT_GOLD}; color: {ACCENT_GOLD}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                 QPushButton:hover {{ background: {ACCENT_GOLD}; color: black; }}
                 QPushButton:pressed {{ background: #b08d2b; color: black; }}
@@ -650,75 +655,91 @@ Continue from the interruption point. Do not repeat earlier content.
             qt_slider.setRange(int(min_value), int(max_value))
             qt_slider.setValue(int(value))
             slider.val_lbl.setText(str(int(value)))
         else:
             min_value = qt_slider.minimum()
             max_scaled = int(max_value * 100)
             if max_scaled < min_value:
                 min_value = max_scaled
             qt_slider.setRange(min_value, max_scaled)
             qt_slider.setValue(int(value * 100))
             slider.val_lbl.setText(f"{value:.2f}")
         qt_slider.blockSignals(False)
 
     def _apply_default_limits(self):
         self._set_slider_limits(
             self.s_ctx,
             DEFAULT_CONFIG["ctx_limit"],
             DEFAULT_CONFIG["ctx_limit"],
         )
         self._set_slider_limits(
             self.s_tok,
             DEFAULT_CONFIG["max_tokens"],
             DEFAULT_CONFIG["max_tokens"],
         )
 
+    def _trace_html(self, msg, tag="INFO", error=False):
+        arrow_color = FG_ERROR if error else ACCENT_GOLD
+        tag_color = FG_ERROR if error else "#555"
+        self.trace.append(
+            f"<table width='100%' cellpadding='0' cellspacing='0'><tr>"
+            f"<td><span style='color:{arrow_color}'>→</span> {msg}</td>"
+            f"<td align='right' style='color:{tag_color}; white-space:nowrap'>[{tag}]</td>"
+            f"</tr></table>"
+        )
+
+    def _trace_plain(self, msg):
+        self.trace.append(f"<span style='color:#555'>{msg}</span>")
+
     def _on_model_capabilities(self, payload):
         model_ctx_length = payload.get("model_ctx_length")
         if model_ctx_length is None:
             self._apply_default_limits()
             return
         configured_ctx = int(self.config.get("ctx_limit", 8192))
         self._set_slider_limits(self.s_ctx, model_ctx_length, model_ctx_length)
         self._set_slider_limits(
             self.s_tok,
             model_ctx_length,
             min(8192, model_ctx_length),
         )
         # Surface context capacity info in reasoning trace
         if configured_ctx < model_ctx_length:
             pct = int((configured_ctx / model_ctx_length) * 100)
-            self.trace.appendPlainText(
-                f"[CTX] Context: {configured_ctx:,} / {model_ctx_length:,} tokens "
-                f"({pct}% of model capacity)"
+            self._trace_html(
+                f"Context: {configured_ctx:,} / {model_ctx_length:,} tokens "
+                f"({pct}% of model capacity)",
+                "CTX",
             )
-            self.trace.appendPlainText(
-                f"[CTX] Increase context limit in SETTINGS to use full {model_ctx_length:,} capacity"
+            self._trace_html(
+                f"Increase context limit in SETTINGS to use full {model_ctx_length:,} capacity",
+                "CTX",
             )
         else:
-            self.trace.appendPlainText(
-                f"[CTX] Context: {model_ctx_length:,} tokens (full capacity)"
+            self._trace_html(
+                f"Context: {model_ctx_length:,} tokens (full capacity)",
+                "CTX",
             )
 
     def _on_ctx_limit_changed(self, value):
         self._update_config_value("ctx_limit", int(value))
         self.sig_set_ctx_limit.emit(int(value))
 
     def _on_behavior_tags_changed(self, tags):
         self._apply_behavior_prompt(tags)
 
     def _on_thinking_mode_toggled(self, checked):
         self._thinking_mode = bool(checked)
         self.config["thinking_mode"] = self._thinking_mode
         self._set_config_dirty(True)
         self._update_thinking_button_style()
 
     def _set_thinking_mode(self, enabled, label="Off"):
         self._thinking_mode = enabled
         self.config["thinking_mode"] = enabled
         self._set_config_dirty(True)
         self.btn_thinking.setText(label.upper() if enabled else "THINK")
         self._update_thinking_button_style()
 
     def _update_thinking_button_style(self):
         active = self._thinking_mode
         color = ACCENT_GOLD if active else FG_DIM
@@ -861,51 +882,51 @@ Continue from the interruption point. Do not repeat earlier content.
         self.s_tok.slider.blockSignals(False)
         self.s_ctx.slider.blockSignals(False)
 
         self.sig_set_ctx_limit.emit(int(slider_values["ctx_limit"]))
 
         tags = config.get("behavior_tags", [])
         self.behavior_tags.set_tags(tags if isinstance(tags, list) else [])
 
         thinking_mode = bool(config.get("thinking_mode", False))
         self._set_thinking_mode(thinking_mode, "Standard" if thinking_mode else "Off")
 
         gguf_path = config.get("gguf_path")
         if gguf_path:
             self.config["gguf_path"] = gguf_path
             self.sig_set_model_path.emit(str(gguf_path))
         self._sync_path_display()
 
         self._start_new_session()
         self._set_config_dirty(True)
         self.sig_operator_loaded.emit(str(operator_data.get("name", "")))
 
     def _start_new_session(self):
         self._title_generated = False
         self._suppress_title_regen = False
         self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
-        self.trace.appendPlainText("--- TRACE RESET ---")
+        self._trace_plain("--- TRACE RESET ---")
 
     def _prompt_clear_session(self):
         dialog = QMessageBox(self)
         dialog.setWindowTitle("Clear Session")
         dialog.setText("Choose how to clear the current session.")
         dialog.setStyleSheet(f"""
             QMessageBox {{
                 background: {BG_INPUT};
                 color: {FG_TEXT};
             }}
             QLabel {{
                 color: {FG_TEXT};
             }}
             QPushButton {{
                 color: {FG_TEXT};
                 background: transparent;
                 border: 1px solid #333;
                 padding: 6px 12px;
                 font-size: 10px;
                 font-weight: bold;
                 border-radius: 2px;
             }}
             QPushButton:hover {{
                 border: 1px solid {ACCENT_GOLD};
                 color: {ACCENT_GOLD};
@@ -1175,82 +1196,82 @@ Continue from the interruption point. Do not repeat earlier content.
         widget.sig_delete.connect(self._delete_from_index)
         widget.sig_edit.connect(self._edit_from_index)
         widget.sig_regen.connect(lambda _idx: self._regen_last_assistant())
         item.setSizeHint(widget.sizeHint())
         self.message_list.addItem(item)
         self.message_list.setItemWidget(item, widget)
         return widget
 
     def _widget_for_index(self, idx: int):
         for row in range(self.message_list.count()):
             item = self.message_list.item(row)
             widget = self.message_list.itemWidget(item)
             if isinstance(widget, MessageWidget) and getattr(widget, "_index", None) == idx:
                 return widget
         return None
 
     def _apply_behavior_prompt(self, tags):
         cleaned = [tag.strip() for tag in tags if tag.strip()]
         self.config["behavior_tags"] = cleaned
         self._set_config_dirty(True)
 
     def _begin_update_trace(self, update_text):
         self._update_trace_state = "requested"
         self._update_token_count = 0
         self._update_progress_index = 0
-        self.trace.appendPlainText("⟐ UPDATE REQUESTED")
-        self.trace.appendPlainText(f'⟐ USER PATCH: "{update_text}"')
+        self._trace_html("UPDATE REQUESTED", "UPDATE")
+        self._trace_html(f'USER PATCH: "{update_text}"', "UPDATE")
 
     def _start_update_streaming(self):
         self._update_trace_state = "streaming"
         self._update_token_count = 0
         self._update_progress_index = 0
 
     def _update_progress_markers(self):
         if self._update_trace_state != "streaming":
             return
         self._update_token_count += 1
         thresholds = [25, 50, 100]
         pct = min(
             100,
             int((self._update_token_count / self.config["max_tokens"]) * 100),
         )
         while self._update_progress_index < len(thresholds):
             if pct >= thresholds[self._update_progress_index]:
                 percent = thresholds[self._update_progress_index]
-                self.trace.appendPlainText(f"⟐ UPDATE PROGRESS {percent}%")
+                self._trace_html(f"UPDATE PROGRESS {percent}%", "UPDATE")
                 self._update_progress_index += 1
                 continue
             break
 
     def _finalize_update_progress(self):
         if self._update_trace_state != "streaming":
             return
         thresholds = [25, 50, 100]
         while self._update_progress_index < len(thresholds):
             percent = thresholds[self._update_progress_index]
-            self.trace.appendPlainText(f"⟐ UPDATE PROGRESS {percent}%")
+            self._trace_html(f"UPDATE PROGRESS {percent}%", "UPDATE")
             self._update_progress_index += 1
         self._update_trace_state = None
 
     def _add_message(self, role, text):
         now = self._now_iso()
         message = {
             "i": len(self._current_session["messages"]) + 1,
             "time": now,
             "role": role,
             "text": text
         }
         self._current_session["messages"].append(message)
         self._current_session["updated_at"] = now
         return len(self._current_session["messages"]) - 1
 
     def _append_assistant_token(self, token):
         target_index = self._rewrite_assistant_index
         if target_index is None:
             target_index = self._active_assistant_index
         if target_index is None:
             target_index = self._add_message("assistant", "")
             self._active_assistant_index = target_index
         msg = self._current_session["messages"][target_index]
         msg["text"] += token
         msg["time"] = self._now_iso()
