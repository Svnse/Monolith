diff --git a/bootstrap.py b/bootstrap.py
index f269bfa2eb6a079c7362afb81b449b87fb0becf8..430d6646121a00f151d296f5d01e757cd2434df1 100644
--- a/bootstrap.py
+++ b/bootstrap.py
@@ -1,57 +1,53 @@
 import sys
 
 from PySide6.QtWidgets import QApplication
 
 from core.state import AppState
 from engine.bridge import EngineBridge
-from engine.llm import LLMEngine
 from engine.vision import VisionEngine
 from monokernel.bridge import MonoBridge
 from monokernel.dock import MonoDock
 from monokernel.guard import MonoGuard
 from ui.addons.builtin import build_builtin_registry
 from ui.addons.context import AddonContext
 from ui.addons.host import AddonHost
 from ui.bridge import UIBridge
 from ui.main_window import MonolithUI
 from ui.overseer import OverseerWindow
 
 
 def main():
     app = QApplication(sys.argv)
     state = AppState()
-    engine_impl = LLMEngine(state)
-    engine = EngineBridge(engine_impl)
     vision_engine_impl = VisionEngine(state)
     vision_engine = EngineBridge(vision_engine_impl)
-    guard = MonoGuard(state, {"llm": engine, "vision": vision_engine})
+    guard = MonoGuard(state, {"vision": vision_engine})
     dock = MonoDock(guard)
     bridge = MonoBridge(dock)
 
     ui_bridge = UIBridge()
     ui = MonolithUI(state, ui_bridge)
     overseer = OverseerWindow(guard, ui_bridge)
 
     registry = build_builtin_registry()
     ctx = AddonContext(state=state, guard=guard, bridge=bridge, ui=ui, host=None, ui_bridge=ui_bridge)
     host = AddonHost(registry, ctx)
     ui.attach_host(host)
 
     ui_bridge.sig_open_overseer.connect(overseer.show)
     ui_bridge.sig_overseer_viz_toggle.connect(guard.enable_viztracer)
 
     # global chrome-only wiring stays here
     guard.sig_status.connect(ui.update_status)
-    guard.sig_usage.connect(ui.update_ctx)
+    guard.sig_usage.connect(lambda _ek, used: ui.update_ctx(used))
     app.aboutToQuit.connect(guard.stop)
     app.aboutToQuit.connect(overseer.db.close)
     app.aboutToQuit.connect(lambda: guard.enable_viztracer(False) if guard._viztracer is not None else None)
-    app.aboutToQuit.connect(engine.shutdown)
     app.aboutToQuit.connect(vision_engine.shutdown)
 
     ui.show()
     return app.exec()
 
 
 if __name__ == "__main__":
     raise SystemExit(main())
diff --git a/engine/bridge.py b/engine/bridge.py
index 8104a2f673f47e0a4d920530bee2c11683072669..1c13e7ec71e270538e59cdaf252785148cc79529 100644
--- a/engine/bridge.py
+++ b/engine/bridge.py
@@ -30,43 +30,47 @@ class EngineBridge(QObject):
             impl.sig_image.connect(self._on_image)
 
     def _is_current_generation(self) -> bool:
         return self._active_gid == self._gen_id
 
     def _on_token(self, token: str) -> None:
         if self._is_current_generation():
             self.sig_token.emit(token)
 
     def _on_trace(self, message: str) -> None:
         if self._is_current_generation():
             self.sig_trace.emit(message)
 
     def _on_usage(self, usage: int) -> None:
         if self._is_current_generation():
             self.sig_usage.emit(usage)
 
     def _on_image(self, image: object) -> None:
         if self._is_current_generation():
             self.sig_image.emit(image)
 
     def set_model_path(self, payload: dict) -> None:
         if hasattr(self.impl, "set_model_path"):
             self.impl.set_model_path(payload)
 
+    def set_ctx_limit(self, payload: dict) -> None:
+        if hasattr(self.impl, "set_ctx_limit"):
+            self.impl.set_ctx_limit(payload)
+
     def load_model(self) -> None:
         self.impl.load_model()
 
     def unload_model(self) -> None:
         self.impl.unload_model()
 
     def generate(self, payload: dict) -> None:
         self._gen_id += 1
         self._active_gid = self._gen_id
         self.impl.generate(payload)
 
     def stop_generation(self) -> None:
         self._gen_id += 1
         self._active_gid = 0
         self.impl.stop_generation()
 
     def shutdown(self) -> None:
         self.impl.shutdown()
diff --git a/engine/llm.py b/engine/llm.py
index 89d9be33d075415f25fed0e03ce4072edcdcc873..30f46811d4640195b850b2db25f17125678b1a31 100644
--- a/engine/llm.py
+++ b/engine/llm.py
@@ -84,172 +84,189 @@ class GeneratorWorker(QThread):
         finally:
             self.done.emit(completed, "".join(assistant_chunks))
 
 class LLMEngine(QObject):
     sig_token = Signal(str)
     sig_trace = Signal(str)
     sig_status = Signal(SystemStatus)
     sig_finished = Signal()
     sig_usage = Signal(int)
     sig_image = Signal(object)
     sig_model_capabilities = Signal(dict)
 
     def __init__(self, state: AppState):
         super().__init__()
         self.state = state
         self.llm = None
         self.loader = None
         self.worker = None
         self.model_path: str | None = None
         self.conversation_history: list[dict] = []
         self._pending_user_index: int | None = None
         self._load_cancel_requested: bool = False
         self._shutdown_requested: bool = False
         self._status: SystemStatus = SystemStatus.READY
         self._ephemeral_generation: bool = False
-        self.state.model_ctx_length = None
-        self.state.sig_model_capabilities = self.sig_model_capabilities
+        self.model_loaded: bool = False
+        self.model_ctx_length: int | None = None
+        self.ctx_limit: int = int(getattr(self.state, "ctx_limit", 8192))
+        self.gguf_path: str | None = None
+
+    def set_ctx_limit(self, payload: dict) -> None:
+        value = payload.get("ctx_limit") if isinstance(payload, dict) else None
+        if value is None:
+            return
+        try:
+            self.ctx_limit = int(value)
+        except (TypeError, ValueError):
+            return
 
     def set_model_path(self, payload: dict) -> None:
         path = payload.get("path") if isinstance(payload, dict) else None
         self.model_path = path
-        self.state.gguf_path = path
+        self.gguf_path = path
         QTimer.singleShot(0, lambda: self.set_status(SystemStatus.READY))
 
     def load_model(self):
         if self._status == SystemStatus.LOADING:
             self.sig_trace.emit("ERROR: Load already in progress.")
             self.set_status(SystemStatus.ERROR)
             return
         
-        model_path = self.model_path or self.state.gguf_path
+        model_path = self.model_path or self.gguf_path
         if not model_path:
             self.sig_trace.emit("ERROR: No GGUF selected.")
             self.set_status(SystemStatus.ERROR)
             return
 
         self.set_status(SystemStatus.LOADING)
         self._load_cancel_requested = False
         # Keep reference to loader to prevent GC
         n_ctx = (
-            min(self.state.ctx_limit, self.state.model_ctx_length)
-            if self.state.model_ctx_length
-            else self.state.ctx_limit
+            min(self.ctx_limit, self.model_ctx_length)
+            if self.model_ctx_length
+            else self.ctx_limit
         )
         self.loader = ModelLoader(model_path, n_ctx)
         self.loader.trace.connect(self.sig_trace)
         self.loader.error.connect(self._on_load_error)
         self.loader.finished.connect(self._on_load_success)
         self.loader.finished.connect(self._cleanup_loader)
         self.loader.error.connect(self._cleanup_loader)
         self.loader.start()
 
     def _on_load_success(self, llm_instance, model_ctx_length):
         if self._shutdown_requested:
             del llm_instance
             self.set_status(SystemStatus.READY)
             return
 
         if self._load_cancel_requested:
             del llm_instance
             self.llm = None
-            self.state.model_loaded = False
+            self.model_loaded = False
             self.set_status(SystemStatus.READY)
             self.sig_trace.emit("→ load cancelled")
             self.loader = None
             return
 
         self.llm = llm_instance
-        self.state.model_ctx_length = int(model_ctx_length)
-        self.state.ctx_limit = min(self.state.ctx_limit, self.state.model_ctx_length)
+        self.model_ctx_length = int(model_ctx_length)
+        self.ctx_limit = min(self.ctx_limit, self.model_ctx_length)
         self.sig_model_capabilities.emit(
             {
-                "model_ctx_length": self.state.model_ctx_length,
-                "ctx_limit": self.state.ctx_limit,
+                "model_ctx_length": self.model_ctx_length,
+                "ctx_limit": self.ctx_limit,
             }
         )
-        self.state.model_loaded = True
+        self.model_loaded = True
         self.set_status(SystemStatus.READY)
         self.reset_conversation(MASTER_PROMPT)
         self.sig_trace.emit("→ system online")
         self.loader = None
 
     def _on_load_error(self, err_msg):
         self.sig_trace.emit(f"<span style='color:red'>{err_msg}</span>")
         if self._shutdown_requested:
             self.set_status(SystemStatus.READY)
         else:
             self.set_status(SystemStatus.ERROR)
         self.loader = None
 
     def _cleanup_loader(self, *args, **kwargs):
         self.loader = None
 
     def unload_model(self):
         if self._status == SystemStatus.LOADING and self.loader and self.loader.isRunning():
             self._load_cancel_requested = True
             self.sig_trace.emit("→ unload requested during load; will cancel when init completes")
             return
 
         if self._status == SystemStatus.RUNNING:
             self.sig_trace.emit("ERROR: Cannot unload while generating.")
             return
 
         if self.llm:
             self.set_status(SystemStatus.UNLOADING)
             del self.llm
             self.llm = None
-        self.state.model_loaded = False
-        self.state.model_ctx_length = None
+        self.model_loaded = False
+        self.model_ctx_length = None
         self.reset_conversation(MASTER_PROMPT)
         QTimer.singleShot(0, lambda: self.set_status(SystemStatus.READY))
         self.sig_trace.emit("→ model unloaded")
 
     def reset_conversation(self, system_prompt):
         self.conversation_history = [{"role": "system", "content": system_prompt}]
         self._pending_user_index = None
 
     def set_history(self, payload: dict):
         history = payload.get("history", []) if isinstance(payload, dict) else []
         if not isinstance(history, list):
             return
         self.conversation_history = [h for h in history if isinstance(h, dict)]
         self._pending_user_index = None
 
     def _compile_system_prompt(self, config):
         tags = config.get("behavior_tags", [])
         cleaned = [tag.strip() for tag in tags if isinstance(tag, str) and tag.strip()]
         if not cleaned:
             return MASTER_PROMPT
         return f"{MASTER_PROMPT}\n\n[BEHAVIOR TAGS]\n" + "\n".join(cleaned)
 
     def generate(self, payload: dict):
-        if not self.state.model_loaded:
+        if not self.model_loaded:
             self.sig_trace.emit("ERROR: Model offline.")
             self.set_status(SystemStatus.ERROR)
             return
 
+        if isinstance(payload, dict) and "ctx_limit" in payload:
+            try:
+                self.ctx_limit = int(payload.get("ctx_limit", self.ctx_limit))
+            except (TypeError, ValueError):
+                pass
+
         if self._status == SystemStatus.RUNNING:
             self.sig_trace.emit("ERROR: Busy. Wait for completion.")
             self.set_status(SystemStatus.ERROR)
             return
 
         self.set_status(SystemStatus.RUNNING)
 
         prompt = payload.get("prompt", "")
         config = payload.get("config")
         if config is None:
             config = load_config()
 
         system_prompt = self._compile_system_prompt(config)
         temp = float(config.get("temp", 0.7))
         top_p = float(config.get("top_p", 0.9))
         max_tokens = int(config.get("max_tokens", 2048))
 
         self._ephemeral_generation = bool(payload.get("ephemeral", False))
         thinking_mode = bool(payload.get("thinking_mode", False))
 
         if not self.conversation_history:
             self.reset_conversation(MASTER_PROMPT)
 
         system_entry = {"role": "system", "content": system_prompt}
         if self.conversation_history[0].get("role") != "system":
diff --git a/monokernel/guard.py b/monokernel/guard.py
index 6b658bbafc23a7fcc9b97a421a959fe693a62b9c..0d119510cfaeb406ec8b59f140d88732c65f4418 100644
--- a/monokernel/guard.py
+++ b/monokernel/guard.py
@@ -1,193 +1,247 @@
 from __future__ import annotations
 
 from datetime import datetime
 from typing import Optional
 
 from core.paths import LOG_DIR
 
 from PySide6.QtCore import QObject, Signal, QTimer
 
 from core.state import AppState, SystemStatus
 from core.task import Task, TaskStatus
 from engine.base import EnginePort
 
 ENGINE_DISPATCH = {
     "set_path": "set_model_path",
     "set_history": "set_history",
+    "set_ctx_limit": "set_ctx_limit",
     "load": "load_model",
     "unload": "unload_model",
     "generate": "generate",
 }
 
-IMMEDIATE_COMMANDS = {"set_history", "set_path"}
+IMMEDIATE_COMMANDS = {"set_history", "set_path", "set_ctx_limit"}
 PAYLOAD_COMMANDS = {"generate"}
 
 
 class MonoGuard(QObject):
-    sig_token = Signal(str)
-    sig_trace = Signal(str)
+    sig_token = Signal(str, str)
+    sig_trace = Signal(str, str)
     sig_status = Signal(str, SystemStatus)
     sig_engine_ready = Signal(str)
-    sig_usage = Signal(int)
+    sig_usage = Signal(str, int)
     sig_image = Signal(object)
     sig_finished = Signal(str, str)
 
     def __init__(self, state: AppState, engines: dict[str, EnginePort]):
         super().__init__()
         self.state = state
         self.engines = engines
         self.active_tasks: dict[str, Optional[Task]] = {
             key: None for key in engines.keys()
         }
         self._stop_requested: dict[str, bool] = {key: False for key in engines.keys()}
         self._viztracer = None
 
+        self._engine_connections: dict[str, dict[str, object]] = {}
         for key, engine in engines.items():
-            engine.sig_status.connect(
-                lambda status, engine_key=key: self._on_status_changed(
-                    engine_key, status
-                )
-            )
-            engine.sig_token.connect(self.sig_token)
-            engine.sig_trace.connect(self.sig_trace)
-            if hasattr(engine, "sig_usage"):
-                engine.sig_usage.connect(self.sig_usage)
-            if hasattr(engine, "sig_image"):
-                engine.sig_image.connect(self.sig_image)
-            if hasattr(engine, "sig_finished"):
-                engine.sig_finished.connect(
-                    lambda engine_key=key: self._on_engine_finished(engine_key)
-                )
+            self._connect_engine_signals(key, engine)
+
+
+    def _connect_engine_signals(self, key: str, engine: EnginePort) -> None:
+        status_slot = lambda status, engine_key=key: self._on_status_changed(engine_key, status)
+        token_slot = lambda t, ek=key: self.sig_token.emit(ek, t)
+        trace_slot = lambda m, ek=key: self.sig_trace.emit(ek, m)
+        finished_slot = lambda engine_key=key: self._on_engine_finished(engine_key)
+
+        engine.sig_status.connect(status_slot)
+        engine.sig_token.connect(token_slot)
+        engine.sig_trace.connect(trace_slot)
+
+        usage_slot = None
+        if hasattr(engine, "sig_usage"):
+            usage_slot = lambda used, ek=key: self.sig_usage.emit(ek, used)
+            engine.sig_usage.connect(usage_slot)
+
+        image_slot = None
+        if hasattr(engine, "sig_image"):
+            image_slot = self.sig_image.emit
+            engine.sig_image.connect(image_slot)
+
+        has_finished = hasattr(engine, "sig_finished")
+        if has_finished:
+            engine.sig_finished.connect(finished_slot)
+
+        self._engine_connections[key] = {
+            "status": status_slot,
+            "token": token_slot,
+            "trace": trace_slot,
+            "usage": usage_slot,
+            "image": image_slot,
+            "finished": finished_slot if has_finished else None,
+        }
+
+    def _disconnect_engine_signals(self, key: str, engine: EnginePort) -> None:
+        slots = self._engine_connections.pop(key, None)
+        if not slots:
+            return
+        for signal_name, slot in slots.items():
+            if slot is None:
+                continue
+            signal = getattr(engine, f"sig_{signal_name}", None)
+            if signal is None:
+                continue
+            try:
+                signal.disconnect(slot)
+            except (TypeError, RuntimeError):
+                pass
+
+    def register_engine(self, key: str, engine: EnginePort):
+        if key in self.engines:
+            self.unregister_engine(key)
+        self.engines[key] = engine
+        self.active_tasks[key] = None
+        self._stop_requested[key] = False
+        self._connect_engine_signals(key, engine)
+
+    def unregister_engine(self, key: str):
+        engine = self.engines.get(key)
+        if engine is None:
+            return
+        self._disconnect_engine_signals(key, engine)
+        self.active_tasks.pop(key, None)
+        self._stop_requested.pop(key, None)
+        del self.engines[key]
 
     def get_active_task_id(self, engine_key: str) -> str | None:
         task = self.active_tasks.get(engine_key)
         return str(task.id) if task else None
 
     def get_active_task(self, engine_key: str) -> Task | None:
         return self.active_tasks.get(engine_key)
 
     def submit(self, task: Task) -> bool:
         engine = self.engines.get(task.target)
         if engine is None:
-            self.sig_trace.emit(f"ERROR: Unknown engine target: {task.target}")
+            self.sig_trace.emit("system", f"ERROR: Unknown engine target: {task.target}")
             return False
 
         method_name = ENGINE_DISPATCH.get(task.command)
         if not method_name:
-            self.sig_trace.emit(f"ERROR: Unknown command: {task.command}")
+            self.sig_trace.emit("system", f"ERROR: Unknown command: {task.command}")
             task.status = TaskStatus.FAILED
             return False
 
         handler = getattr(engine, method_name, None)
         if not handler:
-            self.sig_trace.emit(f"ERROR: Engine lacks handler: {method_name}")
+            self.sig_trace.emit("system", f"ERROR: Engine lacks handler: {method_name}")
             task.status = TaskStatus.FAILED
             return False
 
         if task.command in IMMEDIATE_COMMANDS:
-            self.sig_trace.emit(f"GUARD: IMMEDIATE {task.command} task={task.id}")
+            self.sig_trace.emit("system", f"GUARD: IMMEDIATE {task.command} task={task.id}")
             task.status = TaskStatus.RUNNING
             handler(task.payload)
             task.status = TaskStatus.DONE
             return True
 
         if self.active_tasks.get(task.target) is not None:
-            self.sig_trace.emit(f"GUARD: rejected task={task.id} target={task.target} (busy)")
+            self.sig_trace.emit("system", f"GUARD: rejected task={task.id} target={task.target} (busy)")
             return False
 
-        self.sig_trace.emit(f"GUARD: accepted task={task.id} target={task.target} command={task.command}")
+        self.sig_trace.emit("system", f"GUARD: accepted task={task.id} target={task.target} command={task.command}")
         self.active_tasks[task.target] = task
         task.status = TaskStatus.RUNNING
 
         if task.command in PAYLOAD_COMMANDS:
             handler(task.payload)
         else:
             handler()
         return True
 
     def stop(self, target: str = "all") -> None:
-        self.sig_trace.emit(f"GUARD: STOP target={target}")
+        self.sig_trace.emit("system", f"GUARD: STOP target={target}")
         if target == "all":
             keys = list(self.engines.keys())
         else:
             keys = [target]
 
         for key in keys:
             engine = self.engines.get(key)
             if not engine:
                 continue
             task = self.active_tasks.get(key)
             if task is not None:
                 self._stop_requested[key] = True
             engine.stop_generation()
 
     def _on_engine_finished(self, engine_key: str) -> None:
         task = self.active_tasks.get(engine_key)
         if task:
             self.sig_finished.emit(engine_key, str(task.id))
-            self.sig_trace.emit(f"GUARD: finished engine={engine_key} task={task.id}")
+            self.sig_trace.emit(engine_key, f"GUARD: finished engine={engine_key} task={task.id}")
 
     def _on_status_changed(self, engine_key: str, new_status: SystemStatus) -> None:
         self.sig_status.emit(engine_key, new_status)
 
         if new_status == SystemStatus.ERROR:
             task = self.active_tasks.get(engine_key)
             had_task = task is not None
             if task:
                 task.status = TaskStatus.FAILED
             self.active_tasks[engine_key] = None
             self._stop_requested[engine_key] = False
             self.sig_status.emit(engine_key, SystemStatus.READY)
             if had_task:
                 QTimer.singleShot(0, lambda: self.sig_engine_ready.emit(engine_key))
             return
 
         if new_status == SystemStatus.READY:
             task = self.active_tasks.get(engine_key)
             had_task = task is not None
             if task and task.status == TaskStatus.RUNNING:
                 if self._stop_requested.get(engine_key, False):
                     task.status = TaskStatus.CANCELLED
                 else:
                     task.status = TaskStatus.DONE
             self.active_tasks[engine_key] = None
             self._stop_requested[engine_key] = False
             if had_task:
                 QTimer.singleShot(0, lambda: self.sig_engine_ready.emit(engine_key))
 
 
     def enable_viztracer(self, enabled: bool) -> None:
         if enabled:
             if self._viztracer is not None:
                 return
             try:
                 from viztracer import VizTracer
             except Exception as exc:
-                self.sig_trace.emit(f"OVERSEER: viztracer unavailable: {exc}")
+                self.sig_trace.emit("system", f"OVERSEER: viztracer unavailable: {exc}")
                 return
             try:
                 self._viztracer = VizTracer(
                     min_duration=5000,
                     ignore_frozen=True,
                     exclude_files=["*/site-packages/*"],
                 )
             except TypeError:
                 self._viztracer = VizTracer(
                     min_duration=5000,
                     ignore_frozen=True,
                 )
             except Exception:
                 self._viztracer = VizTracer()
             self._viztracer.start()
-            self.sig_trace.emit("OVERSEER: viztracer started")
+            self.sig_trace.emit("system", "OVERSEER: viztracer started")
             return
 
         tracer = self._viztracer
         if tracer is None:
             return
         tracer.stop()
         ts = datetime.now().strftime("%Y%m%d_%H%M%S")
         out_path = LOG_DIR / f"viztrace_{ts}.json"
         tracer.save(str(out_path))
-        self.sig_trace.emit(f"OVERSEER: viztracer saved {out_path}")
+        self.sig_trace.emit("system", f"OVERSEER: viztracer saved {out_path}")
         self._viztracer = None
diff --git a/ui/addons/builtin.py b/ui/addons/builtin.py
index 7cdc84f194368598df6abbc45b49e533ef2bc0af..dedb638ed0406bae4b618e30b046c9707c58aabc 100644
--- a/ui/addons/builtin.py
+++ b/ui/addons/builtin.py
@@ -1,82 +1,129 @@
+import uuid
+
 from ui.addons.context import AddonContext
 from ui.addons.registry import AddonRegistry
 from ui.addons.spec import AddonSpec
 from ui.modules.injector import InjectorWidget
 from ui.modules.sd import SDModule
 from ui.modules.audiogen import AudioGenModule
 from ui.modules.manager import PageAddons
 from ui.pages.chat import PageChat
 from ui.pages.databank import PageFiles
 from ui.pages.hub import PageHub
 from core.operators import OperatorManager
+from engine.bridge import EngineBridge
+from engine.llm import LLMEngine
 
 
 def terminal_factory(ctx: AddonContext):
+    instance_id = str(uuid.uuid4())
+    engine_key = f"llm_{instance_id}"
+
+    llm_engine = LLMEngine(ctx.state)
+    engine_bridge = EngineBridge(llm_engine)
+    ctx.guard.register_engine(engine_key, engine_bridge)
+
     w = PageChat(ctx.state, ctx.ui_bridge)
+    w._mod_id = instance_id
+    w._engine_key = engine_key
     ctx.ui_bridge.sig_apply_operator.connect(w.apply_operator)
+    llm_engine.sig_model_capabilities.connect(w._on_model_capabilities)
+
+    w.sig_set_model_path.connect(
+        lambda path: ctx.bridge.submit(
+            ctx.bridge.wrap("terminal", "set_path", engine_key, payload={"path": path})
+        )
+    )
+    w.sig_set_ctx_limit.connect(
+        lambda limit: None if limit is None else ctx.bridge.submit(
+            ctx.bridge.wrap("terminal", "set_ctx_limit", engine_key, payload={"ctx_limit": int(limit)})
+        )
+    )
+
+    if w.config.get("gguf_path"):
+        w.sig_set_model_path.emit(str(w.config.get("gguf_path")))
+    w.sig_set_ctx_limit.emit(int(w.config.get("ctx_limit", 8192)))
+
     # outgoing (addon -> bridge)
     w.sig_generate.connect(
         lambda prompt, thinking_mode: ctx.bridge.submit(
             ctx.bridge.wrap(
                 "terminal",
                 "generate",
-                "llm",
-                payload={"prompt": prompt, "config": w.config, "thinking_mode": thinking_mode},
+                engine_key,
+                payload={
+                    "prompt": prompt,
+                    "config": w.config,
+                    "thinking_mode": thinking_mode,
+                    "ctx_limit": int(w.config.get("ctx_limit", 8192)),
+                },
             )
         )
     )
     w.sig_load.connect(
-        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "load", "llm"))
+        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "load", engine_key))
     )
     w.sig_unload.connect(
-        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "unload", "llm"))
+        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "unload", engine_key))
     )
-    w.sig_stop.connect(lambda: ctx.bridge.stop("llm"))
+    w.sig_stop.connect(lambda: ctx.bridge.stop(engine_key))
     w.sig_sync_history.connect(
         lambda history: ctx.bridge.submit(
             ctx.bridge.wrap(
                 "terminal",
                 "set_history",
-                "llm",
+                engine_key,
                 payload={"history": history},
             )
         )
     )
     ctx.guard.sig_status.connect(w.update_status)
     # incoming (guard -> addon)
-    ctx.guard.sig_token.connect(w.append_token)
-    ctx.guard.sig_trace.connect(w.append_trace)
+    ctx.guard.sig_token.connect(
+        lambda ek, t: w.append_token(t) if ek == engine_key else None
+    )
+    ctx.guard.sig_trace.connect(
+        lambda ek, m: w.append_trace(m) if ek == engine_key else None
+    )
     ctx.guard.sig_finished.connect(w.on_guard_finished)
+
+    def _cleanup_terminal(*_args):
+        ctx.guard.unregister_engine(engine_key)
+        engine_bridge.shutdown()
+
+    w.destroyed.connect(_cleanup_terminal)
     return w
 
 
 def addons_page_factory(ctx: AddonContext):
     w = PageAddons(ctx.state)
     # route launcher directly to host (host must exist)
     assert ctx.host is not None, "AddonHost must exist before addons page wiring"
     w.sig_launch_addon.connect(lambda addon_id: ctx.host.launch_module(addon_id))
+    w.sig_open_vitals.connect(lambda: ctx.ui.toggle_vitals() if ctx.ui else None)
+    w.sig_open_overseer.connect(ctx.ui_bridge.sig_open_overseer.emit)
     return w
 
 
 
 def hub_factory(ctx: AddonContext):
     manager = OperatorManager()
 
     def _current_terminal_config():
         if not ctx.ui:
             return {}
         for i in range(ctx.ui.stack.count()):
             widget = ctx.ui.stack.widget(i)
             if isinstance(widget, PageChat):
                 return dict(widget.config)
         return {}
 
     w = PageHub(config_provider=_current_terminal_config, operator_manager=manager)
 
     def _load_operator(name: str):
         try:
             operator_data = manager.load_operator(name)
         except Exception:
             return
         ctx.ui_bridge.sig_apply_operator.emit(operator_data)
 
diff --git a/ui/addons/host.py b/ui/addons/host.py
index 182c952aa9a5e82c8edc8bf57aa980f4eca3521e..2a95f8faead75cdc49b2cf08b12db12a647f2a36 100644
--- a/ui/addons/host.py
+++ b/ui/addons/host.py
@@ -17,51 +17,54 @@ class AddonHost:
     def mount_page(self, addon_id: str) -> QWidget:
         if addon_id in self._pages:
             return self._pages[addon_id]
 
         spec = self.registry.get(addon_id)
         if spec.kind != "page":
             raise ValueError(f"Addon '{addon_id}' is not a page")
         widget = spec.factory(self.ctx)
         self._pages[addon_id] = widget
         return widget
 
     def get_page_widget(self, addon_id: str) -> Optional[QWidget]:
         return self._pages.get(addon_id)
 
     def launch_module(self, addon_id: str) -> str:
         if not self.ctx.ui:
             raise RuntimeError("AddonHost requires UI for launching modules")
 
         try:
             spec = self.registry.get(addon_id)
             if spec.kind != "module":
                 raise ValueError(f"Addon '{addon_id}' is not a module")
             instance_id = str(uuid.uuid4())
             widget = spec.factory(self.ctx)
         except Exception as e:
-            self.ctx.guard.sig_trace.emit(f"<span style='color:red'>ADDON ERROR: {e}</span>")
+            self.ctx.guard.sig_trace.emit("system", f"<span style='color:red'>ADDON ERROR: {e}</span>")
             return ""
 
-        widget._mod_id = instance_id
+        if not hasattr(widget, "_mod_id"):
+            widget._mod_id = instance_id
+        else:
+            instance_id = widget._mod_id
         added_stack = False
         added_strip = False
         try:
             self.ctx.ui.stack.addWidget(widget)
             added_stack = True
             self.ctx.ui.module_strip.add_module(instance_id, spec.icon or "?", spec.title)
             added_strip = True
         except Exception:
             if added_strip:
                 self.ctx.ui.module_strip.remove_module(instance_id)
             if added_stack:
                 self.ctx.ui.stack.removeWidget(widget)
             widget.deleteLater()
             return ""
 
         if hasattr(widget, "sig_closed"):
             widget.sig_closed.connect(lambda: self.ctx.ui.close_module(instance_id))
         if hasattr(widget, "sig_finished"):
             widget.sig_finished.connect(lambda: self.ctx.ui.module_strip.flash_module(instance_id))
 
         self.ctx.ui.switch_to_module(instance_id)
         return instance_id
diff --git a/ui/bridge.py b/ui/bridge.py
index b6be12e28400e029e971a86d5254c17cc2945f56..0e732aaab1a8187c3d96d8a5ef89e5f9416ce417 100644
--- a/ui/bridge.py
+++ b/ui/bridge.py
@@ -1,8 +1,8 @@
 from PySide6.QtCore import QObject, Signal
 
 
 class UIBridge(QObject):
-    sig_terminal_header = Signal(str, str)
+    sig_terminal_header = Signal(str, str, str)
     sig_apply_operator = Signal(dict)
     sig_open_overseer = Signal()
     sig_overseer_viz_toggle = Signal(bool)
diff --git a/ui/components/message_widget.py b/ui/components/message_widget.py
index 84a832677d463dc7b570e5022210c56b68d14637..98703a04cd8478345835f413b1d0460ea25953d7 100644
--- a/ui/components/message_widget.py
+++ b/ui/components/message_widget.py
@@ -20,82 +20,84 @@ class _IconAction(QPushButton):
                 font-size: 12px;
                 padding: 0;
             }}
             QPushButton:hover {{
                 color: {ACCENT_GOLD};
             }}
         """)
 
 
 class MessageWidget(QWidget):
     sig_delete = Signal(int)
     sig_edit = Signal(int)
     sig_regen = Signal(int)
 
     def __init__(self, index: int, role: str, text: str, timestamp: str):
         super().__init__()
         self._index = index
         self._role = role
         self._content = text or ""
 
         self.setAttribute(Qt.WA_Hover, True)
 
         is_assistant = role == "assistant"
         is_system = role == "system"
         border_color = ACCENT_GOLD if is_assistant else "#1a1a1a"
-        # User messages: transparent, blend into list. Assistant: very subtle lift.
-        bg = "rgba(20, 20, 20, 180)" if is_assistant else "transparent"
+        bg = "transparent"
         if is_system:
             bg = "transparent"
             border_color = "#222"
 
         self.setStyleSheet(f"""
             MessageWidget {{
                 background: {bg};
                 border-left: 2px solid {border_color};
-                border-top: none; border-right: none; border-bottom: none;
+                border-top: none; border-right: none; border-bottom: 1px solid #222;
             }}
         """)
 
         root = QVBoxLayout(self)
-        root.setContentsMargins(10, 6, 10, 6)
+        root.setContentsMargins(10, 3, 10, 3)
         root.setSpacing(4)
 
         # --- Header row ---
         head = QHBoxLayout()
         head.setSpacing(6)
 
         role_color = ACCENT_GOLD if is_assistant else FG_TEXT
         if is_system:
             role_color = FG_DIM
         self.lbl_role = QLabel((role or "").upper())
         self.lbl_role.setStyleSheet(
             f"color: {role_color}; font-size: 9px; font-weight: bold; letter-spacing: 1px;"
         )
         head.addWidget(self.lbl_role)
 
-        self.lbl_time = QLabel(timestamp or "")
+        pretty_ts = (timestamp or "")
+        if "T" in pretty_ts and len(pretty_ts) >= 16:
+            pretty_ts = pretty_ts[11:16]
+        self.lbl_time = QLabel(pretty_ts)
         self.lbl_time.setStyleSheet(f"color: #444; font-size: 9px;")
         head.addWidget(self.lbl_time)
         head.addStretch()
 
         # --- Hover action icons ---
         self.actions = QWidget()
         self.actions.setStyleSheet("background: transparent;")
         actions_layout = QHBoxLayout(self.actions)
         actions_layout.setContentsMargins(0, 0, 0, 0)
         actions_layout.setSpacing(2)
 
         if not is_system:
             if role == "user":
                 self.btn_edit = _IconAction("✎", "Edit")
                 self.btn_edit.clicked.connect(lambda: self.sig_edit.emit(self._index))
                 actions_layout.addWidget(self.btn_edit)
 
             if is_assistant:
                 self.btn_regen = _IconAction("⟲", "Regenerate")
                 self.btn_regen.clicked.connect(lambda: self.sig_regen.emit(self._index))
                 actions_layout.addWidget(self.btn_regen)
 
             self.btn_delete = _IconAction("✕", "Delete")
             self.btn_delete.clicked.connect(lambda: self.sig_delete.emit(self._index))
             actions_layout.addWidget(self.btn_delete)
diff --git a/ui/main_window.py b/ui/main_window.py
index d4508e94e66190cee57b8e415744b4949fdecda6..f85d8c0f1f79f6e11272cff94f59ec8c77ef11ff 100644
--- a/ui/main_window.py
+++ b/ui/main_window.py
@@ -1,50 +1,51 @@
 from typing import Optional
 
 from PySide6.QtWidgets import (
     QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
     QFrame, QLabel, QStackedLayout
 )
 from PySide6.QtCore import Qt, QDateTime
 from PySide6.QtGui import QMouseEvent
 
 from core.state import SystemStatus, AppState
 from ui.bridge import UIBridge
 from core.style import BG_MAIN, BG_SIDEBAR, FG_ACCENT, FG_ERROR, FG_WARN
 from ui.addons.host import AddonHost
-from ui.components.atoms import SidebarButton, SkeetButton
+from ui.components.atoms import SidebarButton
 from ui.components.complex import GradientLine, VitalsWindow, SplitControlBlock, FlameLabel
 from ui.components.module_strip import ModuleStrip
 
 class MonolithUI(QMainWindow):
     def __init__(self, state: AppState, ui_bridge: UIBridge):
         super().__init__()
         self.state = state
         self.ui_bridge = ui_bridge
         self.vitals_win = None
         self._drag_pos = None
         self._chat_title = "Untitled Chat"
+        self._terminal_titles: dict[str, tuple[str, str]] = {}
 
         self.setWindowFlags(Qt.FramelessWindowHint)
         self.setAttribute(Qt.WA_TranslucentBackground)
         self.resize(1100, 700)
 
         main_widget = QWidget()
         main_widget.setObjectName("MainFrame")
         main_widget.setStyleSheet(f"""
             QWidget {{ background: {BG_MAIN}; }}
             QWidget#MainFrame {{ border: 1px solid #333; }}
         """)
         self.setCentralWidget(main_widget)
 
         root_layout = QVBoxLayout(main_widget)
         root_layout.setContentsMargins(1,1,1,1)
         root_layout.setSpacing(0)
 
         # Top Gradient
         self.gradient_line = GradientLine()
         root_layout.addWidget(self.gradient_line)
 
         # Top Bar
         self.top_bar = self._build_top_bar()
         root_layout.addWidget(self.top_bar)
 
@@ -130,103 +131,113 @@ class MonolithUI(QMainWindow):
             w = self.stack.widget(i)
             if getattr(w, '_mod_id', None) == mod_id:
                 target_w = w
                 break
         
         if target_w:
             self.stack.removeWidget(target_w)
             target_w.deleteLater()
             
         self.module_strip.remove_module(mod_id)
 
         if current == target_w:
             remaining = self.module_strip.get_order()
             if remaining:
                 self.switch_to_module(remaining[-1])
             else:
                 self.set_page("empty")
 
     def switch_to_module(self, mod_id):
         for i in range(self.stack.count()):
             w = self.stack.widget(i)
             if getattr(w, '_mod_id', None) == mod_id:
                 self.stack.setCurrentWidget(w)
                 self._update_sidebar_state(module_selection=True)
                 self.module_strip.select_module(mod_id)
+                self.update_terminal_header(mod_id, *self._terminal_titles.get(mod_id, ("Untitled Chat", QDateTime.currentDateTime().toString("ddd • HH:mm"))))
                 return
 
     def _update_sidebar_state(self, page_idx=None, module_selection=False):
         self.btn_hub.setChecked(page_idx == "hub" and not module_selection)
         self.btn_addons.setChecked(page_idx == "addons" and not module_selection)
         if not module_selection: self.module_strip.deselect_all()
 
     def update_status(self, engine_key: str, status: SystemStatus):
         if status == SystemStatus.ERROR:
             self.lbl_status.setStyleSheet(f"color: {FG_ERROR}; font-size: 10px; font-weight: bold;")
         elif status == SystemStatus.LOADING:
             self.lbl_status.setStyleSheet(f"color: {FG_WARN}; font-size: 10px; font-weight: bold;")
         else:
             self.lbl_status.setStyleSheet(f"color: {FG_ACCENT}; font-size: 10px; font-weight: bold;")
         status_text = status.value if hasattr(status, "value") else str(status)
-        if engine_key != "llm":
+        if not engine_key.startswith("llm"):
             status_text = f"{engine_key.upper()}: {status_text}"
         self.lbl_status.setText(status_text)
 
     def update_ctx(self, used):
         self.state.ctx_used = used
 
-    def update_terminal_header(self, title, timestamp):
-        self._chat_title = title or "Untitled Chat"
-        self.lbl_chat_title.setText(self._chat_title)
-        self.lbl_chat_time.setText(timestamp or QDateTime.currentDateTime().toString("ddd • HH:mm"))
+    def update_terminal_header(self, mod_id, title, timestamp):
+        if mod_id:
+            self._terminal_titles[mod_id] = (title or "Untitled Chat", timestamp or QDateTime.currentDateTime().toString("ddd • HH:mm"))
+
+        current = self.stack.currentWidget()
+        current_mod = getattr(current, "_mod_id", None) if current is not None else None
+        if not current_mod:
+            self.lbl_chat_title.clear()
+            self.lbl_chat_time.clear()
+            self.lbl_chat_title.hide()
+            self.lbl_chat_time.hide()
+            return
+
+        current_title, current_time = self._terminal_titles.get(
+            current_mod,
+            ("Untitled Chat", QDateTime.currentDateTime().toString("ddd • HH:mm")),
+        )
+        if current_mod == mod_id or mod_id == "":
+            self.lbl_chat_title.setText(current_title)
+            self.lbl_chat_time.setText(current_time)
+            self.lbl_chat_title.show()
+            self.lbl_chat_time.show()
 
     def set_page(self, page_id):
         target = self.pages.get(page_id)
         if target:
             self.stack.setCurrentWidget(target)
         self._update_sidebar_state(page_idx=page_id)
+        self.update_terminal_header("", "", "")
 
     def _build_top_bar(self):
         bar = QFrame()
         bar.setFixedHeight(35)
         bar.setStyleSheet("background: #111; border-bottom: 1px solid #222;")
         layout = QHBoxLayout(bar)
         layout.setContentsMargins(10, 0, 10, 0)
 
         self.lbl_status = QLabel("READY")
         self.lbl_status.setStyleSheet(f"color: {FG_ACCENT}; font-size: 10px; font-weight: bold;")
 
-        btn_vitals = SkeetButton("VITALS")
-        btn_vitals.setFixedSize(75, 26)
-        btn_vitals.clicked.connect(self.toggle_vitals)
-
-        btn_overseer = SkeetButton("OVERSEER")
-        btn_overseer.setFixedSize(95, 26)
-        btn_overseer.clicked.connect(self.ui_bridge.sig_open_overseer.emit)
-
-        layout.addWidget(btn_vitals)
-        layout.addWidget(btn_overseer)
         layout.addWidget(self.lbl_status)
         layout.addStretch()
 
         self.lbl_model = FlameLabel("MONOLITH")
         layout.addWidget(self.lbl_model)
         layout.addStretch()
 
         self.lbl_chat_title = QLabel(self._chat_title)
         self.lbl_chat_title.setStyleSheet("color: #dcdcdc; font-size: 10px; font-weight: bold;")
         self.lbl_chat_time = QLabel(QDateTime.currentDateTime().toString("ddd • HH:mm"))
         self.lbl_chat_time.setStyleSheet("color: #777; font-size: 10px;")
         title_box = QVBoxLayout()
         title_box.setContentsMargins(0, 0, 8, 0)
         title_box.setSpacing(0)
         title_box.addWidget(self.lbl_chat_title, alignment=Qt.AlignRight)
         title_box.addWidget(self.lbl_chat_time, alignment=Qt.AlignRight)
         layout.addLayout(title_box)
 
         self.win_controls = SplitControlBlock()
         self.win_controls.minClicked.connect(self.showMinimized)
         self.win_controls.maxClicked.connect(self.toggle_maximize)
         self.win_controls.closeClicked.connect(self.close)
         layout.addWidget(self.win_controls)
 
         return bar
diff --git a/ui/modules/manager.py b/ui/modules/manager.py
index 89dc02b7a8164106c8a97f44f12de6954f945e09..14e156e9d8fbab6b9b2d630eba6679bf7f5327ae 100644
--- a/ui/modules/manager.py
+++ b/ui/modules/manager.py
@@ -1,60 +1,77 @@
 from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QScrollArea
 from PySide6.QtCore import Signal, Qt
 
 from ui.components.atoms import SkeetGroupBox, SkeetButton
 from core.style import FG_DIM
 
 class PageAddons(QWidget):
     sig_launch_addon = Signal(str)
+    sig_open_vitals = Signal()
+    sig_open_overseer = Signal()
 
     def __init__(self, state):
         super().__init__()
         
         layout = QVBoxLayout(self)
         layout.setContentsMargins(20, 20, 20, 20)
         
         scroll_area = QScrollArea()
         scroll_area.setWidgetResizable(True)
         scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
         scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
 
         scroll_content = QWidget()
         scroll_layout = QVBoxLayout(scroll_content)
         scroll_layout.setContentsMargins(0, 0, 0, 0)
 
         grp_modules = SkeetGroupBox("AVAILABLE MODULES")
         
         mod_layout = QVBoxLayout()
         mod_layout.setSpacing(15)
         
         lbl_info = QLabel("Select a runtime module to attach to the workspace.")
         lbl_info.setStyleSheet(f"color: {FG_DIM}; font-size: 11px;")
 
         btn_terminal = SkeetButton("TERMINAL")
         btn_terminal.clicked.connect(lambda: self.sig_launch_addon.emit("terminal"))
 
         btn_databank = SkeetButton("DATABANK")
         btn_databank.clicked.connect(lambda: self.sig_launch_addon.emit("databank"))
 
         btn_injector = SkeetButton("INJECTOR")
         btn_injector.clicked.connect(lambda: self.sig_launch_addon.emit("injector"))
 
         btn_sd = SkeetButton("VISION")
         btn_sd.clicked.connect(lambda: self.sig_launch_addon.emit("sd"))
 
         btn_audiogen = SkeetButton("AUDIO")
         btn_audiogen.clicked.connect(lambda: self.sig_launch_addon.emit("audiogen"))
 
         mod_layout.addWidget(lbl_info)
         mod_layout.addWidget(btn_terminal)
         mod_layout.addWidget(btn_databank)
         mod_layout.addWidget(btn_injector)
         mod_layout.addWidget(btn_sd)
         mod_layout.addWidget(btn_audiogen)
         mod_layout.addStretch()
         
         grp_modules.add_layout(mod_layout)
         scroll_layout.addWidget(grp_modules)
+        
+        grp_system = SkeetGroupBox("SYSTEM")
+        system_layout = QVBoxLayout()
+        system_layout.setSpacing(10)
+
+        btn_vitals = SkeetButton("VITALS")
+        btn_vitals.clicked.connect(self.sig_open_vitals.emit)
+
+        btn_overseer = SkeetButton("OVERSEER")
+        btn_overseer.clicked.connect(self.sig_open_overseer.emit)
+
+        system_layout.addWidget(btn_vitals)
+        system_layout.addWidget(btn_overseer)
+        grp_system.add_layout(system_layout)
+        scroll_layout.addWidget(grp_system)
         scroll_layout.addStretch()
         scroll_area.setWidget(scroll_content)
         layout.addWidget(scroll_area)
diff --git a/ui/modules/sd.py b/ui/modules/sd.py
index 9a7e086a4ad35f394dbc7ab677f6929074a12bbf..0de76b370f4738c0ba31c67102833c54220c1537 100644
--- a/ui/modules/sd.py
+++ b/ui/modules/sd.py
@@ -219,51 +219,51 @@ class SDModule(QWidget):
         # Status
         status_row = QHBoxLayout()
         lbl_status_title = QLabel("Status")
         lbl_status_title.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
         self.lbl_status = QLabel("IDLE")
         self.lbl_status.setStyleSheet(f"color: {FG_TEXT}; font-size: 10px; font-weight: bold;")
         status_row.addWidget(lbl_status_title)
         status_row.addStretch()
         status_row.addWidget(self.lbl_status)
 
         inner.addWidget(lbl_prompt)
         inner.addWidget(self.inp_prompt)
         inner.addLayout(btn_row)
         inner.addWidget(preview_scroll)
         inner.addLayout(status_row)
         inner.addStretch()
 
         grp.add_layout(inner)
         layout.addWidget(grp)
 
         self.inp_steps.valueChanged.connect(self._queue_save_config)
         self.inp_strength.valueChanged.connect(self._queue_save_config)
         self.inp_seed.valueChanged.connect(self._queue_save_config)
         self.guard.sig_image.connect(self._on_image)
         self.guard.sig_status.connect(self._on_status)
-        self.guard.sig_trace.connect(self._on_trace)
+        self.guard.sig_trace.connect(lambda _engine_key, message: self._on_trace(message))
 
     def _load_config(self):
         if self.config_path.exists():
             try:
                 with open(self.config_path, 'r') as f:
                     config = json.load(f)
                 return self._normalize_config(config)
             except Exception:
                 pass
         if self.legacy_config_path.exists():
             try:
                 with open(self.legacy_config_path, 'r') as f:
                     config = json.load(f)
                 config = self._normalize_config(config)
                 with open(self.config_path, 'w') as f:
                     json.dump(config, f, indent=2)
                 return config
             except Exception:
                 pass
         return {
             "model_path": "",
             "steps": 25,
             "guidance_scale": 7.5,
             "seed": -1
         }
diff --git a/ui/overseer.py b/ui/overseer.py
index 9228300ff5a0891582dfc8b77fd08a1b7b52d2f0..37e6fb3ff7e395447121d96b5d6fccd7dc531a9f 100644
--- a/ui/overseer.py
+++ b/ui/overseer.py
@@ -304,51 +304,51 @@ class OverseerWindow(QMainWindow):
         self.btn_clear.setCursor(Qt.PointingHandCursor)
         self.btn_clear.setFixedHeight(22)
         self.btn_clear.setStyleSheet(f"""
             QPushButton {{
                 background: transparent;
                 border: 1px solid {OVERSEER_BORDER};
                 color: {OVERSEER_DIM};
                 padding: 2px 10px; font-size: 9px; font-weight: bold;
                 border-radius: 2px;
             }}
             QPushButton:hover {{ border: 1px solid {FG_ERROR}; color: {FG_ERROR}; }}
         """)
         self.btn_clear.clicked.connect(self.log_display.clear)
 
         self.chk_viz = QCheckBox("VIZTRACER")
         self.chk_viz.setStyleSheet(ctrl_style)
         self.chk_viz.toggled.connect(self.ui_bridge.sig_overseer_viz_toggle.emit)
 
         controls_layout.addWidget(self.chk_pause)
         controls_layout.addWidget(self.btn_clear)
         controls_layout.addWidget(self.chk_viz)
         controls_layout.addStretch()
         main_layout.addLayout(controls_layout)
 
         # --- Signal connections ---
-        self.guard.sig_trace.connect(self._on_trace)
+        self.guard.sig_trace.connect(lambda _engine_key, msg: self._on_trace(msg))
         self.guard.sig_status.connect(self._on_status)
         self.guard.sig_finished.connect(self._on_finished)
 
         self._poll_timer = QTimer(self)
         self._poll_timer.setInterval(300)
         self._poll_timer.timeout.connect(self._refresh_active_tasks)
         self._poll_timer.start()
 
     # ---- Filtering ----
 
     def _is_severity_visible(self, severity: str) -> bool:
         f = self._severity_filters.get(severity.upper())
         return f.is_active() if f else True
 
     def _apply_recipe(self, recipe_name: str):
         active = _RECIPE_PRESETS.get(recipe_name, set())
         for sev, filt in self._severity_filters.items():
             filt.set_active(sev in active)
 
     # ---- Log helpers ----
 
     def _append_line(self, severity: str, text: str) -> None:
         if self._paused:
             return
         if not self._is_severity_visible(severity):
diff --git a/ui/pages/chat.py b/ui/pages/chat.py
index 25d7ef82a5d8826942bbd97195aecc9dd4a21e8e..c145c159e5b2ab58de02ca102bbc6f610fe5ddb7 100644
--- a/ui/pages/chat.py
+++ b/ui/pages/chat.py
@@ -4,86 +4,84 @@ from datetime import datetime, timezone
 from pathlib import Path
 
 from PySide6.QtWidgets import (
     QWidget, QVBoxLayout, QHBoxLayout, QPlainTextEdit,
     QLineEdit, QPushButton, QLabel, QFileDialog,
     QSplitter, QListWidget, QListWidgetItem, QStackedWidget,
     QMessageBox, QButtonGroup, QMenu
 )
 from PySide6.QtCore import Signal, Qt, QTimer, QDateTime
 from PySide6.QtGui import QActionGroup
 
 from core.state import SystemStatus
 from core.style import BG_INPUT, FG_DIM, FG_TEXT, ACCENT_GOLD, FG_ERROR, SCROLLBAR_STYLE
 from ui.components.atoms import SkeetGroupBox, SkeetButton, SkeetSlider
 from ui.components.complex import BehaviorTagInput
 from ui.components.message_widget import MessageWidget
 from core.llm_config import DEFAULT_CONFIG, MASTER_PROMPT, load_config, save_config
 from core.paths import ARCHIVE_DIR
 
 class PageChat(QWidget):
     sig_generate = Signal(str, bool)
     sig_load = Signal()
     sig_unload = Signal()
     sig_stop = Signal()
     sig_sync_history = Signal(list)
+    sig_set_model_path = Signal(str)
+    sig_set_ctx_limit = Signal(int)
     sig_operator_loaded = Signal(str)
 
     def __init__(self, state, ui_bridge):
         super().__init__()
         self.state = state
         self.ui_bridge = ui_bridge
         self.config = load_config()
-        self.state.gguf_path = self.config.get("gguf_path")
-        self.state.ctx_limit = int(self.config.get("ctx_limit", self.state.ctx_limit))
         self._token_buf: list[str] = []
         self._flush_timer = QTimer(self)
         self._flush_timer.setInterval(25)
         self._flush_timer.timeout.connect(self._flush_tokens)
         self._archive_dir = self._get_archive_dir()
         self._archive_dir.mkdir(parents=True, exist_ok=True)
         self._session_counter = 0
         self._current_session = self._create_session()
         self._undo_snapshot = None
         self._title_generated = False
         self._suppress_title_regen = False
         self._active_assistant_index = None
         self._rewrite_assistant_index = None
         self._active_widget: MessageWidget | None = None
         self._last_status = None
         self._is_running = False
+        self._is_model_loaded = False
         self._pending_update_text = None
         self._awaiting_update_restart = False
         self._update_trace_state = None
         self._update_token_count = 0
         self._update_progress_index = 0
         self._config_dirty = False
         self._thinking_mode = bool(self.config.get("thinking_mode", False))
 
-        capabilities_signal = getattr(self.state, "sig_model_capabilities", None)
-        if capabilities_signal is not None:
-            capabilities_signal.connect(self._on_model_capabilities)
 
         layout = QVBoxLayout(self)
         layout.setContentsMargins(20, 20, 20, 20)
         layout.setSpacing(20)
 
         main_split = QSplitter(Qt.Horizontal)
         main_split.setChildrenCollapsible(False)
         layout.addWidget(main_split)
 
         # === MODEL LOADER (lives in CONTROL tab) ===
         grp_load = SkeetGroupBox("MODEL LOADER")
         self.path_display = QLineEdit()
         self.path_display.setReadOnly(True)
         self.path_display.setPlaceholderText("No GGUF Selected")
         self.path_display.setStyleSheet(
             f"background: {BG_INPUT}; color: #555; border: 1px solid #333; padding: 5px;"
         )
         btn_browse = SkeetButton("...")
         btn_browse.setFixedWidth(30)
         btn_browse.clicked.connect(self.pick_file)
         row_file = QHBoxLayout()
         row_file.addWidget(self.path_display)
         row_file.addWidget(btn_browse)
         self.btn_load = SkeetButton("LOAD MODEL")
         self.btn_load.clicked.connect(self.toggle_load)
@@ -176,103 +174,102 @@ class PageChat(QWidget):
         self.btn_load_chat = SkeetButton("LOAD")
         self.btn_load_chat.clicked.connect(self._load_chat_archive)
         self.btn_delete_chat = SkeetButton("DELETE")
         self.btn_delete_chat.clicked.connect(self._delete_selected_archive)
         self.btn_clear_chat = SkeetButton("CLEAR")
         self.btn_clear_chat.clicked.connect(lambda: self._clear_current_session(delete_archive=False))
         archive_controls.addWidget(self.btn_save_chat)
         archive_controls.addWidget(self.btn_load_chat)
         archive_controls.addWidget(self.btn_delete_chat)
         archive_controls.addWidget(self.btn_clear_chat)
         archive_controls.addStretch()
         archive_layout.addLayout(archive_controls)
 
         self.archive_list = QListWidget()
         self.archive_list.setStyleSheet(f"""
             QListWidget {{
                 background: {BG_INPUT}; color: {FG_TEXT}; border: 1px solid #222;
                 font-family: 'Consolas', monospace; font-size: 10px;
             }}
             QListWidget::item {{ padding: 6px; }}
             QListWidget::item:selected {{ background: #222; color: {ACCENT_GOLD}; }}
             {SCROLLBAR_STYLE}
         """)
         archive_layout.addWidget(self.archive_list)
 
+        self.lbl_behavior = QLabel("BEHAVIOR TAGS")
+        self.lbl_behavior.setStyleSheet(
+            f"color: #444; font-size: 8px; font-weight: bold; letter-spacing: 1px;"
+        )
+        self.behavior_tags = BehaviorTagInput([])
+        self.behavior_tags.tagsChanged.connect(self._on_behavior_tags_changed)
+        self.behavior_tags.setStyleSheet(
+            f"background: #111; border: 1px solid #1a1a1a; border-radius: 2px;"
+        )
+        self.behavior_tags.setMaximumHeight(36)
+
         # --- SETTINGS tab: AI Configuration + Save/Reset ---
         settings_tab = QWidget()
         settings_layout = QVBoxLayout(settings_tab)
         settings_layout.setSpacing(10)
         settings_layout.addWidget(self.s_temp)
         settings_layout.addWidget(self.s_top)
         settings_layout.addWidget(self.s_tok)
         settings_layout.addWidget(self.s_ctx)
+        settings_layout.addWidget(self.lbl_behavior)
+        settings_layout.addWidget(self.behavior_tags)
         settings_layout.addLayout(save_row)
         settings_layout.addStretch()
 
         self.ops_stack.addWidget(control_tab)
         self.ops_stack.addWidget(archive_tab)
         self.ops_stack.addWidget(settings_tab)
         self.btn_tab_control.toggled.connect(lambda checked: self._switch_ops_tab(0, checked))
         self.btn_tab_archive.toggled.connect(lambda checked: self._switch_ops_tab(1, checked))
         self.btn_tab_settings.toggled.connect(lambda checked: self._switch_ops_tab(2, checked))
 
         operations_group.add_layout(operations_layout)
 
         chat_group = SkeetGroupBox("TERMINAL")
         chat_layout = QVBoxLayout()
         chat_layout.setSpacing(10)
 
         self.message_list = QListWidget()
         self.message_list.setStyleSheet(f"""
             QListWidget {{
                 background: #111; color: #ccc; border: 1px solid #222;
                 font-family: 'Consolas', monospace; font-size: 12px;
             }}
             QListWidget::item {{
                 border: none;
                 background: transparent;
                 padding: 0px;
             }}
             {SCROLLBAR_STYLE}
         """)
         chat_layout.addWidget(self.message_list)
         
-        # --- Behavior tags (above input, tag system) ---
-        lbl_behavior = QLabel("BEHAVIOR TAGS")
-        lbl_behavior.setStyleSheet(
-            f"color: #444; font-size: 8px; font-weight: bold; letter-spacing: 1px;"
-        )
-        self.behavior_tags = BehaviorTagInput([])
-        self.behavior_tags.tagsChanged.connect(self._on_behavior_tags_changed)
-        self.behavior_tags.setStyleSheet(
-            f"background: #111; border: 1px solid #1a1a1a; border-radius: 2px;"
-        )
-        self.behavior_tags.setMaximumHeight(36)
-        chat_layout.addWidget(lbl_behavior)
-        chat_layout.addWidget(self.behavior_tags)
-
         # --- Input toolbar (between separator and input box) ---
         input_toolbar = QHBoxLayout()
         input_toolbar.setContentsMargins(0, 0, 0, 0)
         input_toolbar.setSpacing(4)
 
         # [+] Actions menu button
         self.btn_actions = QPushButton("＋")
         self.btn_actions.setCursor(Qt.PointingHandCursor)
         self.btn_actions.setFixedSize(26, 22)
         self.btn_actions.setToolTip("Actions")
         self.btn_actions.setStyleSheet(f"""
             QPushButton {{
                 background: transparent; border: 1px solid #222;
                 color: {FG_DIM}; font-size: 14px; font-weight: bold;
                 border-radius: 2px; padding: 0;
             }}
             QPushButton:hover {{ color: {ACCENT_GOLD}; border: 1px solid {ACCENT_GOLD}; }}
         """)
         self.actions_menu = QMenu(self)
         self.actions_menu.setStyleSheet(f"""
             QMenu {{
                 background: #141414; border: 1px solid #333; color: {FG_TEXT};
                 font-size: 10px; padding: 4px;
             }}
             QMenu::item {{ padding: 6px 20px; }}
@@ -388,51 +385,51 @@ class PageChat(QWidget):
         self.lbl_config_update.setStyleSheet(f"color: {ACCENT_GOLD}; font-size: 10px; font-weight: bold;")
         self.lbl_config_update.hide()
         self._config_update_fade = QTimer(self)
         self._config_update_fade.setSingleShot(True)
         self._config_update_fade.timeout.connect(self.lbl_config_update.hide)
         trace_group.add_widget(self.trace)
         trace_group.add_widget(self.lbl_config_update)
 
         right_stack.addWidget(trace_group)
         right_stack.addWidget(operations_group)
         right_stack.setStretchFactor(0, 1)
         right_stack.setStretchFactor(1, 1)
         right_stack.setSizes([200, 200])
 
         main_split.addWidget(chat_group)
         main_split.addWidget(right_stack)
         main_split.setStretchFactor(0, 3)
         main_split.setStretchFactor(1, 2)
 
         self._sync_path_display()
         self._update_load_button_text()
         self._refresh_archive_list()
         self._apply_behavior_prompt(self.config.get("behavior_tags", []))
         self.behavior_tags.set_tags(self.config.get("behavior_tags", []))
         self._set_config_dirty(False)
-        if not self.state.model_loaded:
+        if not self._is_model_loaded:
             self._apply_default_limits()
 
     def send(self):
         txt = self.input.text().strip()
         if not txt:
             return
         self._set_send_button_state(is_running=True)
         self.input.clear()
         user_idx = self._add_message("user", txt)
         self._append_message_widget(user_idx)
         self._start_assistant_stream()
         self.message_list.scrollToBottom()
         self.sig_generate.emit(txt, self._thinking_mode)
 
     def handle_send_click(self):
         txt = self.input.text().strip()
 
         if not self._is_running:
             self.send()
             return
 
         if not txt:
             self._set_send_button_state(is_running=True, stopping=True)
             self.sig_stop.emit()
             return
@@ -529,99 +526,106 @@ Continue from the interruption point. Do not repeat earlier content.
         if self._active_widget is None:
             target_index = self._rewrite_assistant_index
             if target_index is None:
                 target_index = self._active_assistant_index
             if target_index is not None:
                 self._active_widget = self._widget_for_index(target_index)
         if self._active_widget is None:
             return
         self._active_widget.append_token(chunk)
         for row in range(self.message_list.count()):
             item = self.message_list.item(row)
             widget = self.message_list.itemWidget(item)
             if widget is self._active_widget:
                 item.setSizeHint(widget.sizeHint())
                 break
         self.message_list.scrollToBottom()
 
     def append_token(self, t):
         self._token_buf.append(t)
         self._append_assistant_token(t)
         self._update_progress_markers()
         if not self._flush_timer.isActive():
             self._flush_timer.start()
 
     def on_guard_finished(self, engine_key, task_id):
-        if engine_key != "llm":
+        if engine_key != getattr(self, "_engine_key", "llm"):
             return
         if not self._current_session.get("messages"):
             return
         try:
             self._save_chat_archive()
         except Exception:
             pass
 
     def append_trace(self, trace_msg):
         lowered = trace_msg.lower()
 
         # --- Filter: only show LLM-relevant trace info ---
         # Skip guard internals, status transitions, and noise
         skip_patterns = [
             "guard", "dispatch", "route", "bridge", "dock",
             "addon", "registry", "host", "mount",
         ]
         for pat in skip_patterns:
             if pat in lowered and "error" not in lowered:
                 return
 
         # Categorize what we show
+        if "system online" in lowered:
+            self._is_model_loaded = True
+        elif "model unloaded" in lowered:
+            self._is_model_loaded = False
+
         if "error" in lowered:
             state = "ERROR"
         elif "token" in lowered:
             state = "TOKENIZING"
         elif "inference started" in lowered:
             state = "INFERENCE"
         elif "inference" in lowered and ("complete" in lowered or "aborted" in lowered):
             state = "COMPLETE"
         elif "init backend" in lowered or "system online" in lowered:
             state = "MODEL"
         elif "unload" in lowered or "cancel" in lowered:
             state = "MODEL"
         elif "ctx" in lowered or "context" in lowered:
             state = "CTX"
         else:
             state = "INFO"
 
-        self.trace.appendPlainText(f"[{state}] {trace_msg}")
+        indent = "" if state == "ERROR" else "    "
+        self.trace.appendPlainText(f"{indent}[{state}] {trace_msg}")
 
     def clear_chat(self):
         self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
 
     def _sync_path_display(self):
-        if self.state.gguf_path:
-            self.path_display.setText(self.state.gguf_path)
-            self.path_display.setToolTip(self.state.gguf_path)
+        gguf_path = self.config.get("gguf_path")
+        if gguf_path:
+            self.path_display.setText(gguf_path)
+            self.path_display.setToolTip(str(gguf_path))
         else:
             self.path_display.clear()
             self.path_display.setToolTip("")
 
     def _set_config_dirty(self, dirty=True):
         self._config_dirty = dirty
         self.lbl_config_state.setText("UNSAVED" if dirty else "SAVED")
         self.lbl_config_state.setStyleSheet(
             f"color: {ACCENT_GOLD if dirty else FG_DIM}; font-size: 10px; font-weight: bold;"
         )
         # Save button: gold when dirty (action needed), gray when clean
         if dirty:
             self.btn_save_config.setStyleSheet(f"""
                 QPushButton {{ background: #181818; border: 1px solid {ACCENT_GOLD}; color: {ACCENT_GOLD}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                 QPushButton:hover {{ background: {ACCENT_GOLD}; color: black; }}
                 QPushButton:pressed {{ background: #b08d2b; color: black; }}
             """)
         else:
             self.btn_save_config.setStyleSheet(f"""
                 QPushButton {{ background: #181818; border: 1px solid #333; color: {FG_DIM}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                 QPushButton:hover {{ background: #222; color: {FG_DIM}; }}
             """)
 
     def _save_config(self):
         save_config(self.config)
@@ -674,52 +678,52 @@ Continue from the interruption point. Do not repeat earlier content.
             self._apply_default_limits()
             return
         configured_ctx = int(self.config.get("ctx_limit", 8192))
         self._set_slider_limits(self.s_ctx, model_ctx_length, model_ctx_length)
         self._set_slider_limits(
             self.s_tok,
             model_ctx_length,
             min(8192, model_ctx_length),
         )
         # Surface context capacity info in reasoning trace
         if configured_ctx < model_ctx_length:
             pct = int((configured_ctx / model_ctx_length) * 100)
             self.trace.appendPlainText(
                 f"[CTX] Context: {configured_ctx:,} / {model_ctx_length:,} tokens "
                 f"({pct}% of model capacity)"
             )
             self.trace.appendPlainText(
                 f"[CTX] Increase context limit in SETTINGS to use full {model_ctx_length:,} capacity"
             )
         else:
             self.trace.appendPlainText(
                 f"[CTX] Context: {model_ctx_length:,} tokens (full capacity)"
             )
 
     def _on_ctx_limit_changed(self, value):
-        self.state.ctx_limit = int(value)
         self._update_config_value("ctx_limit", int(value))
+        self.sig_set_ctx_limit.emit(int(value))
 
     def _on_behavior_tags_changed(self, tags):
         self._apply_behavior_prompt(tags)
 
     def _on_thinking_mode_toggled(self, checked):
         self._thinking_mode = bool(checked)
         self.config["thinking_mode"] = self._thinking_mode
         self._set_config_dirty(True)
         self._update_thinking_button_style()
 
     def _set_thinking_mode(self, enabled, label="Off"):
         self._thinking_mode = enabled
         self.config["thinking_mode"] = enabled
         self._set_config_dirty(True)
         self.btn_thinking.setText(label.upper() if enabled else "THINK")
         self._update_thinking_button_style()
 
     def _update_thinking_button_style(self):
         active = self._thinking_mode
         color = ACCENT_GOLD if active else FG_DIM
         border = ACCENT_GOLD if active else "#333"
         self.btn_thinking.setStyleSheet(f"""
             QPushButton {{
                 background: transparent; border: 1px solid {border};
                 color: {color}; padding: 2px 10px;
@@ -730,159 +734,167 @@ Continue from the interruption point. Do not repeat earlier content.
 
     def _attach_file_placeholder(self):
         """Placeholder for file attachment — backend will be implemented later."""
         pass
 
     def _reset_config(self):
         """Reset all settings to DEFAULT_CONFIG values."""
         for key, val in DEFAULT_CONFIG.items():
             self.config[key] = val
         self.s_temp.slider.blockSignals(True)
         self.s_top.slider.blockSignals(True)
         self.s_tok.slider.blockSignals(True)
         self.s_ctx.slider.blockSignals(True)
         self.s_temp.slider.setValue(int(DEFAULT_CONFIG["temp"] * 100))
         self.s_temp.val_lbl.setText(f"{DEFAULT_CONFIG['temp']:.2f}")
         self.s_top.slider.setValue(int(DEFAULT_CONFIG["top_p"] * 100))
         self.s_top.val_lbl.setText(f"{DEFAULT_CONFIG['top_p']:.2f}")
         self.s_tok.slider.setValue(int(DEFAULT_CONFIG["max_tokens"]))
         self.s_tok.val_lbl.setText(str(int(DEFAULT_CONFIG["max_tokens"])))
         self.s_ctx.slider.setValue(int(DEFAULT_CONFIG["ctx_limit"]))
         self.s_ctx.val_lbl.setText(str(int(DEFAULT_CONFIG["ctx_limit"])))
         self.s_temp.slider.blockSignals(False)
         self.s_top.slider.blockSignals(False)
         self.s_tok.slider.blockSignals(False)
         self.s_ctx.slider.blockSignals(False)
-        self.state.ctx_limit = int(DEFAULT_CONFIG["ctx_limit"])
+        self.sig_set_ctx_limit.emit(int(DEFAULT_CONFIG["ctx_limit"]))
         self.behavior_tags.set_tags(DEFAULT_CONFIG.get("behavior_tags", []))
         self._set_thinking_mode(False)
         self._set_config_dirty(True)
 
     def pick_file(self):
         path, _ = QFileDialog.getOpenFileName(self, "Select GGUF", "", "GGUF (*.gguf)")
         if path:
-            self.state.gguf_path = path
             self.config["gguf_path"] = path
+            self.sig_set_model_path.emit(path)
             self._sync_path_display()
             self._set_config_dirty(True)
 
     def toggle_load(self):
-        if self.state.model_loaded:
+        if self._is_model_loaded:
             self.sig_unload.emit()
         else:
             self.sig_load.emit()
 
     def _update_load_button_text(self):
-        self.btn_load.setText("UNLOAD MODEL" if self.state.model_loaded else "LOAD MODEL")
+        self.btn_load.setText("UNLOAD MODEL" if self._is_model_loaded else "LOAD MODEL")
 
     def update_status(self, engine_key: str, status: SystemStatus):
-        if engine_key != "llm":
+        if engine_key != getattr(self, "_engine_key", "llm"):
             return
         is_loading = status in (SystemStatus.LOADING, SystemStatus.RUNNING)
         self.btn_load.setEnabled(not is_loading)
         if is_loading:
             self.btn_load.setText("PROCESSING...")
         else:
             self._update_load_button_text()
         if status == SystemStatus.READY and self._awaiting_update_restart:
             self._awaiting_update_restart = False
             self.btn_send.setEnabled(True)
 
             update_text = self._pending_update_text
             self._pending_update_text = None
             self._submit_update(update_text)
             return
         if status == SystemStatus.RUNNING:
             self._set_send_button_state(is_running=True)
         elif status == SystemStatus.READY:
+            if self._last_status == SystemStatus.LOADING:
+                self._is_model_loaded = True
             self._set_send_button_state(is_running=False)
             self._rewrite_assistant_index = None
             if self._active_widget is not None:
                 self._active_widget.finalize()
             self._active_widget = None
             if self._update_trace_state == "streaming":
                 self._finalize_update_progress()
             # Title generation is finalized ONLY on READY.
             # READY is emitted after _on_gen_finish completes and assistant text is final.
             # STOP also transitions to READY; _maybe_generate_title self-guards.
             # Do NOT call this method from token flush, send paths, or mutation handlers.
             self._maybe_generate_title()
             self._suppress_title_regen = False
         elif status == SystemStatus.LOADING:
             self._set_send_button_state(is_running=False)
             self.btn_send.setEnabled(False)
-        if status == SystemStatus.READY and not self.state.model_loaded:
+        elif status in (SystemStatus.UNLOADING, SystemStatus.ERROR):
+            self._is_model_loaded = False
+
+        if status == SystemStatus.READY and not self._is_model_loaded:
             self._apply_default_limits()
         self._last_status = status
 
     def _switch_ops_tab(self, index, checked):
         if checked:
             self.ops_stack.setCurrentIndex(index)
 
 
     def apply_operator(self, operator_data: dict):
         if not isinstance(operator_data, dict):
             return
         config = operator_data.get("config")
         if not isinstance(config, dict):
             return
 
         slider_values = {
             "temp": float(config.get("temp", self.config.get("temp", 0.7))),
             "top_p": float(config.get("top_p", self.config.get("top_p", 0.9))),
             "max_tokens": int(config.get("max_tokens", self.config.get("max_tokens", 2048))),
             "ctx_limit": int(config.get("ctx_limit", self.config.get("ctx_limit", 8192))),
         }
 
         self.config.update(config)
 
         self.s_temp.slider.blockSignals(True)
         self.s_top.slider.blockSignals(True)
         self.s_tok.slider.blockSignals(True)
         self.s_ctx.slider.blockSignals(True)
         self.s_temp.slider.setValue(int(slider_values["temp"] * 100))
         self.s_temp.val_lbl.setText(f"{slider_values['temp']:.2f}")
         self.s_top.slider.setValue(int(slider_values["top_p"] * 100))
         self.s_top.val_lbl.setText(f"{slider_values['top_p']:.2f}")
         self.s_tok.slider.setValue(int(slider_values["max_tokens"]))
         self.s_tok.val_lbl.setText(str(int(slider_values["max_tokens"])))
         self.s_ctx.slider.setValue(int(slider_values["ctx_limit"]))
         self.s_ctx.val_lbl.setText(str(int(slider_values["ctx_limit"])))
         self.s_temp.slider.blockSignals(False)
         self.s_top.slider.blockSignals(False)
         self.s_tok.slider.blockSignals(False)
         self.s_ctx.slider.blockSignals(False)
 
-        self.state.ctx_limit = int(slider_values["ctx_limit"])
+        self.sig_set_ctx_limit.emit(int(slider_values["ctx_limit"]))
 
         tags = config.get("behavior_tags", [])
         self.behavior_tags.set_tags(tags if isinstance(tags, list) else [])
 
         thinking_mode = bool(config.get("thinking_mode", False))
         self._set_thinking_mode(thinking_mode, "Standard" if thinking_mode else "Off")
 
-        self.state.gguf_path = config.get("gguf_path")
+        gguf_path = config.get("gguf_path")
+        if gguf_path:
+            self.config["gguf_path"] = gguf_path
+            self.sig_set_model_path.emit(str(gguf_path))
         self._sync_path_display()
 
         self._start_new_session()
         self._set_config_dirty(True)
         self.sig_operator_loaded.emit(str(operator_data.get("name", "")))
 
     def _start_new_session(self):
         self._title_generated = False
         self._suppress_title_regen = False
         self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
         self.trace.appendPlainText("--- TRACE RESET ---")
 
     def _prompt_clear_session(self):
         dialog = QMessageBox(self)
         dialog.setWindowTitle("Clear Session")
         dialog.setText("Choose how to clear the current session.")
         dialog.setStyleSheet(f"""
             QMessageBox {{
                 background: {BG_INPUT};
                 color: {FG_TEXT};
             }}
             QLabel {{
                 color: {FG_TEXT};
             }}
             QPushButton {{
@@ -1253,51 +1265,51 @@ Continue from the interruption point. Do not repeat earlier content.
             return
         if self._current_session.get("title"):
             self._title_generated = True
             return
         user_msgs = [m for m in self._current_session["messages"] if m.get("role") == "user" and m.get("text", "").strip()]
         if len(user_msgs) < 2 and not self._topic_dominant():
             return
         title = self._derive_title(self._current_session["messages"])
         self._current_session["title"] = title
         self._title_generated = True
         self._notify_header_update()
 
     def _topic_dominant(self):
         user_text = " ".join([m.get("text", "") for m in self._current_session["messages"] if m.get("role") == "user"])
         words = [w.lower() for w in re.findall(r"[a-zA-Z]{4,}", user_text)]
         if not words:
             return False
         counts = {}
         for word in words:
             counts[word] = counts.get(word, 0) + 1
         return max(counts.values()) >= 3
 
     def _notify_header_update(self):
         dt = QDateTime.currentDateTime().toString("ddd • HH:mm")
         title = self._current_session.get("title") or self._derive_title(self._current_session.get("messages", []))
-        self.ui_bridge.sig_terminal_header.emit(title, dt)
+        self.ui_bridge.sig_terminal_header.emit(getattr(self, "_mod_id", ""), title, dt)
 
     def _derive_title(self, messages):
         stopwords = {
             "a", "an", "and", "are", "as", "at", "be", "but", "by", "for", "from",
             "how", "i", "if", "in", "into", "is", "it", "me", "my", "of", "on", "or",
             "our", "please", "so", "that", "the", "their", "them", "then", "there", "these",
             "this", "to", "us", "we", "what", "when", "where", "which", "who", "why", "with",
             "you", "your",
         }
         user_texts = []
         for msg in messages:
             if msg.get("role") != "user":
                 continue
             text = " ".join((msg.get("text") or "").lower().split())
             if text:
                 user_texts.append(text)
             if len(user_texts) == 3:
                 break
 
         if not user_texts:
             return "chat"
 
         candidates = []
         counts = {}
         for text in user_texts:
diff --git a/ui/pages/hub.py b/ui/pages/hub.py
index 470c7d4c7c16fd463cd948442ea2f90e35d7a53d..841accd5214fed0cf775993d52f8cb5fdcfa7c82 100644
--- a/ui/pages/hub.py
+++ b/ui/pages/hub.py
@@ -1,46 +1,75 @@
 from PySide6.QtCore import Signal, Qt
 from PySide6.QtWidgets import (
     QWidget,
     QVBoxLayout,
     QLabel,
     QGridLayout,
     QFrame,
     QPushButton,
     QHBoxLayout,
-    QInputDialog,
+    QDialog,
+    QLineEdit,
     QMessageBox,
 )
 
 from core.operators import OperatorManager
 from core.style import (
     BG_GROUP, BG_INPUT, BG_MAIN, FG_TEXT, FG_DIM, ACCENT_GOLD,
     BORDER_DARK, GLASS_BG, GLASS_BORDER, GLASS_HOVER,
 )
 from ui.components.atoms import SkeetButton
 
 
+class _NameDialog(QDialog):
+    def __init__(self, parent=None):
+        super().__init__(parent)
+        self.setWindowTitle("New Operator")
+        self.setModal(True)
+        self.setStyleSheet(f"""
+            QDialog {{ background: {BG_INPUT}; color: {FG_TEXT}; }}
+            QLineEdit {{ background: #101010; color: {FG_TEXT}; border: 1px solid #333; padding: 6px; }}
+            QPushButton {{ color: {FG_TEXT}; background: transparent; border: 1px solid #333; padding: 6px 12px; }}
+            QPushButton:hover {{ border: 1px solid {ACCENT_GOLD}; color: {ACCENT_GOLD}; }}
+        """)
+        layout = QVBoxLayout(self)
+        layout.addWidget(QLabel("Operator name:"))
+        self.input = QLineEdit()
+        layout.addWidget(self.input)
+        row = QHBoxLayout()
+        row.addStretch()
+        ok_btn = SkeetButton("OK")
+        cancel_btn = SkeetButton("CANCEL")
+        ok_btn.clicked.connect(self.accept)
+        cancel_btn.clicked.connect(self.reject)
+        row.addWidget(ok_btn)
+        row.addWidget(cancel_btn)
+        layout.addLayout(row)
+
+    def value(self) -> str:
+        return self.input.text().strip()
+
 class _OperatorCard(QPushButton):
     """Glassmorphic operator card with structured info."""
 
     def __init__(self, name: str, gguf_path: str, tag_count: int):
         super().__init__()
         self.op_name = name
         self.setCursor(Qt.PointingHandCursor)
         self.setMinimumHeight(80)
         self.setMinimumWidth(180)
         self._selected = False
 
         layout = QVBoxLayout(self)
         layout.setContentsMargins(12, 10, 12, 10)
         layout.setSpacing(4)
 
         lbl_name = QLabel(name.upper())
         lbl_name.setStyleSheet(f"color: {FG_TEXT}; font-size: 11px; font-weight: bold; background: transparent; letter-spacing: 1px;")
         layout.addWidget(lbl_name)
 
         lbl_model = QLabel(gguf_path)
         lbl_model.setStyleSheet(f"color: {FG_DIM}; font-size: 9px; background: transparent;")
         lbl_model.setWordWrap(True)
         layout.addWidget(lbl_model)
 
         lbl_tags = QLabel(f"{tag_count} tag{'s' if tag_count != 1 else ''}")
@@ -185,53 +214,53 @@ class PageHub(QWidget):
             cfg = data.get("config", {})
             gguf_path = self._truncate_path(cfg.get("gguf_path"))
             tag_count = len(cfg.get("behavior_tags") or [])
 
             card = _OperatorCard(name, gguf_path, tag_count)
             card.clicked.connect(lambda _checked=False, op_name=name: self._on_card_clicked(op_name))
             row, col = divmod(idx, 3)
             self.grid.addWidget(card, row + 1, col)  # +1 to skip row 0 (empty_label)
             self._cards[name] = card
 
         if self._selected_name not in self._cards:
             self._selected_name = None
             self.btn_delete.setEnabled(False)
 
     def _on_card_clicked(self, name: str):
         self._selected_name = name
         for op_name, card in self._cards.items():
             card.set_selected(op_name == name)
         self.btn_delete.setEnabled(True)
         self.sig_load_operator.emit(name)
 
     def _create_operator_from_current(self):
         if self._config_provider is None:
             QMessageBox.warning(self, "Operator", "Terminal page is not mounted.")
             return
-        name, ok = QInputDialog.getText(self, "New Operator", "Operator name:")
-        if not ok:
+        dialog = _NameDialog(self)
+        if dialog.exec() != QDialog.Accepted:
             return
-        clean_name = name.strip()
+        clean_name = dialog.value()
         if not clean_name:
             return
         config = dict(self._config_provider() or {})
         data = {"name": clean_name, "config": config, "layout": {}, "geometry": {}}
         self.sig_save_operator.emit(clean_name, data)
         self.refresh_cards()
 
     def _delete_selected(self):
         if not self._selected_name:
             return
         if not self._operator_manager.delete_operator(self._selected_name):
             QMessageBox.warning(self, "Operator", "Delete failed.")
             return
         self._selected_name = None
         self.btn_delete.setEnabled(False)
         self.refresh_cards()
 
     def _truncate_path(self, value) -> str:
         if not value:
             return "No model path"
         path = str(value)
         if len(path) <= 42:
             return path
         return f"...{path[-39:]}"
