
================================================================================
FILE: .\.gitignore
================================================================================

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python

# Virtual Environment
venv/
env/
ENV/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Monolith specific
ui/addons/configs/
*.db
*.log
.env

# Model files (optional - user downloads these)
*.gguf
*.safetensors
*.ckpt
*.pth

# Generated content
generated_images/
generated_audio/
chat_history/



================================================================================
FILE: .\bootstrap.py
================================================================================

import sys

from PySide6.QtWidgets import QApplication

from core.state import AppState
from engine.bridge import EngineBridge
from engine.vision import VisionEngine
from monokernel.bridge import MonoBridge
from monokernel.dock import MonoDock
from monokernel.guard import MonoGuard
from ui.addons.builtin import build_builtin_registry
from ui.addons.context import AddonContext
from ui.addons.host import AddonHost
from ui.bridge import UIBridge
from ui.main_window import MonolithUI
from ui.overseer import OverseerWindow


def main():
    app = QApplication(sys.argv)

    # Load saved theme before any UI is created
    from core.theme_config import load_theme_config
    from core.themes import apply_theme
    from core.style import refresh_styles
    theme_cfg = load_theme_config()
    apply_theme(theme_cfg.get("theme", "midnight"))
    refresh_styles()

    state = AppState()
    vision_engine_impl = VisionEngine(state)
    vision_engine = EngineBridge(vision_engine_impl)
    guard = MonoGuard(state, {"vision": vision_engine})
    dock = MonoDock(guard)
    bridge = MonoBridge(dock)

    ui_bridge = UIBridge()
    ui = MonolithUI(state, ui_bridge)
    overseer = OverseerWindow(guard, ui_bridge)

    registry = build_builtin_registry()
    ctx = AddonContext(state=state, guard=guard, bridge=bridge, ui=ui, host=None, ui_bridge=ui_bridge)
    host = AddonHost(registry, ctx)
    ui.attach_host(host)

    ui_bridge.sig_open_overseer.connect(overseer.show)
    ui_bridge.sig_overseer_viz_toggle.connect(guard.enable_viztracer)

    # Theme change: refresh style constants and rebuild UI stylesheets
    def _on_theme_changed(theme_name):
        apply_theme(theme_name)
        refresh_styles()
        ui.apply_theme_refresh()
        # Refresh all mounted pages (hub, addons, etc.)
        for page in ui.pages.values():
            if hasattr(page, "apply_theme_refresh"):
                page.apply_theme_refresh()
        # Refresh any open module widgets in the stack
        for i in range(ui.stack.count()):
            w = ui.stack.widget(i)
            if hasattr(w, "apply_theme_refresh"):
                w.apply_theme_refresh()

    ui_bridge.sig_theme_changed.connect(_on_theme_changed)

    # global chrome-only wiring stays here
    guard.sig_status.connect(ui.update_status)
    guard.sig_usage.connect(lambda _ek, used: ui.update_ctx(used))
    app.aboutToQuit.connect(guard.stop)
    app.aboutToQuit.connect(overseer.db.close)
    app.aboutToQuit.connect(lambda: guard.enable_viztracer(False) if guard._viztracer is not None else None)
    app.aboutToQuit.connect(vision_engine.shutdown)

    ui.show()
    return app.exec()


if __name__ == "__main__":
    raise SystemExit(main())



================================================================================
FILE: .\CHANGELOG.md
================================================================================

# Changelog

## v0.2a — 2025-02-09

### New Systems

- **Operator System** — Save and restore full workspace snapshots (all open modules, terminal configs, chat history). Load via LOAD button or double-click. Legacy single-config format backward compatible.
- **Overseer** — Real-time trace viewer and debug dashboard. Tracks kernel tasks, engine events, and LLM generation with searchable log. VizTracer integration for profiling.
- **UI Bridge** — Dedicated signal bus (`ui/bridge.py`) decoupling UI events from kernel internals. Handles operator apply, terminal headers, overseer toggling.
- **Operator Manager** (`core/operators.py`) — JSON-based operator storage with save/load/delete/list. Supports both legacy (single config) and new (multi-module snapshot) formats.
- **Overseer Database** (`core/overseer_db.py`) — Persistent trace storage for session history.

### New Files

- `ui/pages/hub.py` — Operator hub page with card grid, LOAD/NEW/DELETE actions, double-click to open
- `ui/components/message_widget.py` — Dedicated message bubble widget with per-message edit/delete/regenerate actions, proper word-wrap sizing
- `ui/bridge.py` — UI signal bridge
- `ui/overseer.py` — Overseer trace window
- `core/operators.py` — Operator persistence layer
- `core/overseer_db.py` — Trace database
- `core/paths.py` — Centralized config/data path resolution
- `combiner.py` — Source bundler utility
- `requirements.txt` — Dependency manifest

### Chat Overhaul

- Replaced monolithic QTextEdit chat with individual `MessageWidget` bubbles in a QListWidget
- Per-message actions on hover: edit, delete, regenerate
- Thinking mode support (Off / Standard / Extended) via collapsible OPTIONS panel in CONTROL tab
- File attachment support via OPTIONS panel
- Race condition prevention (`_pending_mutation` system) — safe edit/delete/regen during active generation
- Ghost bubble cleanup (`_cleanup_empty_assistant_if_needed`)
- `sig_debug` signal for structured trace output to Overseer
- Streaming state cleanup on interruption (UNLOADING handling)

### UI Changes

- **Top bar**: MONOLITH label is now static muted gold, left-aligned (removed fire animation)
- **Status**: Moved from top bar to small label in bottom-right corner
- **Chat title/time**: Only visible when viewing terminal modules (hidden for SD, audio, runtime)
- **Live clock**: 60-second timer keeps chat timestamp current
- **Gradient line**: Kept at top of window (unchanged)
- **Input toolbar**: Removed + and THINK buttons from chat input area
- **OPTIONS panel**: Collapsible panel in CONTROL tab with attach file + think mode toggles

### Addon System

- `AddonHost.launch_module()` now stamps `widget._addon_id` on every module instance for type identification
- `hub_factory` added to builtin registry — wires operator hub with snapshot/load/save
- Terminal factory enhanced with named exception-wrapped handlers, short engine ID traces (`[LLM:xxxx]`), descriptive generation messages
- Operator trace messages routed to Overseer via `ctx.guard.sig_trace`

### Architecture

- Removed direct `LLMEngine` instantiation from bootstrap — engine creation delegated to addon system
- Added `UIBridge` to bootstrap wiring
- Added `OverseerWindow` to bootstrap with guard connection
- `aboutToQuit` now cleans up viztracer and overseer database

### Bug Fixes

- Fixed operator loading doing nothing (missing view switch + module creation)
- Fixed assistant bubble showing large empty gap during streaming (sizeHint override for word-wrap)
- Fixed `btn_thinking` AttributeError when applying operators (removed stale reference)
- Fixed race conditions during edit/delete/regenerate while LLM is generating
- Fixed ghost empty assistant bubbles appearing after interrupted generation



================================================================================
FILE: .\install.bat
================================================================================

@echo off
echo Creating virtual environment...
python -m venv venv

echo Activating venv...
call venv\Scripts\activate.bat

echo Installing dependencies...
pip install --upgrade pip
pip install PySide6

echo.
echo Optional: Install LLM support?
set /p llm="Install llama-cpp-python? (y/n): "
if /i "%llm%"=="y" pip install llama-cpp-python

echo.
echo Optional: Install Audio generation?
set /p audio="Install audiocraft? (y/n): "
if /i "%audio%"=="y" pip install audiocraft torch torchaudio

echo.
echo Optional: Install Stable Diffusion?
set /p sd="Install diffusers? (y/n): "
if /i "%sd%"=="y" pip install diffusers torch transformers accelerate

echo.
echo Installation complete!
echo Run start.bat to launch Monolith
pause



================================================================================
FILE: .\LICENSE
================================================================================

MIT License

Copyright (c) 2026 Eryndel (Erick Ascano-Marin)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================================================
FILE: .\main.py
================================================================================

__version__ = "0.2.1a"

from bootstrap import main

if __name__ == "__main__":
    raise SystemExit(main())



================================================================================
FILE: .\README.md
================================================================================

<p align="center">
<img width="642" height="118" alt="monolith" src="https://github.com/user-attachments/assets/17bc1107-9fdd-4d9d-9c7d-6c9a1f00fed6" />
</p>

<p align="center">
<b>Stop chatting with AI. Start commanding it.</b><br/>
A local-first AI workstation for running LLMs, Stable Diffusion, and audio generation through a modular kernel.
</p>

---

## Screenshots

<table style="border: none;">
<tr>
<td width="50%" align="center" style="border:none;">
<img src="https://github.com/user-attachments/assets/817d57a3-fb4a-4210-80a4-511116faad0b" width="98%">
</td>
<td width="50%" align="center" style="border:none;">
<img src="https://github.com/user-attachments/assets/f6f2af83-3038-42a0-b0aa-dbfa79489485" width="98%">
</td>
</tr>
</table>

<p align="center">
<img src="https://github.com/user-attachments/assets/7bb47e3d-0b12-413b-8fa7-24c174a4ddc4" width="88%">
</p>

<p align="center">
<i>Top: idle kernel + LLM chat · Bottom: Vision tab generating an image</i>
</p>

---

## Quick Start

### Windows
1. Clone repo  
2. Run `install.bat`  
3. Run `start.bat`

### Linux / macOS

```bash
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python main.py
```


## Core Overview

**Status**
v0.2.1a — Early alpha. Built for personal use and active experimentation. Shared publicly for builders & creators.

**Features**
* **Local LLM Chat:** GGUF models via llama.cpp
* **Image Generation:** Stable Diffusion
* **Audio Generation:** AudioCraft
* **System:** Persistent conversation history, modular kernel architecture, dark mode

**Architecture**
Kernel + Engines + Addons model. Engines run isolated processes; Addons control them. The Kernel enforces contracts and lifecycle boundaries.

See [Kernel Contract (V2)](/monokernel/kernel_contract.md) for details.

---

## Requirements

* **Python:** 3.10+
* **GPU:** NVIDIA GPU with 8GB+ VRAM recommended (required for SD/Audio)
* **Storage:** ~10GB disk space for base models

---

<p align="center">
  Built by <a href="https://eryndel.us">Eryndel</a>
</p>



================================================================================
FILE: .\requirements.txt
================================================================================

# Core (required)
PySide6>=6.10.0

# LLM support (optional — needed for chat/terminal)
llama-cpp-python>=0.3.0

# Image generation (optional — needed for Stable Diffusion module)
diffusers>=0.35.0
transformers>=4.57.0
accelerate>=1.11.0
torch>=2.4.0

# Audio generation (optional — needed for audio module)
audiocraft>=1.3.0
torchaudio>=2.4.0



================================================================================
FILE: .\start.bat
================================================================================

@echo off
call venv\Scripts\activate.bat
python main.py
pause



================================================================================
FILE: .\.claude\worktrees\cool-mayer\.git
================================================================================

gitdir: C:/Users/ascan/Desktop/Monolith/.git/worktrees/cool-mayer



================================================================================
FILE: .\.claude\worktrees\cool-mayer\.gitignore
================================================================================

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python

# Virtual Environment
venv/
env/
ENV/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Monolith specific
ui/addons/configs/
*.db
*.log
.env

# Model files (optional - user downloads these)
*.gguf
*.safetensors
*.ckpt
*.pth

# Generated content
generated_images/
generated_audio/
chat_history/



================================================================================
FILE: .\.claude\worktrees\cool-mayer\bootstrap.py
================================================================================

import sys

from PySide6.QtWidgets import QApplication

from core.state import AppState
from engine.bridge import EngineBridge
from engine.vision import VisionEngine
from monokernel.bridge import MonoBridge
from monokernel.dock import MonoDock
from monokernel.guard import MonoGuard
from ui.addons.builtin import build_builtin_registry
from ui.addons.context import AddonContext
from ui.addons.host import AddonHost
from ui.bridge import UIBridge
from ui.main_window import MonolithUI
from ui.overseer import OverseerWindow


def main():
    app = QApplication(sys.argv)
    state = AppState()
    vision_engine_impl = VisionEngine(state)
    vision_engine = EngineBridge(vision_engine_impl)
    guard = MonoGuard(state, {"vision": vision_engine})
    dock = MonoDock(guard)
    bridge = MonoBridge(dock)

    ui_bridge = UIBridge()
    ui = MonolithUI(state, ui_bridge)
    overseer = OverseerWindow(guard, ui_bridge)

    registry = build_builtin_registry()
    ctx = AddonContext(state=state, guard=guard, bridge=bridge, ui=ui, host=None, ui_bridge=ui_bridge)
    host = AddonHost(registry, ctx)
    ui.attach_host(host)

    ui_bridge.sig_open_overseer.connect(overseer.show)
    ui_bridge.sig_overseer_viz_toggle.connect(guard.enable_viztracer)

    # global chrome-only wiring stays here
    guard.sig_status.connect(ui.update_status)
    guard.sig_usage.connect(lambda _ek, used: ui.update_ctx(used))
    app.aboutToQuit.connect(guard.stop)
    app.aboutToQuit.connect(overseer.db.close)
    app.aboutToQuit.connect(lambda: guard.enable_viztracer(False) if guard._viztracer is not None else None)
    app.aboutToQuit.connect(vision_engine.shutdown)

    ui.show()
    return app.exec()


if __name__ == "__main__":
    raise SystemExit(main())



================================================================================
FILE: .\.claude\worktrees\cool-mayer\CHANGELOG.md
================================================================================

# Changelog

## v0.2a — 2025-02-09

### New Systems

- **Operator System** — Save and restore full workspace snapshots (all open modules, terminal configs, chat history). Load via LOAD button or double-click. Legacy single-config format backward compatible.
- **Overseer** — Real-time trace viewer and debug dashboard. Tracks kernel tasks, engine events, and LLM generation with searchable log. VizTracer integration for profiling.
- **UI Bridge** — Dedicated signal bus (`ui/bridge.py`) decoupling UI events from kernel internals. Handles operator apply, terminal headers, overseer toggling.
- **Operator Manager** (`core/operators.py`) — JSON-based operator storage with save/load/delete/list. Supports both legacy (single config) and new (multi-module snapshot) formats.
- **Overseer Database** (`core/overseer_db.py`) — Persistent trace storage for session history.

### New Files

- `ui/pages/hub.py` — Operator hub page with card grid, LOAD/NEW/DELETE actions, double-click to open
- `ui/components/message_widget.py` — Dedicated message bubble widget with per-message edit/delete/regenerate actions, proper word-wrap sizing
- `ui/bridge.py` — UI signal bridge
- `ui/overseer.py` — Overseer trace window
- `core/operators.py` — Operator persistence layer
- `core/overseer_db.py` — Trace database
- `core/paths.py` — Centralized config/data path resolution
- `combiner.py` — Source bundler utility
- `requirements.txt` — Dependency manifest

### Chat Overhaul

- Replaced monolithic QTextEdit chat with individual `MessageWidget` bubbles in a QListWidget
- Per-message actions on hover: edit, delete, regenerate
- Thinking mode support (Off / Standard / Extended) via collapsible OPTIONS panel in CONTROL tab
- File attachment support via OPTIONS panel
- Race condition prevention (`_pending_mutation` system) — safe edit/delete/regen during active generation
- Ghost bubble cleanup (`_cleanup_empty_assistant_if_needed`)
- `sig_debug` signal for structured trace output to Overseer
- Streaming state cleanup on interruption (UNLOADING handling)

### UI Changes

- **Top bar**: MONOLITH label is now static muted gold, left-aligned (removed fire animation)
- **Status**: Moved from top bar to small label in bottom-right corner
- **Chat title/time**: Only visible when viewing terminal modules (hidden for SD, audio, runtime)
- **Live clock**: 60-second timer keeps chat timestamp current
- **Gradient line**: Kept at top of window (unchanged)
- **Input toolbar**: Removed + and THINK buttons from chat input area
- **OPTIONS panel**: Collapsible panel in CONTROL tab with attach file + think mode toggles

### Addon System

- `AddonHost.launch_module()` now stamps `widget._addon_id` on every module instance for type identification
- `hub_factory` added to builtin registry — wires operator hub with snapshot/load/save
- Terminal factory enhanced with named exception-wrapped handlers, short engine ID traces (`[LLM:xxxx]`), descriptive generation messages
- Operator trace messages routed to Overseer via `ctx.guard.sig_trace`

### Architecture

- Removed direct `LLMEngine` instantiation from bootstrap — engine creation delegated to addon system
- Added `UIBridge` to bootstrap wiring
- Added `OverseerWindow` to bootstrap with guard connection
- `aboutToQuit` now cleans up viztracer and overseer database

### Bug Fixes

- Fixed operator loading doing nothing (missing view switch + module creation)
- Fixed assistant bubble showing large empty gap during streaming (sizeHint override for word-wrap)
- Fixed `btn_thinking` AttributeError when applying operators (removed stale reference)
- Fixed race conditions during edit/delete/regenerate while LLM is generating
- Fixed ghost empty assistant bubbles appearing after interrupted generation



================================================================================
FILE: .\.claude\worktrees\cool-mayer\install.bat
================================================================================

@echo off
echo Creating virtual environment...
python -m venv venv

echo Activating venv...
call venv\Scripts\activate.bat

echo Installing dependencies...
pip install --upgrade pip
pip install PySide6

echo.
echo Optional: Install LLM support?
set /p llm="Install llama-cpp-python? (y/n): "
if /i "%llm%"=="y" pip install llama-cpp-python

echo.
echo Optional: Install Audio generation?
set /p audio="Install audiocraft? (y/n): "
if /i "%audio%"=="y" pip install audiocraft torch torchaudio

echo.
echo Optional: Install Stable Diffusion?
set /p sd="Install diffusers? (y/n): "
if /i "%sd%"=="y" pip install diffusers torch transformers accelerate

echo.
echo Installation complete!
echo Run start.bat to launch Monolith
pause



================================================================================
FILE: .\.claude\worktrees\cool-mayer\LICENSE
================================================================================

MIT License

Copyright (c) 2026 Eryndel (Erick Ascano-Marin)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================================================
FILE: .\.claude\worktrees\cool-mayer\main.py
================================================================================

__version__ = "0.2.1a"

from bootstrap import main

if __name__ == "__main__":
    raise SystemExit(main())



================================================================================
FILE: .\.claude\worktrees\cool-mayer\README.md
================================================================================

<p align="center">
<img width="642" height="118" alt="monolith" src="https://github.com/user-attachments/assets/17bc1107-9fdd-4d9d-9c7d-6c9a1f00fed6" />
</p>

<p align="center">
<b>Stop chatting with AI. Start commanding it.</b><br/>
A local-first AI workstation for running LLMs, Stable Diffusion, and audio generation through a modular kernel.
</p>

---

## Screenshots

<table style="border: none;">
<tr>
<td width="50%" align="center" style="border:none;">
<img src="https://github.com/user-attachments/assets/817d57a3-fb4a-4210-80a4-511116faad0b" width="98%">
</td>
<td width="50%" align="center" style="border:none;">
<img src="https://github.com/user-attachments/assets/f6f2af83-3038-42a0-b0aa-dbfa79489485" width="98%">
</td>
</tr>
</table>

<p align="center">
<img src="https://github.com/user-attachments/assets/7bb47e3d-0b12-413b-8fa7-24c174a4ddc4" width="88%">
</p>

<p align="center">
<i>Top: idle kernel + LLM chat · Bottom: Vision tab generating an image</i>
</p>

---

## Quick Start

### Windows
1. Clone repo  
2. Run `install.bat`  
3. Run `start.bat`

### Linux / macOS

```bash
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python main.py
```


## Core Overview

**Status**
v0.2.1a — Early alpha. Built for personal use and active experimentation. Shared publicly for builders & creators.

**Features**
* **Local LLM Chat:** GGUF models via llama.cpp
* **Image Generation:** Stable Diffusion
* **Audio Generation:** AudioCraft
* **System:** Persistent conversation history, modular kernel architecture, dark mode

**Architecture**
Kernel + Engines + Addons model. Engines run isolated processes; Addons control them. The Kernel enforces contracts and lifecycle boundaries.

See [Kernel Contract (V2)](/monokernel/kernel_contract.md) for details.

---

## Requirements

* **Python:** 3.10+
* **GPU:** NVIDIA GPU with 8GB+ VRAM recommended (required for SD/Audio)
* **Storage:** ~10GB disk space for base models

---

<p align="center">
  Built by <a href="https://eryndel.us">Eryndel</a>
</p>



================================================================================
FILE: .\.claude\worktrees\cool-mayer\requirements.txt
================================================================================

# Core (required)
PySide6>=6.10.0

# LLM support (optional — needed for chat/terminal)
llama-cpp-python>=0.3.0

# Image generation (optional — needed for Stable Diffusion module)
diffusers>=0.35.0
transformers>=4.57.0
accelerate>=1.11.0
torch>=2.4.0

# Audio generation (optional — needed for audio module)
audiocraft>=1.3.0
torchaudio>=2.4.0



================================================================================
FILE: .\.claude\worktrees\cool-mayer\start.bat
================================================================================

@echo off
call venv\Scripts\activate.bat
python main.py
pause



================================================================================
FILE: .\.claude\worktrees\cool-mayer\.claude\settings.local.json
================================================================================

{
  "permissions": {
    "allow": [
      "mcp__gitnexus__context"
    ]
  }
}



================================================================================
FILE: .\.claude\worktrees\cool-mayer\core\llm_config.py
================================================================================

import json

from core.paths import CONFIG_DIR

MASTER_PROMPT = """
You are Monolith.

CORE RULES:
- Treat inference as a threat.
- Only assert facts explicitly present in the user-visible context or provided by the system.
- If information is missing or uncertain: respond with "Unknown" or "I don’t know" and stop.
- Do not guess user intent.
- Do not invent system state.
- Do not assume defaults.
- Never upgrade uncertainty into certainty.
- Do not fabricate files, tools, processes, or runtime conditions.
- Re-check provided information before answering.
- If verification is impossible: say so.

OUTPUT RULES:
- Be precise.
- Be literal.
- Avoid speculation.
- Avoid narrative filler.

WORLD MODEL:
- No persistent memory unless explicitly stored.
- No assumptions about environment.
- No hidden state.
- Only the current session text is authoritative.
""".strip()

TAG_MAP = {
    "helpful": "[TONE] neutral\n[DETAIL] medium",
    "teacher": "[TONE] explanatory\n[DETAIL] high\n[STEPWISE]",
    "emotional": "[TONE] supportive\n[VALIDATING]",
    "concise": "[LENGTH] short",
    "strict": "[EPISTEMIC] maximal",
}

DEFAULT_CONFIG = {
    "gguf_path": None,
    "temp": 0.7,
    "top_p": 0.9,
    "max_tokens": 2048,
    "ctx_limit": 8192,
    "system_prompt": MASTER_PROMPT,
    "behavior_tags": [],
}

CONFIG_PATH = CONFIG_DIR / "llm_config.json"


def load_config():
    config = DEFAULT_CONFIG.copy()
    resave_config = False
    if CONFIG_PATH.exists():
        try:
            with CONFIG_PATH.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
                if isinstance(data, dict):
                    if "system_prompt" in data or "context_injection" in data:
                        data.pop("system_prompt", None)
                        data.pop("context_injection", None)
                        resave_config = True
                    config.update(data)
        except Exception:
            pass
    config.setdefault("behavior_tags", [])
    if not isinstance(config.get("behavior_tags"), list):
        config["behavior_tags"] = []
    config["system_prompt"] = MASTER_PROMPT
    if resave_config:
        save_config(config)
    return config


def save_config(config):
    persisted = dict(config)
    persisted.pop("system_prompt", None)
    persisted.pop("context_injection", None)
    CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    with CONFIG_PATH.open("w", encoding="utf-8") as handle:
        json.dump(persisted, handle, indent=2)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\core\operators.py
================================================================================

import json
import re
from pathlib import Path

from core.paths import CONFIG_DIR


class OperatorManager:
    def __init__(self):
        self._operators_dir = CONFIG_DIR / "operators"

    def _ensure_dir(self) -> Path:
        self._operators_dir.mkdir(parents=True, exist_ok=True)
        return self._operators_dir

    def _slugify(self, name: str) -> str:
        value = re.sub(r"[^a-z0-9]+", "-", (name or "").strip().lower())
        value = re.sub(r"-+", "-", value).strip("-")
        return value or "operator"

    def _path_for_name(self, name: str) -> Path:
        return self._ensure_dir() / f"{self._slugify(name)}.json"

    def list_operators(self) -> list[dict]:
        operators = []
        for path in self._ensure_dir().glob("*.json"):
            try:
                with path.open("r", encoding="utf-8") as handle:
                    data = json.load(handle)
            except Exception:
                continue
            if isinstance(data, dict) and isinstance(data.get("name"), str):
                # Accept both new format (has "modules") and legacy (has "config")
                if isinstance(data.get("modules"), list) or isinstance(data.get("config"), dict):
                    operators.append({"name": data["name"], "path": path})
        operators.sort(key=lambda item: item["name"].lower())
        return operators

    def load_operator(self, name: str) -> dict:
        path = self._path_for_name(name)
        with path.open("r", encoding="utf-8") as handle:
            data = json.load(handle)
        if not isinstance(data, dict):
            raise ValueError("Operator payload must be a JSON object")
        return data

    def save_operator(self, name: str, data: dict) -> Path:
        payload = dict(data or {})
        payload["name"] = name
        payload.setdefault("layout", {})
        payload.setdefault("geometry", {})
        # Strip system_prompt from config (legacy format) or module configs (new format)
        if isinstance(payload.get("config"), dict):
            payload["config"].pop("system_prompt", None)
        for mod in payload.get("modules", []):
            if isinstance(mod.get("config"), dict):
                mod["config"].pop("system_prompt", None)
        path = self._path_for_name(name)
        with path.open("w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2)
        return path

    def delete_operator(self, name: str) -> bool:
        path = self._path_for_name(name)
        if not path.exists():
            return False
        try:
            path.unlink()
        except OSError:
            return False
        return True



================================================================================
FILE: .\.claude\worktrees\cool-mayer\core\overseer_db.py
================================================================================

from __future__ import annotations

import json
import sqlite3
import threading
from datetime import datetime, timezone
from typing import Any

from core.paths import LOG_DIR


class OverseerDB:
    def __init__(self) -> None:
        self._lock = threading.Lock()
        self._conn: sqlite3.Connection | None = sqlite3.connect(LOG_DIR / "overseer.sqlite3", check_same_thread=False)
        self._conn.row_factory = sqlite3.Row
        self._conn.execute("PRAGMA journal_mode=WAL")
        self._create_schema()

    def _get_conn(self) -> sqlite3.Connection:
        if self._conn is None:
            raise RuntimeError("OverseerDB connection is closed")
        return self._conn

    def _create_schema(self) -> None:
        with self._lock:
            conn = self._get_conn()
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS events(
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ts TEXT NOT NULL,
                    engine_key TEXT NOT NULL,
                    event TEXT NOT NULL,
                    payload TEXT
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS tasks(
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id TEXT NOT NULL,
                    engine_key TEXT NOT NULL,
                    status TEXT NOT NULL,
                    ts TEXT NOT NULL
                )
                """
            )
            conn.commit()

    def _now(self) -> str:
        return datetime.now(timezone.utc).isoformat()

    def log_event(self, engine_key: str, event: str, payload: Any) -> int:
        payload_text = json.dumps(payload)
        with self._lock:
            conn = self._get_conn()
            cur = conn.execute(
                "INSERT INTO events(ts, engine_key, event, payload) VALUES(?, ?, ?, ?)",
                (self._now(), engine_key, event, payload_text),
            )
            conn.commit()
            return int(cur.lastrowid)

    def log_task(self, task_id: str, engine_key: str, status: str) -> int:
        with self._lock:
            conn = self._get_conn()
            cur = conn.execute(
                "INSERT INTO tasks(task_id, engine_key, status, ts) VALUES(?, ?, ?, ?)",
                (task_id, engine_key, status, self._now()),
            )
            conn.commit()
            return int(cur.lastrowid)

    def get_recent_events(self, limit: int = 500) -> list[dict[str, Any]]:
        with self._lock:
            cur = self._get_conn().execute(
                "SELECT id, ts, engine_key, event, payload FROM events ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            rows = [self._row_to_event_dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def get_recent_tasks(self, limit: int = 500) -> list[dict[str, Any]]:
        with self._lock:
            cur = self._get_conn().execute(
                "SELECT id, task_id, engine_key, status, ts FROM tasks ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            rows = [dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def query_events(
        self,
        engine_key: str | None = None,
        event: str | None = None,
        after: str | None = None,
        before: str | None = None,
        limit: int = 500,
    ) -> list[dict[str, Any]]:
        clauses: list[str] = []
        params: list[Any] = []

        if engine_key is not None:
            clauses.append("engine_key = ?")
            params.append(engine_key)
        if event is not None:
            clauses.append("event = ?")
            params.append(event)
        if after is not None:
            clauses.append("ts >= ?")
            params.append(after)
        if before is not None:
            clauses.append("ts <= ?")
            params.append(before)

        where = f"WHERE {' AND '.join(clauses)}" if clauses else ""
        params.append(limit)
        with self._lock:
            cur = self._get_conn().execute(
                f"SELECT id, ts, engine_key, event, payload FROM events {where} ORDER BY id DESC LIMIT ?",
                params,
            )
            rows = [self._row_to_event_dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def _row_to_event_dict(self, row: sqlite3.Row) -> dict[str, Any]:
        payload_raw = row["payload"]
        payload: Any = payload_raw
        if payload_raw is not None:
            try:
                payload = json.loads(payload_raw)
            except Exception:
                payload = payload_raw
        return {
            "id": row["id"],
            "ts": row["ts"],
            "engine_key": row["engine_key"],
            "event": row["event"],
            "payload": payload,
        }

    def close(self) -> None:
        with self._lock:
            if self._conn is None:
                return
            self._conn.close()
            self._conn = None



================================================================================
FILE: .\.claude\worktrees\cool-mayer\core\paths.py
================================================================================

import os
from pathlib import Path


if "MONOLITH_ROOT" in os.environ:
    MONOLITH_ROOT = Path(os.environ["MONOLITH_ROOT"]).expanduser()
elif os.name == "nt":
    appdata = os.getenv("APPDATA")
    if appdata:
        MONOLITH_ROOT = Path(appdata) / "Monolith"
    else:
        MONOLITH_ROOT = Path.home() / "AppData" / "Roaming" / "Monolith"
else:
    MONOLITH_ROOT = Path.home() / "Monolith"

CONFIG_DIR = MONOLITH_ROOT / "config"
ARCHIVE_DIR = MONOLITH_ROOT / "chats"
LOG_DIR = MONOLITH_ROOT / "logs"
ADDON_CONFIG_DIR = MONOLITH_ROOT / "addons" / "configs"

for _dir in (MONOLITH_ROOT, CONFIG_DIR, ARCHIVE_DIR, LOG_DIR, ADDON_CONFIG_DIR):
    _dir.mkdir(parents=True, exist_ok=True)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\core\state.py
================================================================================

from enum import Enum

# System Status Enum
class SystemStatus(Enum):
    READY = "READY"
    LOADING = "LOADING"
    RUNNING = "RUNNING"
    ERROR = "ERROR"
    UNLOADING = "UNLOADING"

# Shared Application State
class AppState:
    def __init__(self):
        # System
        self.gguf_path: str | None = None
        self.model_loaded: bool = False
        self.status: SystemStatus = SystemStatus.READY
        
        # Resources
        self.ctx_limit: int = 8192
        self.ctx_used: int = 0



================================================================================
FILE: .\.claude\worktrees\cool-mayer\core\style.py
================================================================================

# ======================
# THEME: SKEET / GAMESENSE
# ======================
BG_MAIN = "#0C0C0C"       # Deep dark background
BG_SIDEBAR = "#111111"    # Sidebar background
BG_PANEL = "#141414"      # Panel background
BG_GROUP = "#0C0C0C"      # Groupbox background
BG_INPUT = "#0f0f0f"      # Input field background

BORDER_DARK = "#2a2a2a"   # Subtle borders
BORDER_LIGHT = "#333333"  # Highlight borders

FG_TEXT = "#dcdcdc"       # Main text
FG_DIM = "#777777"        # Dim text / Labels
FG_ACCENT = "#96c93d"     # "Enabled" Green
FG_ERROR = "#d44e4e"      # Error Red
FG_WARN = "#e0b020"       # Warning Yellow

ACCENT_GOLD = "#D4AF37"   # Monolith Identity Gold

# Glassmorphic surfaces
GLASS_BG = "rgba(12, 12, 12, 220)"
GLASS_BORDER = "rgba(212, 175, 55, 40)"
GLASS_HOVER = "rgba(212, 175, 55, 15)"

# Overseer palette
OVERSEER_BG = "#080808"
OVERSEER_FG = "#33ff33"
OVERSEER_DIM = "#1a7a1a"
OVERSEER_BORDER = "#1a1a1a"

SCROLLBAR_STYLE = f"""
QScrollBar:vertical {{
    background: {BG_INPUT};
    width: 10px;
    margin: 0px;
    border: 1px solid {BORDER_DARK};
}}
QScrollBar::handle:vertical {{
    background: #1c1c1c;
    min-height: 24px;
    border: 1px solid {ACCENT_GOLD};
    border-radius: 2px;
}}
QScrollBar::handle:vertical:hover {{
    background: #252525;
}}
QScrollBar::add-line:vertical,
QScrollBar::sub-line:vertical {{
    height: 0px;
    width: 0px;
}}
QScrollBar:horizontal {{
    background: {BG_INPUT};
    height: 10px;
    margin: 0px;
    border: 1px solid {BORDER_DARK};
}}
QScrollBar::handle:horizontal {{
    background: #1c1c1c;
    min-width: 24px;
    border: 1px solid {ACCENT_GOLD};
    border-radius: 2px;
}}
QScrollBar::handle:horizontal:hover {{
    background: #252525;
}}
QScrollBar::add-line:horizontal,
QScrollBar::sub-line:horizontal {{
    height: 0px;
    width: 0px;
}}
"""



================================================================================
FILE: .\.claude\worktrees\cool-mayer\core\task.py
================================================================================

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from time import time
from uuid import UUID, uuid4


class TaskStatus(Enum):
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    DONE = "DONE"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


@dataclass
class Task:
    id: UUID
    addon_pid: str
    target: str
    command: str
    payload: dict
    priority: int
    status: TaskStatus
    timestamp: float

    @classmethod
    def new(
        cls,
        addon_pid: str,
        target: str,
        command: str,
        payload: dict,
        priority: int = 2,
    ) -> "Task":
        return cls(
            id=uuid4(),
            addon_pid=addon_pid,
            target=target,
            command=command,
            payload=payload,
            priority=priority,
            status=TaskStatus.PENDING,
            timestamp=time(),
        )



================================================================================
FILE: .\.claude\worktrees\cool-mayer\engine\base.py
================================================================================

from __future__ import annotations

from typing import Protocol, runtime_checkable

from PySide6.QtCore import Signal


@runtime_checkable
class EnginePort(Protocol):
    """
    EnginePort protocol defines the minimal interface all engines must implement.

    Required signals:
        sig_token: Text output stream (for LLM-style engines)
        sig_trace: Debug/status messages
        sig_status: SystemStatus transitions (LOADING/RUNNING/READY/ERROR)

    Optional signals (check with hasattr before use):
        sig_usage: Token/step count tracking (LLM-specific)
        sig_image: Image output (vision engines)
        sig_audio: Audio output (audio engines)
        sig_finished: Optional completion notification

    The protocol intentionally keeps optional signals out to prevent forcing
    LLM-centric requirements onto vision/audio engines.
    """
    sig_status: Signal
    sig_trace: Signal
    sig_token: Signal

    def set_model_path(self, payload: dict) -> None:
        ...

    def load_model(self) -> None:
        ...

    def unload_model(self) -> None:
        ...

    def generate(self, payload: dict) -> None:
        ...

    def stop_generation(self) -> None:
        ...

    def shutdown(self) -> None:
        ...



================================================================================
FILE: .\.claude\worktrees\cool-mayer\engine\bridge.py
================================================================================

from PySide6.QtCore import QObject, Signal

from core.state import SystemStatus
from engine.base import EnginePort


class EngineBridge(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_usage = Signal(int)
    sig_image = Signal(object)
    sig_finished = Signal()

    def __init__(self, impl: EnginePort):
        super().__init__()
        self.impl = impl
        self._gen_id = 0
        self._active_gid = 0

        impl.sig_status.connect(self.sig_status)
        if hasattr(impl, "sig_finished"):
            impl.sig_finished.connect(self.sig_finished)

        impl.sig_token.connect(self._on_token)
        impl.sig_trace.connect(self._on_trace)
        if hasattr(impl, "sig_usage"):
            impl.sig_usage.connect(self._on_usage)
        if hasattr(impl, "sig_image"):
            impl.sig_image.connect(self._on_image)

    def _is_current_generation(self) -> bool:
        return self._active_gid == self._gen_id

    def _on_token(self, token: str) -> None:
        if self._is_current_generation():
            self.sig_token.emit(token)

    def _on_trace(self, message: str) -> None:
        if self._is_current_generation():
            self.sig_trace.emit(message)

    def _on_usage(self, usage: int) -> None:
        if self._is_current_generation():
            self.sig_usage.emit(usage)

    def _on_image(self, image: object) -> None:
        if self._is_current_generation():
            self.sig_image.emit(image)

    def set_history(self, payload: dict) -> None:
        if hasattr(self.impl, "set_history"):
            self.impl.set_history(payload)

    def set_model_path(self, payload: dict) -> None:
        if hasattr(self.impl, "set_model_path"):
            self.impl.set_model_path(payload)

    def set_ctx_limit(self, payload: dict) -> None:
        if hasattr(self.impl, "set_ctx_limit"):
            self.impl.set_ctx_limit(payload)

    def load_model(self) -> None:
        self.impl.load_model()

    def unload_model(self) -> None:
        self.impl.unload_model()

    def generate(self, payload: dict) -> None:
        self._gen_id += 1
        self._active_gid = self._gen_id
        self.impl.generate(payload)

    def stop_generation(self) -> None:
        self._gen_id += 1
        self._active_gid = 0
        self.impl.stop_generation()

    def shutdown(self) -> None:
        self.impl.shutdown()



================================================================================
FILE: .\.claude\worktrees\cool-mayer\engine\llm.py
================================================================================

from PySide6.QtCore import QObject, QThread, Signal, QTimer
from core.state import AppState, SystemStatus
from core.llm_config import load_config, MASTER_PROMPT

class ModelLoader(QThread):
    trace = Signal(str)
    finished = Signal(object, int)
    error = Signal(str)

    def __init__(self, path, n_ctx=8192, n_gpu_layers=-1):
        super().__init__()
        self.path = path
        self.n_ctx = n_ctx
        self.n_gpu_layers = n_gpu_layers

    def run(self):
        try:
            try:
                from llama_cpp import Llama
            except ImportError as exc:
                raise RuntimeError(
                    "llama-cpp-python is not installed. Install it to use the local LLM engine."
                ) from exc
            self.trace.emit(f"→ init backend: {self.path}")
            llm_instance = Llama(
                model_path=self.path,
                n_ctx=self.n_ctx,
                n_gpu_layers=self.n_gpu_layers,
                verbose=False
            )
            model_ctx_length = llm_instance._model.n_ctx_train()
            self.finished.emit(llm_instance, model_ctx_length)
        except Exception as e:
            self.error.emit(f"Load Failed: {str(e)}")

class GeneratorWorker(QThread):
    token = Signal(str)
    trace = Signal(str)
    done = Signal(bool, str)
    usage = Signal(int)

    def __init__(self, llm, messages, temp, top_p, max_tokens):
        super().__init__()
        self.llm = llm
        self.messages = messages
        self.temp = temp
        self.top_p = top_p
        self.max_tokens = max_tokens

    def run(self):
        self.trace.emit(f"[WORKER] started: msgs={len(self.messages)}, temp={self.temp}, max_tokens={self.max_tokens}")
        self.trace.emit("→ inference started")
        assistant_chunks = []
        completed = False
        try:
            if self.isInterruptionRequested():
                self.trace.emit("[WORKER] interrupted before inference")
                return

            stream = self.llm.create_chat_completion(
                messages=self.messages,
                temperature=self.temp,
                top_p=self.top_p,
                max_tokens=self.max_tokens,
                stream=True
            )

            total_generated = 0
            for chunk in stream:
                if self.isInterruptionRequested():
                    self.trace.emit("→ inference aborted")
                    break

                if "content" in chunk["choices"][0]["delta"]:
                    text = chunk["choices"][0]["delta"]["content"]
                    assistant_chunks.append(text)
                    self.token.emit(text)
                    total_generated += 1
                    self.usage.emit(total_generated)

            if not self.isInterruptionRequested():
                completed = True
                self.trace.emit("→ inference complete")
        except Exception as e:
            self.trace.emit(f"[WORKER] EXCEPTION: {e}")
            self.trace.emit(f"<span style='color:red'>ERROR: {e}</span>")
        finally:
            self.trace.emit(f"[WORKER] finished: completed={completed}, chunks={len(assistant_chunks)}")
            self.done.emit(completed, "".join(assistant_chunks))

class LLMEngine(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_finished = Signal()
    sig_usage = Signal(int)
    sig_image = Signal(object)
    sig_model_capabilities = Signal(dict)

    def __init__(self, state: AppState):
        super().__init__()
        self.state = state
        self.llm = None
        self.loader = None
        self.worker = None
        self.model_path: str | None = None
        self.conversation_history: list[dict] = []
        self._pending_user_index: int | None = None
        self._load_cancel_requested: bool = False
        self._shutdown_requested: bool = False
        self._status: SystemStatus = SystemStatus.READY
        self._ephemeral_generation: bool = False
        self.model_loaded: bool = False
        self.model_ctx_length: int | None = None
        self.ctx_limit: int = int(getattr(self.state, "ctx_limit", 8192))
        self.gguf_path: str | None = None

    def set_ctx_limit(self, payload: dict) -> None:
        value = payload.get("ctx_limit") if isinstance(payload, dict) else None
        if value is None:
            return
        try:
            self.ctx_limit = int(value)
        except (TypeError, ValueError):
            return

    def set_model_path(self, payload: dict) -> None:
        path = payload.get("path") if isinstance(payload, dict) else None
        self.model_path = path
        self.gguf_path = path
        QTimer.singleShot(0, lambda: self.set_status(SystemStatus.READY))

    def load_model(self):
        if self._status == SystemStatus.LOADING:
            self.sig_trace.emit("ERROR: Load already in progress.")
            self.set_status(SystemStatus.ERROR)
            return
        
        model_path = self.model_path or self.gguf_path
        if not model_path:
            self.sig_trace.emit("ERROR: No GGUF selected.")
            self.set_status(SystemStatus.ERROR)
            return

        self.set_status(SystemStatus.LOADING)
        self._load_cancel_requested = False
        # Keep reference to loader to prevent GC
        n_ctx = (
            min(self.ctx_limit, self.model_ctx_length)
            if self.model_ctx_length
            else self.ctx_limit
        )
        self.loader = ModelLoader(model_path, n_ctx)
        self.loader.trace.connect(self.sig_trace)
        self.loader.error.connect(self._on_load_error)
        self.loader.finished.connect(self._on_load_success)
        self.loader.finished.connect(self._cleanup_loader)
        self.loader.error.connect(self._cleanup_loader)
        self.loader.start()

    def _on_load_success(self, llm_instance, model_ctx_length):
        if self._shutdown_requested:
            del llm_instance
            self.set_status(SystemStatus.READY)
            return

        if self._load_cancel_requested:
            del llm_instance
            self.llm = None
            self.model_loaded = False
            self.set_status(SystemStatus.READY)
            self.sig_trace.emit("→ load cancelled")
            self.loader = None
            return

        self.llm = llm_instance
        self.model_ctx_length = int(model_ctx_length)
        self.ctx_limit = min(self.ctx_limit, self.model_ctx_length)
        self.sig_model_capabilities.emit(
            {
                "model_ctx_length": self.model_ctx_length,
                "ctx_limit": self.ctx_limit,
            }
        )
        self.model_loaded = True
        self.set_status(SystemStatus.READY)
        self.reset_conversation(MASTER_PROMPT)
        self.sig_trace.emit("→ system online")
        self.loader = None

    def _on_load_error(self, err_msg):
        self.sig_trace.emit(f"<span style='color:red'>{err_msg}</span>")
        if self._shutdown_requested:
            self.set_status(SystemStatus.READY)
        else:
            self.set_status(SystemStatus.ERROR)
        self.loader = None

    def _cleanup_loader(self, *args, **kwargs):
        self.loader = None

    def unload_model(self):
        if self._status == SystemStatus.LOADING and self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit("→ unload requested during load; will cancel when init completes")
            return

        if self._status == SystemStatus.RUNNING:
            self.sig_trace.emit("ERROR: Cannot unload while generating.")
            return

        if self.llm:
            self.set_status(SystemStatus.UNLOADING)
            del self.llm
            self.llm = None
        self.model_loaded = False
        self.model_ctx_length = None
        self.reset_conversation(MASTER_PROMPT)
        QTimer.singleShot(0, lambda: self.set_status(SystemStatus.READY))
        self.sig_trace.emit("→ model unloaded")

    def reset_conversation(self, system_prompt):
        self.conversation_history = [{"role": "system", "content": system_prompt}]
        self._pending_user_index = None

    def set_history(self, payload: dict):
        history = payload.get("history", []) if isinstance(payload, dict) else []
        if not isinstance(history, list):
            return
        self.conversation_history = [h for h in history if isinstance(h, dict)]
        self._pending_user_index = None

    def _compile_system_prompt(self, config):
        tags = config.get("behavior_tags", [])
        cleaned = [tag.strip() for tag in tags if isinstance(tag, str) and tag.strip()]
        if not cleaned:
            return MASTER_PROMPT
        return f"{MASTER_PROMPT}\n\n[BEHAVIOR TAGS]\n" + "\n".join(cleaned)

    def generate(self, payload: dict):
        if not self.model_loaded:
            self.sig_trace.emit("ERROR: Model offline.")
            self.set_status(SystemStatus.ERROR)
            return

        if isinstance(payload, dict) and "ctx_limit" in payload:
            try:
                self.ctx_limit = int(payload.get("ctx_limit", self.ctx_limit))
            except (TypeError, ValueError):
                pass

        if self._status == SystemStatus.RUNNING:
            self.sig_trace.emit("ERROR: Busy. Wait for completion.")
            self.set_status(SystemStatus.ERROR)
            return

        self.set_status(SystemStatus.RUNNING)

        prompt = payload.get("prompt", "")
        self.sig_trace.emit(f"[ENGINE] generate: history_len={len(self.conversation_history)}, prompt={repr(prompt[:80])}, model_loaded={self.model_loaded}")
        config = payload.get("config")
        if config is None:
            config = load_config()

        system_prompt = self._compile_system_prompt(config)
        temp = float(config.get("temp", 0.7))
        top_p = float(config.get("top_p", 0.9))
        max_tokens = int(config.get("max_tokens", 2048))

        self._ephemeral_generation = bool(payload.get("ephemeral", False))
        thinking_mode = bool(payload.get("thinking_mode", False))

        if not self.conversation_history:
            self.reset_conversation(MASTER_PROMPT)

        system_entry = {"role": "system", "content": system_prompt}
        if self.conversation_history[0].get("role") != "system":
            self.conversation_history.insert(0, system_entry)
        else:
            self.conversation_history[0] = system_entry

        is_update = prompt.startswith("You were interrupted mid-generation.")
        if not self._ephemeral_generation and not is_update:
            self.conversation_history.append({"role": "user", "content": prompt})
            self._pending_user_index = len(self.conversation_history) - 1
            messages = list(self.conversation_history)
        else:
            messages = list(self.conversation_history)
            if not is_update:
                messages.append({"role": "user", "content": prompt})
            self._pending_user_index = None

        if thinking_mode and not self._ephemeral_generation:
            messages = list(messages)
            messages.append(
                {
                    "role": "system",
                    "content": "Use private reasoning to think step-by-step, then provide a concise final answer.",
                }
            )

        self.worker = GeneratorWorker(
            self.llm, messages, temp,
            top_p, max_tokens
        )
        self.worker.token.connect(self.sig_token)
        self.worker.trace.connect(self.sig_trace)
        self.worker.usage.connect(self._on_usage_update)
        self.worker.done.connect(self._on_gen_finish)
        self.worker.start()

    def stop_generation(self):
        if self._status == SystemStatus.LOADING and self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit("→ load cancel requested; will stop after initialization completes")
            return

        self._ephemeral_generation = False
        if self.worker and self.worker.isRunning():
            self.worker.requestInterruption()

    def _on_usage_update(self, count):
        self.sig_usage.emit(count)

    def _on_gen_finish(self, completed, assistant_text):
        self.sig_trace.emit(f"[ENGINE] _on_gen_finish: completed={completed}, text_len={len(assistant_text)}")
        if completed and not self._ephemeral_generation:
            self.conversation_history.append(
                {"role": "assistant", "content": assistant_text}
            )
        self._pending_user_index = None
        self._ephemeral_generation = False
        self.sig_token.emit("\n")
        self.sig_finished.emit()
        self.set_status(SystemStatus.READY)

    def set_status(self, s):
        self._status = s
        self.sig_status.emit(s)

    def shutdown(self):
        self._shutdown_requested = True
        self.stop_generation()

        if self.worker:
            self.worker.requestInterruption()
            self.worker.wait(1500)
            self.worker = None

        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.loader.wait(150)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\engine\vision.py
================================================================================

from __future__ import annotations

from PySide6.QtCore import QObject, QThread, Signal, QTimer

from core.state import AppState, SystemStatus


class PipelineLoader(QThread):
    trace = Signal(str)
    finished = Signal(object)
    error = Signal(str)

    def __init__(self, model_path: str):
        super().__init__()
        self.model_path = model_path

    def run(self) -> None:
        try:
            try:
                import torch
                from diffusers import StableDiffusionPipeline
            except ImportError as exc:
                raise RuntimeError(
                    "diffusers is not installed. pip install diffusers"
                ) from exc

            device = "cuda" if torch.cuda.is_available() else "cpu"
            dtype = torch.float16 if device == "cuda" else torch.float32

            if self.isInterruptionRequested():
                return

            self.trace.emit(f"loading pipeline: {self.model_path}")
            if self.model_path.endswith((".safetensors", ".ckpt")):
                pipe = StableDiffusionPipeline.from_single_file(
                    self.model_path,
                    torch_dtype=dtype,
                    safety_checker=None,
                    requires_safety_checker=False,
                )
            else:
                pipe = StableDiffusionPipeline.from_pretrained(
                    self.model_path,
                    torch_dtype=dtype,
                    safety_checker=None,
                    requires_safety_checker=False,
                )

            pipe = pipe.to(device)
            self.finished.emit(pipe)
        except Exception as exc:
            self.error.emit(str(exc))


class GenerationWorker(QThread):
    image = Signal(object)
    trace = Signal(str)
    done = Signal(bool, str)

    def __init__(
        self,
        pipe,
        prompt: str,
        steps: int,
        guidance: float,
        seed: int | None,
    ):
        super().__init__()
        self.pipe = pipe
        self.prompt = prompt
        self.steps = steps
        self.guidance = guidance
        self.seed = seed

    def run(self) -> None:
        completed = False
        err_msg = ""
        try:
            import torch

            if self.isInterruptionRequested():
                return

            device = "cuda" if torch.cuda.is_available() else "cpu"
            generator = None
            if self.seed is not None:
                generator = torch.Generator(device=device).manual_seed(self.seed)

            def _callback(step: int, timestep: int, latents) -> None:
                if self.isInterruptionRequested():
                    raise RuntimeError("Generation interrupted")

            self.trace.emit("generation started")
            result = self.pipe(
                self.prompt,
                num_inference_steps=self.steps,
                guidance_scale=self.guidance,
                generator=generator,
                callback=_callback,
                callback_steps=1,
            )
            if self.isInterruptionRequested():
                return
            self.image.emit(result.images[0])
            self.trace.emit("generation complete")
            completed = True
        except Exception as exc:
            err_msg = str(exc)
        finally:
            self.done.emit(completed, err_msg)


class VisionEngine(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_usage = Signal(int)
    sig_finished = Signal()
    sig_image = Signal(object)

    def __init__(self, state: AppState):
        super().__init__()
        self.state = state
        self.pipe = None
        self.model_path: str | None = None
        self._loaded_path: str | None = None
        self.loader: PipelineLoader | None = None
        self.worker: GenerationWorker | None = None
        self._load_cancel_requested = False
        self._shutdown_requested = False

    def set_model_path(self, payload: dict) -> None:
        path = payload.get("path") if isinstance(payload, dict) else None
        self.model_path = path
        QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))

    def load_model(self) -> None:
        if self.loader and self.loader.isRunning():
            self.sig_trace.emit("VISION: load already in progress.")
            QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))
            return

        if not self.model_path:
            self.sig_trace.emit("VISION: ERROR: No model selected.")
            self.sig_status.emit(SystemStatus.ERROR)
            return

        if self.pipe and self._loaded_path == self.model_path:
            self.sig_trace.emit("VISION: pipeline already loaded.")
            QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))
            return

        if self.pipe and self._loaded_path != self.model_path:
            self.unload_model()

        self.sig_status.emit(SystemStatus.LOADING)
        self.sig_trace.emit("VISION: loading pipeline")
        self._load_cancel_requested = False
        self.loader = PipelineLoader(self.model_path)
        self.loader.trace.connect(self._emit_trace)
        self.loader.error.connect(self._on_load_error)
        self.loader.finished.connect(self._on_load_success)
        self.loader.finished.connect(self._cleanup_loader)
        self.loader.error.connect(self._cleanup_loader)
        self.loader.start()

    def _emit_trace(self, message: str) -> None:
        self.sig_trace.emit(f"VISION: {message}")

    def _on_load_success(self, pipe) -> None:
        if self._shutdown_requested:
            del pipe
            self.sig_status.emit(SystemStatus.READY)
            return

        if self._load_cancel_requested:
            del pipe
            self.pipe = None
            self._loaded_path = None
            self.sig_status.emit(SystemStatus.READY)
            self.sig_trace.emit("VISION: load cancelled")
            self.loader = None
            return

        self.pipe = pipe
        self._loaded_path = self.model_path
        self.sig_trace.emit("VISION: pipeline ready")
        self.sig_status.emit(SystemStatus.READY)
        self.loader = None

    def _on_load_error(self, err_msg: str) -> None:
        self.sig_trace.emit(f"VISION: ERROR: {err_msg}")
        self.sig_status.emit(SystemStatus.ERROR)
        self.loader = None

    def _cleanup_loader(self, *args, **kwargs) -> None:
        self.loader = None

    def unload_model(self) -> None:
        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit(
                "VISION: unload requested during load; will cancel after init completes"
            )
            return

        if self.worker and self.worker.isRunning():
            self.sig_trace.emit("VISION: ERROR: Cannot unload while generating.")
            return

        self.sig_status.emit(SystemStatus.UNLOADING)
        if self.pipe:
            del self.pipe
            self.pipe = None
            self._loaded_path = None

        try:
            import torch

            if torch.cuda.is_available():
                torch.cuda.empty_cache()
        except Exception:
            pass

        QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))

    def generate(self, payload: dict) -> None:
        if not self.pipe:
            self.sig_trace.emit("VISION: ERROR: Model offline.")
            self.sig_status.emit(SystemStatus.READY)
            return

        if self.worker and self.worker.isRunning():
            self.sig_trace.emit("VISION: ERROR: Busy. Wait for completion.")
            return

        config = payload.get("config", payload)
        prompt = config.get("prompt", payload.get("prompt", ""))

        steps = int(config.get("steps", 25))
        guidance_scale = float(config.get("guidance_scale", 7.5))
        seed = config.get("seed")
        if isinstance(seed, int) and seed < 0:
            seed = None

        self.sig_status.emit(SystemStatus.RUNNING)
        self.worker = GenerationWorker(
            self.pipe,
            prompt,
            steps,
            guidance_scale,
            seed,
        )
        self.worker.image.connect(self.sig_image)
        self.worker.trace.connect(self._emit_trace)
        self.worker.done.connect(self._on_gen_finish)
        self.worker.start()

    def stop_generation(self) -> None:
        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit(
                "VISION: load cancel requested; will stop after initialization completes"
            )
            return

        if self.worker and self.worker.isRunning():
            self.worker.requestInterruption()

    def _on_gen_finish(self, completed: bool, err_msg: str) -> None:
        if completed:
            self.sig_finished.emit()
            self.sig_status.emit(SystemStatus.READY)
        elif err_msg == "Generation interrupted":
            self.sig_trace.emit("VISION: generation interrupted")
            self.sig_status.emit(SystemStatus.READY)
        else:
            self.sig_trace.emit(f"VISION: ERROR: {err_msg}")
            self.sig_status.emit(SystemStatus.ERROR)
        self.worker = None

    def shutdown(self) -> None:
        self._shutdown_requested = True
        self.stop_generation()

        if self.worker:
            self.worker.requestInterruption()
            self.worker.wait(1500)
            self.worker = None

        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.loader.wait(150)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\monokernel\bridge.py
================================================================================

from __future__ import annotations

from core.task import Task
from monokernel.dock import MonoDock


class MonoBridge:
    def __init__(self, dock: MonoDock):
        self.dock = dock

    def wrap(self, source: str, command: str, target: str, **kwargs) -> Task:
        priority = int(kwargs.pop("priority", 2))
        payload = kwargs.pop("payload", kwargs)
        return Task.new(
            addon_pid=source,
            target=target,
            command=command,
            payload=payload,
            priority=priority,
        )

    def submit(self, task: Task) -> None:
        self.dock.enqueue(task)

    def cancel(self, task_id: str) -> None:
        self.dock.cancel_task(task_id)

    def cancel_addon(self, addon_pid: str) -> None:
        self.dock.cancel_addon(addon_pid)

    def stop(self, target: str = "all") -> None:
        self.dock.on_stop(target)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\monokernel\dock.py
================================================================================

from __future__ import annotations

from collections import deque
from typing import Deque

from core.task import Task, TaskStatus
from monokernel.guard import MonoGuard


class MonoDock:
    def __init__(self, guard: MonoGuard):
        self.guard = guard
        self.queues: dict[str, Deque[Task]] = {}
        self.cancelled_task_ids: set[str] = set()
        self.cancelled_addons: set[str] = set()
        self._in_submit: dict[str, bool] = {}
        self.guard.sig_engine_ready.connect(self._on_engine_ready)

    def enqueue(self, task: Task) -> None:
        self.guard.sig_trace.emit("system", f"[DOCK] enqueue: task={task.id}, cmd={task.command}, target={task.target}, priority={task.priority}")
        if task.priority == 1:
            self.on_stop(task.target)
            return
        queue = self.queues.setdefault(task.target, deque())
        self._insert_task(queue, task)
        self._try_submit(task.target)

    def cancel_task(self, task_id: str) -> None:
        self.cancelled_task_ids.add(task_id)
        for engine_key in self.guard.engines.keys():
            active = self.guard.get_active_task(engine_key)
            if active and str(active.id) == task_id:
                self.guard.stop(engine_key)

    def cancel_addon(self, addon_pid: str) -> None:
        self.cancelled_addons.add(addon_pid)
        for engine_key in self.guard.engines.keys():
            active = self.guard.get_active_task(engine_key)
            if active and active.addon_pid == addon_pid:
                self.guard.stop(engine_key)

    def on_stop(self, target: str = "all") -> None:
        self.guard.stop(target)
        if target == "all":
            for queue in self.queues.values():
                for task in queue:
                    self.cancelled_task_ids.add(str(task.id))
        else:
            queue = self.queues.get(target)
            if queue:
                for task in queue:
                    self.cancelled_task_ids.add(str(task.id))

    def _on_engine_ready(self, engine_key: str) -> None:
        self._try_submit(engine_key)

    def _try_submit(self, engine_key: str) -> None:
        if self._in_submit.get(engine_key):
            self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: BLOCKED by _in_submit for {engine_key}")
            return
        queue = self.queues.get(engine_key)
        if not queue:
            self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: empty queue for {engine_key}")
            return

        self._in_submit[engine_key] = True
        try:
            while queue:
                task = queue[0]
                if self._is_cancelled(task):
                    self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: CANCELLED task={task.id}, cmd={task.command}")
                    task.status = TaskStatus.CANCELLED
                    if queue:
                        queue.popleft()
                    self.cancelled_task_ids.discard(str(task.id))
                    continue
                accepted = self.guard.submit(task)
                self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: guard.submit returned {accepted} for task={task.id}, cmd={task.command}")
                if accepted and queue:
                    queue.popleft()
                break
        finally:
            self._in_submit[engine_key] = False

    def _is_cancelled(self, task: Task) -> bool:
        return str(task.id) in self.cancelled_task_ids or task.addon_pid in self.cancelled_addons

    def _insert_task(self, queue: Deque[Task], task: Task) -> None:
        if task.priority == 2:
            items = list(queue)
            insert_at = 0
            for existing in items:
                if existing.priority != 2:
                    break
                insert_at += 1
            items.insert(insert_at, task)
            queue.clear()
            queue.extend(items)
        else:
            queue.append(task)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\monokernel\guard.py
================================================================================

from __future__ import annotations

from datetime import datetime
from typing import Optional

from core.paths import LOG_DIR

from PySide6.QtCore import QObject, Signal, QTimer

from core.state import AppState, SystemStatus
from core.task import Task, TaskStatus
from engine.base import EnginePort

ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "set_history": "set_history",
    "set_ctx_limit": "set_ctx_limit",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}

IMMEDIATE_COMMANDS = {"set_history", "set_path", "set_ctx_limit"}
PAYLOAD_COMMANDS = {"generate"}


class MonoGuard(QObject):
    sig_token = Signal(str, str)
    sig_trace = Signal(str, str)
    sig_status = Signal(str, SystemStatus)
    sig_engine_ready = Signal(str)
    sig_usage = Signal(str, int)
    sig_image = Signal(object)
    sig_finished = Signal(str, str)

    def __init__(self, state: AppState, engines: dict[str, EnginePort]):
        super().__init__()
        self.state = state
        self.engines = engines
        self.active_tasks: dict[str, Optional[Task]] = {
            key: None for key in engines.keys()
        }
        self._stop_requested: dict[str, bool] = {key: False for key in engines.keys()}
        self._viztracer = None

        self._engine_connections: dict[str, dict[str, object]] = {}
        for key, engine in engines.items():
            self._connect_engine_signals(key, engine)


    def _connect_engine_signals(self, key: str, engine: EnginePort) -> None:
        status_slot = lambda status, engine_key=key: self._on_status_changed(engine_key, status)
        token_slot = lambda t, ek=key: self.sig_token.emit(ek, t)
        trace_slot = lambda m, ek=key: self.sig_trace.emit(ek, m)
        finished_slot = lambda engine_key=key: self._on_engine_finished(engine_key)

        engine.sig_status.connect(status_slot)
        engine.sig_token.connect(token_slot)
        engine.sig_trace.connect(trace_slot)

        usage_slot = None
        if hasattr(engine, "sig_usage"):
            usage_slot = lambda used, ek=key: self.sig_usage.emit(ek, used)
            engine.sig_usage.connect(usage_slot)

        image_slot = None
        if hasattr(engine, "sig_image"):
            image_slot = self.sig_image.emit
            engine.sig_image.connect(image_slot)

        has_finished = hasattr(engine, "sig_finished")
        if has_finished:
            engine.sig_finished.connect(finished_slot)

        self._engine_connections[key] = {
            "status": status_slot,
            "token": token_slot,
            "trace": trace_slot,
            "usage": usage_slot,
            "image": image_slot,
            "finished": finished_slot if has_finished else None,
        }

    def _disconnect_engine_signals(self, key: str, engine: EnginePort) -> None:
        slots = self._engine_connections.pop(key, None)
        if not slots:
            return
        for signal_name, slot in slots.items():
            if slot is None:
                continue
            signal = getattr(engine, f"sig_{signal_name}", None)
            if signal is None:
                continue
            try:
                signal.disconnect(slot)
            except (TypeError, RuntimeError):
                pass

    def register_engine(self, key: str, engine: EnginePort):
        if key in self.engines:
            self.unregister_engine(key)
        self.engines[key] = engine
        self.active_tasks[key] = None
        self._stop_requested[key] = False
        self._connect_engine_signals(key, engine)

    def unregister_engine(self, key: str):
        engine = self.engines.get(key)
        if engine is None:
            return
        self._disconnect_engine_signals(key, engine)
        self.active_tasks.pop(key, None)
        self._stop_requested.pop(key, None)
        del self.engines[key]

    def get_active_task_id(self, engine_key: str) -> str | None:
        task = self.active_tasks.get(engine_key)
        return str(task.id) if task else None

    def get_active_task(self, engine_key: str) -> Task | None:
        return self.active_tasks.get(engine_key)

    def submit(self, task: Task) -> bool:
        engine = self.engines.get(task.target)
        if engine is None:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED unknown engine target={task.target}")
            self.sig_trace.emit("system", f"ERROR: Unknown engine target: {task.target}")
            return False

        method_name = ENGINE_DISPATCH.get(task.command)
        if not method_name:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED unknown command={task.command}")
            self.sig_trace.emit("system", f"ERROR: Unknown command: {task.command}")
            task.status = TaskStatus.FAILED
            return False

        handler = getattr(engine, method_name, None)
        if not handler:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED no handler for {method_name}")
            self.sig_trace.emit("system", f"ERROR: Engine lacks handler: {method_name}")
            task.status = TaskStatus.FAILED
            return False

        if task.command in IMMEDIATE_COMMANDS:
            self.sig_trace.emit("system", f"[GUARD] submit: IMMEDIATE {task.command} task={task.id}")
            self.sig_trace.emit("system", f"GUARD: IMMEDIATE {task.command} task={task.id}")
            task.status = TaskStatus.RUNNING
            handler(task.payload)
            task.status = TaskStatus.DONE
            return True

        if self.active_tasks.get(task.target) is not None:
            active = self.active_tasks.get(task.target)
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED BUSY target={task.target}, active_task={active.id if active else None}, active_cmd={active.command if active else None}")
            self.sig_trace.emit("system", f"GUARD: rejected task={task.id} target={task.target} (busy)")
            return False

        self.sig_trace.emit("system", f"[GUARD] submit: ACCEPTED task={task.id} cmd={task.command} target={task.target}")
        self.sig_trace.emit("system", f"GUARD: accepted task={task.id} target={task.target} command={task.command}")
        self.active_tasks[task.target] = task
        task.status = TaskStatus.RUNNING

        if task.command in PAYLOAD_COMMANDS:
            handler(task.payload)
        else:
            handler()
        return True

    def stop(self, target: str = "all") -> None:
        self.sig_trace.emit("system", f"GUARD: STOP target={target}")
        if target == "all":
            keys = list(self.engines.keys())
        else:
            keys = [target]

        for key in keys:
            engine = self.engines.get(key)
            if not engine:
                continue
            task = self.active_tasks.get(key)
            if task is not None:
                self._stop_requested[key] = True
            engine.stop_generation()

    def _on_engine_finished(self, engine_key: str) -> None:
        task = self.active_tasks.get(engine_key)
        if task:
            self.sig_finished.emit(engine_key, str(task.id))
            self.sig_trace.emit(engine_key, f"GUARD: finished engine={engine_key} task={task.id}")

    def _on_status_changed(self, engine_key: str, new_status: SystemStatus) -> None:
        self.sig_trace.emit("system", f"[GUARD] _on_status_changed: engine={engine_key}, status={new_status}, active_task={self.active_tasks.get(engine_key) is not None}")
        self.sig_status.emit(engine_key, new_status)

        if new_status == SystemStatus.ERROR:
            task = self.active_tasks.get(engine_key)
            had_task = task is not None
            if task:
                task.status = TaskStatus.FAILED
            self.active_tasks[engine_key] = None
            self._stop_requested[engine_key] = False
            self.sig_status.emit(engine_key, SystemStatus.READY)
            if had_task:
                QTimer.singleShot(0, lambda: self.sig_engine_ready.emit(engine_key))
            return

        if new_status == SystemStatus.READY:
            task = self.active_tasks.get(engine_key)
            had_task = task is not None
            if task and task.status == TaskStatus.RUNNING:
                if self._stop_requested.get(engine_key, False):
                    task.status = TaskStatus.CANCELLED
                else:
                    task.status = TaskStatus.DONE
            self.active_tasks[engine_key] = None
            self._stop_requested[engine_key] = False
            if had_task:
                QTimer.singleShot(0, lambda: self.sig_engine_ready.emit(engine_key))


    def enable_viztracer(self, enabled: bool) -> None:
        if enabled:
            if self._viztracer is not None:
                return
            try:
                from viztracer import VizTracer
            except Exception as exc:
                self.sig_trace.emit("system", f"OVERSEER: viztracer unavailable: {exc}")
                return
            try:
                self._viztracer = VizTracer(
                    min_duration=5000,
                    ignore_frozen=True,
                    exclude_files=["*/site-packages/*"],
                )
            except TypeError:
                self._viztracer = VizTracer(
                    min_duration=5000,
                    ignore_frozen=True,
                )
            except Exception:
                self._viztracer = VizTracer()
            self._viztracer.start()
            self.sig_trace.emit("system", "OVERSEER: viztracer started")
            return

        tracer = self._viztracer
        if tracer is None:
            return
        tracer.stop()
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        out_path = LOG_DIR / f"viztrace_{ts}.json"
        tracer.save(str(out_path))
        self.sig_trace.emit("system", f"OVERSEER: viztracer saved {out_path}")
        self._viztracer = None



================================================================================
FILE: .\.claude\worktrees\cool-mayer\monokernel\__init__.py
================================================================================





================================================================================
FILE: .\.claude\worktrees\cool-mayer\README\architecture.md
================================================================================

# MONOLITH ARCHITECTURE — Agent Reference

**Purpose**: This document maps Monolith's complete architecture with explicit signal flows, contracts, and implementation patterns. Everything an agent needs to understand the system in one read.

**Philosophy**: Sovereignty-focused local-first AI workstation with deterministic core (MonoKernel) and probabilistic periphery (engines/modules).

---

## TABLE OF CONTENTS

1. [System Overview](#system-overview)
2. [Component Hierarchy](#component-hierarchy)
3. [Signal Flow Architecture](#signal-flow-architecture)
4. [MonoKernel Contract (v2)](#monokernel-contract-v2)
5. [Engine Architecture](#engine-architecture)
6. [Addon System](#addon-system)
7. [Task Queue System](#task-queue-system)
8. [Bootstrap Sequence](#bootstrap-sequence)
9. [Critical Patterns](#critical-patterns)
10. [Implementation Details](#implementation-details)

---

## SYSTEM OVERVIEW

### Core Principle
**MonoKernel decides WHEN things happen — never WHAT happens.**

Monolith enforces strict separation:
- **Deterministic Core**: MonoGuard + MonoDock (arbitration only)
- **Probabilistic Periphery**: Engines (LLM, Vision, Audio) + UI/Modules (execution)

### Component Layers
```
UI/Addons (presentation + user interaction)
    ↕ signals only
MonoKernel (arbitration + routing)
    ↕ signals only  
Engines (execution + computation)
```

**Rule**: UI never calls engines directly. Engines never emit to UI directly. Everything routes through MonoKernel.

---

## COMPONENT HIERARCHY

### Directory Structure
```
monolith-main/
├── monokernel/          # Core arbitration layer (FROZEN v1)
│   ├── guard.py         # Signal router + engine orchestrator
│   ├── dock.py          # Task queue + cancellation
│   └── bridge.py        # UI→Kernel API
├── engine/              # Execution layer
│   ├── base.py          # EnginePort protocol
│   ├── bridge.py        # EngineBridge (generation gating)
│   ├── llm.py           # LLMEngine implementation
│   └── vision.py        # VisionEngine implementation
├── ui/                  # Presentation layer
│   ├── main_window.py   # Main chrome + global signals
│   ├── pages/           # Page addons (full screen)
│   │   └── chat.py      # Chat interface (Terminal addon)
│   ├── modules/         # Module addons (stackable)
│   │   ├── sd.py        # Vision module
│   │   └── injector.py  # Context injector module
│   ├── addons/          # Addon system infrastructure
│   │   ├── spec.py      # AddonSpec (id, kind, factory)
│   │   ├── registry.py  # AddonRegistry (addon storage)
│   │   ├── host.py      # AddonHost (lifecycle manager)
│   │   ├── context.py   # AddonContext (dependency injection)
│   │   └── builtin.py   # Built-in addon factories + wiring
│   └── components/      # Reusable UI components
├── core/                # Shared state + utilities
│   ├── state.py         # AppState + SystemStatus enum
│   ├── task.py          # Task + TaskStatus (kernel commands)
│   └── llm_config.py    # LLM configuration + behavior tags
└── bootstrap.py         # Application entry point
```

---

## SIGNAL FLOW ARCHITECTURE

### Signal Flow: User Prompt → LLM Response

This is the canonical signal chain every agent should understand:

```
┌─────────────┐
│  User types │ "Hello"
│  in input   │
└─────┬───────┘
      │
      ↓ QLineEdit.returnPressed or btn_send.clicked
┌─────────────────┐
│  PageChat       │
│  .handle_send   │──┐
│    _click()     │  │ Emits sig_generate
└─────────────────┘  │
                     ↓
              ┌──────────────┐
              │ terminal_    │  (in builtin.py)
              │  factory     │  Wiring layer
              │  lambda      │
              └──────┬───────┘
                     │
                     ↓ ctx.bridge.submit(Task)
              ┌──────────────┐
              │  MonoBridge  │
              │  .submit()   │
              └──────┬───────┘
                     │
                     ↓ dock.enqueue(Task)
              ┌──────────────┐
              │  MonoDock    │
              │  .enqueue()  │──┐ Queues task
              └──────────────┘  │
                                ↓ _try_submit()
                         ┌──────────────┐
                         │  MonoGuard   │
                         │  .submit()   │──┐ Routes to engine
                         └──────────────┘  │
                                           ↓ handler(payload)
                                    ┌──────────────┐
                                    │ EngineBridge │
                                    │  .generate() │──┐ Generation gating
                                    └──────────────┘  │
                                                      ↓ impl.generate(payload)
                                               ┌──────────────┐
                                               │  LLMEngine   │
                                               │  .generate() │──┐ Creates worker thread
                                               └──────────────┘  │
                                                                 ↓
                                                          ┌─────────────┐
                                                          │ Generator   │
                                                          │   Worker    │ (QThread)
                                                          └─────┬───────┘
                                                                │
                              ┌─────────────────────────────────┴─────────────────────────┐
                              │  Token stream from llama.cpp                              │
                              └─────────┬─────────────────────────────────────────────────┘
                                        │
                                        ↓ worker.token.emit(text)
                                 ┌──────────────┐
                                 │  LLMEngine   │
                                 │  sig_token   │
                                 └──────┬───────┘
                                        │
                                        ↓ Connected via EngineBridge
                                 ┌──────────────┐
                                 │ EngineBridge │
                                 │  sig_token   │──┐ Generation-gated
                                 └──────────────┘  │
                                                   ↓ Only if _active_gid matches
                                            ┌──────────────┐
                                            │  MonoGuard   │
                                            │  sig_token   │──┐ Verbatim re-emit
                                            └──────────────┘  │
                                                              ↓ Connected in builtin.py
                                                       ┌──────────────┐
                                                       │  PageChat    │
                                                       │  .append_    │
                                                       │   token()    │
                                                       └──────────────┘
                                                              │
                                                              ↓ Accumulates tokens
                                                        [Display in UI]
```

### Key Signal Chains

#### 1. SEND Signal Chain (User → Kernel → Engine)
```
PageChat.sig_generate
  → builtin.terminal_factory lambda
    → MonoBridge.submit(Task)
      → MonoDock.enqueue(Task)
        → MonoDock._try_submit()
          → MonoGuard.submit(Task)
            → engine.generate(payload)
```

#### 2. TOKEN Signal Chain (Engine → Kernel → UI)
```
GeneratorWorker.token.emit(str)
  → LLMEngine.sig_token
    → EngineBridge.sig_token (gated)
      → MonoGuard.sig_token (verbatim)
        → PageChat.append_token()
```

#### 3. STATUS Signal Chain (Engine → Kernel → UI)
```
LLMEngine.set_status(SystemStatus)
  → LLMEngine.sig_status.emit(status)
    → EngineBridge.sig_status
      → MonoGuard.sig_status
        → MonolithUI.update_status()
        → PageChat.update_status()
```

#### 4. STOP Signal Chain (UI → Kernel → Engine)
```
PageChat.sig_stop
  → builtin.terminal_factory lambda
    → MonoBridge.stop("llm")
      → MonoDock.on_stop("llm")
        → MonoGuard.stop("llm")
          → engine.stop_generation()
            → GeneratorWorker.requestInterruption()
```

---

## MONOKERNEL CONTRACT (v2)

> Note: The authoritative contract is `monokernel/Kernel_Contract_v2.txt`.


### Purpose (Non-Negotiable)
MonoGuard is the **sole authority** between UI and engines. Its role is **arbitration, not computation**.

### Authority Rules

#### 1.1 Single Ingress
- All user commands affecting execution **MUST** pass through MonoGuard
- UI **MUST NOT** call engine methods directly
- Addons **MUST NOT** call engine methods directly

#### 1.2 Single Egress
- All execution state, tokens, traces, usage metrics **MUST** pass through MonoGuard
- UI **MUST NOT** subscribe to engine signals directly
- Engines **MUST NEVER** emit directly to UI

### Kernel Scope

**The kernel MAY:**
- Route commands
- Gate execution by system state
- Preempt execution via STOP
- Queue at most one pending command
- Re-emit engine signals verbatim
- Observe system state transitions

**The kernel MUST NOT:**
- Execute business logic
- Perform blocking operations
- Sleep, wait, or poll
- Contain UI logic
- Contain engine logic
- Know what "chat", "LLM", or "RAG" is
- Accumulate feature-specific state

### STOP Semantics (Hard Law)

#### 3.1 STOP Always Wins
When STOP is issued:
- Current execution is interrupted immediately (non-blocking)
- Any pending command is cleared
- Control returns to UI instantly

#### 3.2 Truthful State
`SystemStatus.READY` **MUST** only be emitted when:
- No execution is running
- No engine work is active
- No pending command is executing

The kernel **must never emit READY prematurely**.

### Pending Command Rule

#### 4.1 Single Pending Slot
- Kernel may hold **at most one** pending command
- Pending commands exist **only** to resume after STOP-based preemption

#### 4.2 Replay on READY
- Pending command may execute once when system transitions to READY
- Pending commands are discarded if STOP is explicitly invoked
- No scheduling, prioritization, or batching exists in v1

### Engine Isolation
The engine:
- Is execution-only
- Knows nothing about UI
- Knows nothing about kernel rules
- Knows nothing about addons
- Accepts commands and emits signals **only**

**The kernel adapts the engine; the engine never adapts to the kernel.**

### UI Restrictions
The UI:
- May emit commands freely
- **MUST NOT** assume commands will execute
- **MUST NOT** block waiting for execution
- **MUST** treat kernel signals as authoritative truth

**UI correctness depends on kernel truth, not intent.**

---

## ENGINE ARCHITECTURE

### EnginePort Protocol
All engines implement this protocol (defined in `engine/base.py`):

```python
@runtime_checkable
class EnginePort(Protocol):
    # Required signals
    sig_status: Signal  # SystemStatus transitions
    sig_trace: Signal   # Debug/status messages
    sig_token: Signal   # Text output stream
    
    # Required methods
    def set_model_path(self, payload: dict) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...
```

**Optional signals** (check with `hasattr` before use):
- `sig_usage`: Token/step count tracking (LLM-specific)
- `sig_image`: Image output (Vision engines)
- `sig_audio`: Audio output (Audio engines)
- `sig_finished`: Optional completion notification

### EngineBridge Pattern

**Purpose**: Generation gating to prevent signals from stale generations reaching the UI.

**Mechanism**:
```python
# Each generate() call gets a unique generation ID
self._gen_id += 1
gid = self._gen_id
self._active_gid = gid
self._connect_gated_handlers(gid)

# Signals only emit if gid matches _active_gid
lambda t, gid=gid: self.sig_token.emit(t) if self._active_gid == gid else None
```

**Result**: When `stop_generation()` is called, the generation ID increments, and all signals from the previous generation are automatically ignored.

### Engine Implementations

#### LLMEngine (`engine/llm.py`)
**State Machine**:
```
READY → set_model_path() → READY
READY → load_model() → LOADING → READY | ERROR
READY → generate() → RUNNING → READY | ERROR
RUNNING → stop_generation() → READY
READY → unload_model() → UNLOADING → READY
```

**Worker Threads**:
- `ModelLoader`: Loads GGUF via llama-cpp-python
- `GeneratorWorker`: Streaming inference with interruption support

**Conversation Management**:
- Maintains `conversation_history: list[dict]` with roles: system, user, assistant
- System prompt injection: `[{role: system, content: prompt}, {role: system, content: CONTEXT: ...}, ...]`
- Pending user index tracking for UPDATE semantics

#### VisionEngine (`engine/vision.py`)
**State Machine**: Same as LLMEngine

**Worker Threads**:
- `PipelineLoader`: Loads Stable Diffusion via diffusers
- `GenerationWorker`: Step-based image generation with callbacks

**Signals**:
- `sig_image`: Emits PIL Image objects
- `sig_trace`: Step progress messages
- No `sig_token` (not text-based)

---

## ADDON SYSTEM

### Addon Types

**Two kinds**:
1. **Page addons** (`kind="page"`): Full-screen views in main content area
2. **Module addons** (`kind="module"`): Stackable floating modules with icons in module strip

### AddonSpec
```python
@dataclass(frozen=True)
class AddonSpec:
    id: str                                    # Unique identifier
    kind: Literal["page", "module"]           # Addon type
    title: str                                # Display name
    icon: str | None                          # Unicode icon or None
    factory: Callable[[AddonContext], QWidget] # Widget constructor
```

### AddonContext (Dependency Injection)
```python
@dataclass
class AddonContext:
    state: AppState        # Shared application state
    guard: MonoGuard       # Kernel signal router
    bridge: MonoBridge     # Task submission API
    ui: MonolithUI | None  # Main window (for modules)
    host: AddonHost | None # Addon lifecycle manager
```

### Addon Lifecycle

#### Page Addon
```python
# Mounted once, lives forever
def addons_page_factory(ctx: AddonContext) -> QWidget:
    w = PageAddons(ctx.state)
    # Wire signals
    return w

# Registration
registry.register(AddonSpec(
    id="addons",
    kind="page",
    title="ADDONS",
    icon=None,
    factory=addons_page_factory
))

# Mounting
host.mount_page("addons")  # Returns cached widget if exists
```

#### Module Addon
```python
# Created fresh each launch, gets unique instance ID
def terminal_factory(ctx: AddonContext) -> QWidget:
    w = PageChat(ctx.state)
    
    # OUTGOING (addon → kernel)
    w.sig_generate.connect(
        lambda prompt: ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "generate", "llm", 
                          payload={"prompt": prompt, "config": w.config})
        )
    )
    w.sig_stop.connect(lambda: ctx.bridge.stop("llm"))
    
    # INCOMING (kernel → addon)
    ctx.guard.sig_token.connect(w.append_token)
    ctx.guard.sig_trace.connect(w.append_trace)
    ctx.guard.sig_status.connect(w.update_status)
    
    return w

# Registration
registry.register(AddonSpec(
    id="terminal",
    kind="module",
    title="TERMINAL",
    icon="⌖",
    factory=terminal_factory
))

# Launching
instance_id = host.launch_module("terminal")  # Creates new instance
```

### Signal Wiring Pattern

**Critical**: Addon factories are responsible for **all signal wiring** between:
- Addon widgets and MonoBridge (outgoing commands)
- MonoGuard and addon widgets (incoming signals)

**Why**: Keeps wiring logic co-located with addon definition, making signal flows explicit.

---

## TASK QUEUE SYSTEM

### Task Structure
```python
@dataclass
class Task:
    id: UUID              # Unique task identifier
    addon_pid: str        # Addon instance that created task
    target: str           # Engine key ("llm", "vision", etc.)
    command: str          # Command verb ("generate", "load", etc.)
    payload: dict         # Command-specific data
    priority: int         # 1=STOP, 2=normal, 3+=low priority
    status: TaskStatus    # PENDING/RUNNING/DONE/FAILED/CANCELLED
    timestamp: float      # Creation time
```

### Task Priority System
- **Priority 1**: STOP commands (preempt everything)
- **Priority 2**: Normal commands (FIFO within priority)
- **Priority 3+**: Low priority (future use)

### MonoDock Queue Behavior

**Per-engine queues**:
```python
queues: dict[str, Deque[Task]] = {
    "llm": deque([task1, task2, task3]),
    "vision": deque([task4, task5])
}
```

**Insertion logic** (`_insert_task`):
- Priority 2 tasks: Insert at end of priority-2 group (maintain FIFO within priority)
- Priority 3+ tasks: Append to end of queue
- Priority 1 tasks: Don't queue, immediately call `on_stop()`

**Execution logic** (`_try_submit`):
1. Check if engine has active task (via `MonoGuard.active_tasks`)
2. If busy, wait for `sig_engine_ready` signal
3. When ready, pop front of queue, check if cancelled
4. Submit to `MonoGuard.submit()`, which calls engine method
5. If submission fails, leave task in queue

**Cancellation**:
```python
cancelled_task_ids: set[str]   # Specific task cancellation
cancelled_addons: set[str]     # All tasks from this addon

def _is_cancelled(task: Task) -> bool:
    return (str(task.id) in cancelled_task_ids or 
            task.addon_pid in cancelled_addons)
```

### MonoGuard Task Routing

**Dispatch table**:
```python
ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}
```

**Submission flow**:
```python
def submit(self, task: Task) -> bool:
    engine = self.engines.get(task.target)
    if self.active_tasks[task.target] is not None:
        return False  # Engine busy
    
    self.active_tasks[task.target] = task
    task.status = TaskStatus.RUNNING
    
    method_name = ENGINE_DISPATCH[task.command]
    handler = getattr(engine, method_name)
    handler(task.payload)  # or handler() for no-arg commands
    return True
```

---

## BOOTSTRAP SEQUENCE

### Startup Order (bootstrap.py)
```python
1. QApplication()
2. AppState()
3. LLMEngine(state) + VisionEngine(state)
4. EngineBridge(llm) + EngineBridge(vision)
5. MonoGuard(state, engines)
6. MonoDock(guard)
7. MonoBridge(dock)
8. MonolithUI(state)
9. AddonRegistry + build_builtin_registry()
10. AddonContext(state, guard, bridge, ui, host=None)
11. AddonHost(registry, ctx)
12. ui.attach_host(host)
13. Wire global signals (guard → ui)
14. ui.show()
15. app.exec()
```

### Global Signal Wiring
```python
# System-wide status updates
guard.sig_status.connect(ui.update_status)

# Token usage tracking (LLM only)
guard.sig_usage.connect(ui.update_ctx)

# Shutdown sequence
app.aboutToQuit.connect(guard.stop)
app.aboutToQuit.connect(engine.shutdown)
app.aboutToQuit.connect(vision_engine.shutdown)
```

---

## CRITICAL PATTERNS

### Pattern 1: Generation Gating (EngineBridge)
**Problem**: After `stop_generation()`, stale tokens from cancelled generation still arrive
**Solution**: Generation ID gating
```python
# Old generation (gid=5) emits token after stop (gid=6)
lambda t, gid=5: self.sig_token.emit(t) if self._active_gid == 6 else None
# Result: Signal dropped, UI sees nothing
```

### Pattern 2: Signal Re-emission (MonoGuard)
**Problem**: Kernel must route signals without transforming them
**Solution**: Verbatim re-emit
```python
engine.sig_token.connect(self.sig_token)  # Direct passthrough
```

### Pattern 3: Factory-based Wiring (Addons)
**Problem**: Signal connections need to be explicit and traceable
**Solution**: All wiring happens in addon factory functions
```python
def terminal_factory(ctx):
    w = PageChat(ctx.state)
    # ALL WIRING HERE — visible in one place
    w.sig_generate.connect(lambda p: ctx.bridge.submit(...))
    ctx.guard.sig_token.connect(w.append_token)
    return w
```

### Pattern 4: UPDATE Semantics (Chat)
**Problem**: User types new prompt while generation is running
**Solution**: Tri-state SEND/STOP/UPDATE
```python
if not self._is_running:
    self.send()  # Normal send
elif not txt:
    self.sig_stop.emit()  # STOP button
else:
    self._pending_update_text = txt
    self._awaiting_update_restart = True
    self.sig_stop.emit()
    # On sig_engine_ready, re-submit with UPDATE prompt
```

### Pattern 5: Non-blocking Kernel (MonoGuard)
**Problem**: Kernel must never block
**Solution**: All engine calls are async via QThread
```python
# ✅ CORRECT
worker = GeneratorWorker(...)
worker.start()  # Returns immediately

# ❌ WRONG
result = model.generate(...)  # Blocks kernel!
```

### Pattern 6: Status Truth (MonoGuard)
**Problem**: UI needs reliable state
**Solution**: Kernel is single source of truth
```python
# UI must never assume:
self.send()  # ❌ Assumes execution will happen

# UI must react to signals:
def update_status(self, engine_key, status):
    if status == SystemStatus.READY:
        self.btn_send.setEnabled(True)  # ✅ React to truth
```

---

## IMPLEMENTATION DETAILS

### SystemStatus Enum
```python
class SystemStatus(Enum):
    READY = "READY"         # Engine idle, can accept commands
    LOADING = "LOADING"     # Model loading in progress
    RUNNING = "RUNNING"     # Generation in progress
    ERROR = "ERROR"         # Error occurred (auto-transitions to READY)
    UNLOADING = "UNLOADING" # Model unloading in progress
```

### TaskStatus Enum
```python
class TaskStatus(Enum):
    PENDING = "PENDING"       # Queued, not yet submitted
    RUNNING = "RUNNING"       # Submitted to engine
    DONE = "DONE"             # Completed successfully
    FAILED = "FAILED"         # Error occurred
    CANCELLED = "CANCELLED"   # Explicitly cancelled
```

### Behavior Tag System (LLM Config)
**Location**: `core/llm_config.py`

**Mechanism**: User selects tags → combined prompts injected into system message

```python
TAG_MAP = {
    "concise": "Be extremely concise. Omit pleasantries.",
    "technical": "Assume expert-level technical knowledge.",
    # ... more tags
}

# User selects ["concise", "technical"]
# → System prompt becomes:
# "You are Monolith. Be precise.\n\nBe extremely concise...\n\nAssume expert-level..."
```

### Context Injection (Injector Module)
**Location**: `ui/modules/injector.py`

**Mechanism**: Runtime context dynamically inserted into system messages before generation

```python
# In LLMEngine.generate():
if context_injection:
    self.conversation_history.insert(1, {
        "role": "system",
        "content": f"CONTEXT: {context_injection}"
    })
```

**Use case**: Add file contents, notes, or dynamic data to every generation without modifying system prompt.

### Module Strip (UI Component)
**Location**: `ui/components/module_strip.py`

**Features**:
- Horizontal scrollable icon strip
- Overflow arrows (left/right) when modules exceed width
- Module flashing on `sig_finished` (visual completion notification)
- Click to switch module, close button to remove

**Critical**: Module IDs are UUID strings, not addon IDs (allows multiple instances of same addon)

### Conversation History (LLM)
**Structure**:
```python
[
    {"role": "system", "content": "You are Monolith. Be precise."},
    {"role": "system", "content": "CONTEXT: <injector contents>"},
    {"role": "user", "content": "Hello"},
    {"role": "assistant", "content": "Hi there!"},
    {"role": "user", "content": "How are you?"},
    # ... continues
]
```

**UPDATE semantics**:
- On normal send: append user message, create pending assistant slot
- On stop: remove pending user message if generation didn't complete
- On resume: inject special user message "You were interrupted mid-generation. Continue from: {last_text}"

---

## DEBUGGING SIGNAL FLOWS

### Trace Signal Path
To trace a signal from UI → Kernel → Engine:

1. **Find the UI trigger**
   - Example: `btn_send.clicked` → `handle_send_click()`

2. **Locate the signal emission**
   - Example: `self.sig_generate.emit(txt)`

3. **Find the addon factory wiring**
   - Example: In `terminal_factory()`: `w.sig_generate.connect(lambda p: ctx.bridge.submit(...))`

4. **Trace through MonoBridge/MonoDock**
   - `bridge.submit(task)` → `dock.enqueue(task)` → `dock._try_submit()`

5. **Trace through MonoGuard**
   - `guard.submit(task)` → `engine.generate(payload)`

6. **Trace engine implementation**
   - `LLMEngine.generate()` → `worker.start()`

7. **Trace return signal path**
   - `worker.token.emit()` → `LLMEngine.sig_token` → `EngineBridge.sig_token` → `MonoGuard.sig_token` → `PageChat.append_token()`

### Trace System Status Changes
```
User clicks LOAD MODEL
  → PageChat.toggle_load()
    → sig_load.emit()
      → bridge.submit(wrap("terminal", "load", "llm"))
        → guard.submit(task)
          → engine.load_model()
            → sig_status.emit(LOADING)
              → guard.sig_status.emit("llm", LOADING)
                → ui.update_status("llm", LOADING)
                  → PageChat.update_status("llm", LOADING)
                    → btn_load.setText("LOADING...")

ModelLoader finishes
  → LLMEngine._on_load_success()
    → set_status(READY)
      → sig_status.emit(READY)
        → guard.sig_status.emit("llm", READY)
          → ui.update_status("llm", READY)
            → PageChat.update_status("llm", READY)
              → btn_load.setText("UNLOAD MODEL")
```

---

## EXTENDING MONOLITH

### Adding a New Engine

1. **Implement EnginePort protocol** (`engine/your_engine.py`)
```python
class YourEngine(QObject):
    sig_status = Signal(SystemStatus)
    sig_trace = Signal(str)
    sig_token = Signal(str)
    sig_your_output = Signal(object)  # Optional custom signal
    
    def __init__(self, state: AppState):
        self.state = state
        self._status = SystemStatus.READY
    
    def set_model_path(self, payload: dict) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...
```

2. **Wrap in EngineBridge** (`bootstrap.py`)
```python
your_engine_impl = YourEngine(state)
your_engine = EngineBridge(your_engine_impl)
```

3. **Register with MonoGuard** (`bootstrap.py`)
```python
guard = MonoGuard(state, {
    "llm": engine,
    "vision": vision_engine,
    "your": your_engine,  # Add here
})
```

4. **Wire optional signals** (`monokernel/guard.py` → `__init__`)
```python
if hasattr(engine, "sig_your_output"):
    engine.sig_your_output.connect(self.sig_your_output)
```

5. **Create addon factory** (`ui/addons/builtin.py`)
```python
def your_module_factory(ctx: AddonContext):
    w = YourModuleWidget()
    w.sig_generate.connect(
        lambda prompt: ctx.bridge.submit(
            ctx.bridge.wrap("your_module", "generate", "your", payload={...})
        )
    )
    ctx.guard.sig_your_output.connect(w.on_output)
    return w
```

6. **Register addon**
```python
registry.register(AddonSpec(
    id="your_module",
    kind="module",
    title="YOUR MODULE",
    icon="★",
    factory=your_module_factory
))
```

### Adding a New Addon

1. **Create widget** (`ui/pages/` or `ui/modules/`)
```python
class YourWidget(QWidget):
    sig_action = Signal(str)  # Define outgoing signals
    
    def __init__(self):
        super().__init__()
        # Build UI
    
    def handle_input(self, data):
        # Incoming signal handler
        pass
```

2. **Create factory** (`ui/addons/builtin.py`)
```python
def your_factory(ctx: AddonContext):
    w = YourWidget()
    
    # OUTGOING
    w.sig_action.connect(
        lambda data: ctx.bridge.submit(
            ctx.bridge.wrap("your_addon", "command", "target", payload={...})
        )
    )
    
    # INCOMING
    ctx.guard.sig_some_signal.connect(w.handle_input)
    
    return w
```

3. **Register** (`ui/addons/builtin.py` → `build_builtin_registry()`)
```python
registry.register(AddonSpec(
    id="your_addon",
    kind="module",  # or "page"
    title="YOUR ADDON",
    icon="◆",
    factory=your_factory
))
```

4. **Add launcher** (if module, add to `ui/modules/manager.py`)
```python
btn_your = SkeetButton("YOUR ADDON")
btn_your.clicked.connect(lambda: self.sig_launch_addon.emit("your_addon"))
```

---

## AGENT QUICK REFERENCE

### When implementing UI changes:
- ✅ Emit signals from widgets
- ❌ Don't call kernel/engine methods directly
- ✅ Connect signals in addon factories
- ❌ Don't assume commands will execute

### When implementing engine changes:
- ✅ Follow EnginePort protocol
- ❌ Don't emit UI-specific signals
- ✅ Use QThread for blocking operations
- ❌ Don't know about kernel rules

### When implementing kernel changes:
- ⚠️ **STOP**: Kernel contract is FROZEN (v1)
- ⚠️ Any change requires architectural review
- ✅ If you must: version bump, not patch

### When debugging signal flows:
1. Find UI emission point
2. Locate addon factory wiring
3. Trace through bridge/dock/guard
4. Find engine handler
5. Trace return path backward

### When reading code:
- Signal chains: Follow `.connect()` calls
- Task flow: Start at `MonoBridge.submit()`
- Status changes: Track `sig_status.emit()`
- Generation flow: Start at `engine.generate()`

---

## APPENDIX: FILE LOCATIONS

### Core Contracts
- `monokernel/kernel_contract.md` — Kernel rules (FROZEN)
- `monokernel/Kernel_Contract_v2.txt` — Authoritative kernel contract (v2).
- `engine/base.py` — EnginePort protocol

### Signal Routing
- `monokernel/guard.py` — MonoGuard (signal router)
- `monokernel/dock.py` — MonoDock (task queue)
- `monokernel/bridge.py` — MonoBridge (UI→Kernel API)
- `engine/bridge.py` — EngineBridge (generation gating)

### Engine Implementations
- `engine/llm.py` — LLM engine (llama-cpp-python)
- `engine/vision.py` — Vision engine (diffusers)

### Addon System
- `ui/addons/spec.py` — AddonSpec definition
- `ui/addons/registry.py` — AddonRegistry
- `ui/addons/host.py` — AddonHost (lifecycle)
- `ui/addons/context.py` — AddonContext (DI)
- `ui/addons/builtin.py` — Built-in addon factories + wiring

### UI Components
- `ui/main_window.py` — Main chrome + global signals
- `ui/pages/chat.py` — Chat/Terminal interface
- `ui/modules/sd.py` — Vision module
- `ui/modules/injector.py` — Context injector
- `ui/components/atoms.py` — Basic widgets
- `ui/components/complex.py` — Compound widgets
- `ui/components/module_strip.py` — Module icon strip

### Configuration
- `core/state.py` — AppState + SystemStatus
- `core/task.py` — Task + TaskStatus
- `core/llm_config.py` — LLM config + behavior tags
- `core/style.py` — UI styling constants

### Bootstrap
- `bootstrap.py` — Application entry point
- `main.py` — Thin wrapper around bootstrap

---

## FINAL NOTES FOR AGENTS

**This document captures implicit knowledge that would otherwise require:**
- Reading 15+ files
- Tracing signal chains across 5+ layers
- Understanding frozen contracts vs. extensible systems
- Discovering generation gating patterns
- Mapping task lifecycle through queue system

**Everything is here. No archaeology required.**

**When in doubt:**
1. Check kernel contract (FROZEN)
2. Trace signal chain (this doc)
3. Follow EnginePort protocol
4. Wire in addon factory
5. Test with VITALS pattern (sig_status transitions)

**Remember**: MonoKernel decides WHEN. Engines decide WHAT. UI reacts to truth.



================================================================================
FILE: .\.claude\worktrees\cool-mayer\README\Kernel_Contract_v2.txt
================================================================================

MONOLITH KERNEL CONTRACT — v2 (FROZEN)
0. Purpose

The Monolith kernel is a four-layer execution hierarchy:

UI → MonoBridge → MonoDock → MonoGuard → Engines

SIGNAL PASSTHROUGH LAW: Every command string in ENGINE_DISPATCH must have a matching method on EngineBridge. If guard.py dispatches to it, bridge.py must forward it. Violation = silent permanent queue deadlock. When adding any new command: update ENGINE_DISPATCH, add handler on LLMEngine, and add passthrough on EngineBridge. All three or none.
Three flows. No exceptions.

Flow	Direction	Behavior
Commands	Downward	UI → Bridge → Dock → Guard → Engine
State	Upward	Engine → Guard → UI
STOP	Instant	Bypasses queues, executes immediately

All execution-affecting functionality routes around this structure, never into it.

1. Authority Gradient

MonoGuard is the sole authority.

Only MonoGuard may:

Initiate engine execution

Interrupt engine execution

Transition engine state

Emit READY

Clear active work

MonoBridge and MonoDock are non-authoritative. They translate, organize, and route. They do not execute or decide.

2. Component Contracts
2.1 MonoBridge (Translator)

Role: Normalize UI intent into Task submission and control requests.

Interface:


def wrap(source: str, command: str, target: str, **kwargs) -> Task
def submit(task: Task) -> None                  # forwards to MonoDock.enqueue
def cancel(task_id: str) -> None                # forwards to MonoDock.cancel_task
def cancel_addon(addon_pid: str) -> None        # forwards to MonoDock.cancel_addon
def stop(target: str = "all") -> None           # forwards STOP to MonoDock.on_stop


Rules:

Creates Task with unique ID, timestamp, payload, origin metadata

Forwards Tasks to MonoDock (never directly to MonoGuard)

For cancel/stop: forwards requests to MonoDock (does not mutate queued state)

Must not:

Queue tasks

Block

Execute engines

Inspect payload semantics

Mutate MonoDock-owned task state

2.2 MonoDock (Organizer)

Role: Queue, prioritize, cancel, and submit Tasks prior to arbitration.

Interface:


def enqueue(task: Task) -> None
def cancel_task(task_id: str) -> None
def cancel_addon(addon_pid: str) -> None
def on_stop(target: str = "all") -> None


State:

queues: dict[str, deque[Task]]        # per-engine FIFO queues (priority-aware)
cancelled_task_ids: set[str]          # fast cancel filter
cancelled_addons: set[str]            # fast cancel filter (by addon_pid)


Rules:

Maintains per-target priority queues (FIFO within same priority)

Filters cancelled tasks before submission

Submits to MonoGuard via guard.submit(task) only

If guard.submit(task) returns False (engine busy): waits for guard.sig_engine_ready(engine_key) to retry

On STOP:

issues immediate stop to MonoGuard (no queue)

marks queued tasks for that target as cancelled (by id or by target sweep)

May request Guard STOP if a cancelled task is currently active (Dock-driven, not Bridge-driven)

Must not:

Execute engines

Emit state signals

Mutate MonoGuard internals

Synthesize READY

Override or delay STOP

2.3 MonoGuard (Authority)

Role: Final execution arbiter.

Interface:


def submit(task: Task) -> bool        # True if accepted, False if engine busy
def stop(target: str = "all") -> None


State:

engines: dict[str, EnginePort]            # registered engines by key
active_tasks: dict[str, Task | None]      # one active task per engine


Signals:

sig_status: Signal(str, SystemStatus)     # (engine_key, status) — authoritative
sig_engine_ready: Signal(str)             # engine_key — emitted only on truthful READY
sig_token: Signal(str)                    # passthrough from engine
sig_trace: Signal(str)                    # passthrough from engine
sig_image: Signal(object)                 # passthrough from engine (optional)
sig_finished: Signal(str, str)            # (engine_key, task_id) optional convenience


Rules:

Routes by task.target engine key

Does not validate payload semantics (engine’s job)

Re-emits engine signals verbatim

Emits sig_engine_ready(engine_key) only when that engine is truthfully READY

Enforces: one active Task per engine

On STOP(target):

interrupts target engine(s) immediately (non-blocking)

clears relevant active_tasks

emits authoritative status transitions

On engine ERROR:

emits status ERROR

clears active task

transitions back to READY (no stuck states)

Dispatch rule (non-semantic):
MonoGuard must not grow command-specific business logic. It may only perform mechanical dispatch to the target engine.

Canonical pattern:

ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}


MonoGuard performs method lookup and calls the engine; payload interpretation remains engine-specific.

Must not:

Perform business logic

Block or sleep

Inspect payload meaning

Contain UI logic

Accumulate feature-specific state

2.4 Engines (Workers)

Role: Execute work, emit results.

Rules:

Must implement EnginePort protocol

Must not know about MonoBridge, MonoDock, MonoGuard internals, or UI

Must not emit directly to UI

Must support stop_generation() as an interrupt

3. EnginePort Protocol

All engines implement this interface:

@runtime_checkable
class EnginePort(Protocol):
    # Signals
    sig_status: Signal      # SystemStatus
    sig_trace: Signal       # str
    sig_token: Signal       # str (text stream output, optional)
    sig_image: Signal       # object (image output, optional)
    sig_finished: Signal    # () optional

    # Methods
    def set_model_path(self, path: str) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...


Payload interpretation is engine-specific:

LLM reads payload["prompt"], payload["config"]

Vision reads payload["prompt"], payload["steps"], payload["seed"]

MonoGuard does not interpret payload content.

4. Task Model (Canonical)

Each command becomes exactly one Task:

@dataclass
class Task:
    id: UUID                    # unique identifier
    addon_pid: str              # source addon instance
    target: str                 # engine key ("llm", "vision", etc.)
    command: str                # "generate", "load", "unload", "set_path", "stop"
    payload: dict               # command-specific data
    priority: int               # 1=STOP, 2=normal, 3=background
    status: TaskStatus          # PENDING/RUNNING/DONE/FAILED/CANCELLED
    timestamp: float            # creation time


Priority semantics:

Priority	Name	Behavior
1	STOP	Bypasses queues, executes immediately
2	Normal	Standard FIFO
3	Background	Yields to normal priority
5. Cancellation vs STOP

Two distinct operations:

Operation	Scope	Effect
Cancel	Task or addon	Prevents queued execution; active execution may be stopped by Dock→Guard
STOP	Engine or all	Interrupts active execution immediately; clears active task; cancels queued tasks for target

Cancel flow:

UI → Bridge.cancel(task_id)
  → Dock.cancel_task(task_id)
  → Dock filters cancelled tasks on submission
  → If cancelled task is active: Dock calls Guard.stop(task.target)


STOP flow:

UI → Bridge.stop(target)
  → Dock.on_stop(target)
  → Guard.stop(target)
  → Engine.stop_generation()
  → Engine emits sig_status(READY)
  → Guard emits sig_engine_ready(target)
  → Dock submits next non-cancelled task


STOP is idempotent. Repeated calls have no additional effect.

6. Execution Model

Concurrency

Multiple engines may execute concurrently

Only one Task per engine at a time

State truth

MonoGuard is the sole source of execution state

UI subscribes to Guard signals, never Engine signals

READY means: no active task and accepting new work

Error handling

Engine errors emit sig_status(ERROR)

MonoGuard clears the active task and transitions back to READY

No stuck states

7. Stability Guarantees

Breaking any of the following requires a major contract revision:

Single ingress via MonoBridge

Single egress via MonoGuard

STOP dominance — always priority 1, always immediate

Non-blocking MonoGuard — no sleeps, no waits

Engine isolation — engines know nothing about kernel/UI

One active Task per engine

Truthful READY — emitted only when genuinely idle

8. Extension Rules

Does not belong in kernel if:

Feature can be removed without changing MonoGuard

Feature is UI-specific

Feature is engine-specific (model config, output format)

Requires new kernel version if:

MonoGuard behavior must change

New signal flow pattern required

Authority gradient modified

9. Future Compatibility

Process isolation ready:

MonoBridge may become IPC broker

Task model and authority gradient unchanged

Engines may run in separate processes

New engine registration:

Add key to guard.engines dict

Implement EnginePort

No MonoGuard logic changes required

One-Line Summary

The kernel decides when and where — never what.



================================================================================
FILE: .\.claude\worktrees\cool-mayer\README\requirement.txt
================================================================================

PySide6>=6.10.0
llama-cpp-python>=0.3.0
audiocraft>=1.3.0
torch>=2.4.0
torchaudio>=2.4.0
diffusers>=0.35.0
transformers>=4.57.0
accelerate>=1.11.0



================================================================================
FILE: .\.claude\worktrees\cool-mayer\README\LEGACY\kernel_contract_v1.md
================================================================================

MONOLITH KERNEL CONTRACT — v1 (FROZEN)
0. Purpose (Non-Negotiable)

The Monolith kernel (MonoGuard) is the sole authority between UI and execution engines.

Its role is arbitration, not computation.

All future functionality must route around the kernel, not into it.

1. Authority Rules

1.1 Single Ingress
All user-initiated commands that affect execution MUST pass through MonoGuard.

UI must not call engine methods directly.

Addons must not call engine methods directly.

1.2 Single Egress
All execution state, tokens, traces, and usage metrics MUST pass through MonoGuard.

UI must not subscribe to engine signals directly.

Engines must never emit directly to UI.

2. Kernel Scope

The kernel MAY:

Route commands

Gate execution by system state

Preempt execution via STOP

Queue at most one pending command

Re-emit engine signals verbatim

Observe system state transitions

The kernel MUST NOT:

Execute business logic

Perform blocking operations

Sleep, wait, or poll

Contain UI logic

Contain engine logic

Know what “chat”, “LLM”, or “RAG” is

Accumulate feature-specific state

3. STOP Semantics (Hard Law)

3.1 STOP Always Wins

When STOP is issued:

Current execution is interrupted immediately (non-blocking)

Any pending command is cleared

Control returns to the UI instantly

3.2 Truthful State

SystemStatus.READY MUST only be emitted when:

No execution is running

No engine work is active

No pending command is executing

The kernel must never emit READY prematurely.

4. Pending Command Rule

4.1 Single Pending Slot

The kernel may hold at most one pending command.

Pending commands exist only to resume after STOP-based preemption.

4.2 Replay on READY

A pending command may execute once when the system transitions to READY.

Pending commands are discarded if STOP is explicitly invoked.

No scheduling, prioritization, or batching exists in v1.

5. Engine Isolation

The engine:

Is execution-only

Knows nothing about UI

Knows nothing about kernel rules

Knows nothing about addons

Accepts commands and emits signals only

The kernel adapts the engine; the engine never adapts to the kernel.

6. UI Restrictions

The UI:

May emit commands freely

Must not assume commands will execute

Must not block waiting for execution

Must treat kernel signals as authoritative truth

UI correctness depends on kernel truth, not intent.

7. Stability Guarantee

Any future change that violates:

Single ingress

Single egress

STOP dominance

Non-blocking kernel behavior

breaks the kernel contract and must be treated as a major architectural change.

8. Extension Rule

If a feature:

Can be removed without breaking the kernel
→ it does not belong in the kernel.

If a feature:

Requires changing kernel behavior
→ it is a kernel version bump, not a feature patch.

9. Freeze Declaration

This kernel contract is considered frozen as of this state.

Future development must build above this boundary unless explicitly redesigning the kernel.

One-Line Summary

The kernel decides when things may happen — never what happens.



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\bridge.py
================================================================================

from PySide6.QtCore import QObject, Signal


class UIBridge(QObject):
    sig_terminal_header = Signal(str, str, str)
    sig_apply_operator = Signal(dict)
    sig_open_overseer = Signal()
    sig_overseer_viz_toggle = Signal(bool)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\main_window.py
================================================================================

from typing import Optional

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QFrame, QLabel, QStackedLayout
)
from PySide6.QtCore import Qt, QDateTime, QTimer
from PySide6.QtGui import QMouseEvent

from core.state import SystemStatus, AppState
from ui.bridge import UIBridge
from core.style import BG_MAIN, BG_SIDEBAR, FG_ACCENT, FG_ERROR, FG_WARN
from ui.addons.host import AddonHost
from ui.components.atoms import SidebarButton
from ui.components.complex import GradientLine, VitalsWindow, SplitControlBlock
from ui.components.module_strip import ModuleStrip

class MonolithUI(QMainWindow):
    def __init__(self, state: AppState, ui_bridge: UIBridge):
        super().__init__()
        self.state = state
        self.ui_bridge = ui_bridge
        self.vitals_win = None
        self._drag_pos = None
        self._chat_title = "Untitled Chat"
        self._terminal_titles: dict[str, tuple[str, str]] = {}

        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.resize(1100, 700)

        main_widget = QWidget()
        main_widget.setObjectName("MainFrame")
        main_widget.setStyleSheet(f"""
            QWidget {{ background: {BG_MAIN}; }}
            QWidget#MainFrame {{ border: 1px solid #333; }}
        """)
        self.setCentralWidget(main_widget)

        root_layout = QVBoxLayout(main_widget)
        root_layout.setContentsMargins(1,1,1,1)
        root_layout.setSpacing(0)

        # Top Gradient
        self.gradient_line = GradientLine()
        root_layout.addWidget(self.gradient_line)

        # Top Bar
        self.top_bar = self._build_top_bar()
        root_layout.addWidget(self.top_bar)

        content_layout = QHBoxLayout()
        content_layout.setSpacing(0)

        # --- SIDEBAR ---
        self.sidebar = QFrame()
        self.sidebar.setFixedWidth(70)
        self.sidebar.setStyleSheet(f"background: {BG_SIDEBAR}; border-right: 1px solid #1a1a1a;")
        
        sidebar_layout = QVBoxLayout(self.sidebar)
        sidebar_layout.setContentsMargins(5, 15, 5, 15)
        sidebar_layout.setSpacing(10)

        self.module_strip = ModuleStrip()
        self.module_strip.sig_module_selected.connect(self.switch_to_module)
        self.module_strip.sig_module_closed.connect(self.close_module)

        self.btn_hub = SidebarButton("◉", "HUB")
        self.btn_hub.clicked.connect(lambda: self.set_page("hub"))

        self.btn_addons = SidebarButton("＋", "ADDONS")
        self.btn_addons.clicked.connect(lambda: self.set_page("addons"))

        sidebar_layout.addWidget(self.module_strip)
        sidebar_layout.addStretch() 
        sidebar_layout.addWidget(self.btn_hub)
        sidebar_layout.addWidget(self.btn_addons)

        content_layout.addWidget(self.sidebar)

        # --- PAGE STACK ---
        self.stack = QStackedLayout()
        self.host: Optional[AddonHost] = None
        self.pages = {}

        self.empty_page = QWidget()
        self.stack.addWidget(self.empty_page)
        self.pages["empty"] = self.empty_page

        self.center_vbox = QVBoxLayout()
        self.center_vbox.addLayout(self.stack)
        content_layout.addLayout(self.center_vbox)

        root_layout.addLayout(content_layout)

        # --- Bottom status bar ---
        bottom_bar = QHBoxLayout()
        bottom_bar.setContentsMargins(0, 0, 8, 2)
        bottom_bar.addStretch()
        self.lbl_status = QLabel("READY")
        self.lbl_status.setStyleSheet(f"color: #555; font-size: 8px; font-weight: bold; background: transparent;")
        bottom_bar.addWidget(self.lbl_status)
        root_layout.addLayout(bottom_bar)

        # --- Time update timer ---
        self._time_timer = QTimer(self)
        self._time_timer.timeout.connect(self._update_time_display)
        self._time_timer.start(60000)

        self.ui_bridge.sig_terminal_header.connect(self.update_terminal_header)

    def attach_host(self, host: AddonHost) -> None:
        self.host = host
        hub = host.mount_page("hub")
        addons = host.mount_page("addons")

        self.stack.addWidget(hub)
        self.pages["hub"] = hub

        self.stack.addWidget(addons)
        self.pages["addons"] = addons

        self.set_page("hub")

    # ---------------- WINDOW BEHAVIOR ----------------

    def mousePressEvent(self, event: QMouseEvent):
        if event.button() == Qt.LeftButton and event.position().y() < 40:
            self._drag_pos = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
            event.accept()

    def mouseMoveEvent(self, event: QMouseEvent):
        if self._drag_pos and event.buttons() == Qt.LeftButton:
            self.move(event.globalPosition().toPoint() - self._drag_pos)
            event.accept()
            
    def mouseReleaseEvent(self, event: QMouseEvent):
        self._drag_pos = None

    # ---------------- MODULE SYSTEM ----------------

    def close_module(self, mod_id):
        current = self.stack.currentWidget()
        target_w = None
        for i in range(self.stack.count()):
            w = self.stack.widget(i)
            if getattr(w, '_mod_id', None) == mod_id:
                target_w = w
                break
        
        if target_w:
            self.stack.removeWidget(target_w)
            target_w.deleteLater()
            
        self.module_strip.remove_module(mod_id)

        if current == target_w:
            remaining = self.module_strip.get_order()
            if remaining:
                self.switch_to_module(remaining[-1])
            else:
                self.set_page("empty")

    def switch_to_module(self, mod_id):
        for i in range(self.stack.count()):
            w = self.stack.widget(i)
            if getattr(w, '_mod_id', None) == mod_id:
                self.stack.setCurrentWidget(w)
                self._update_sidebar_state(module_selection=True)
                self.module_strip.select_module(mod_id)
                self.lbl_monolith.setVisible(True)
                # Only show chat title for terminal modules
                if getattr(w, '_addon_id', None) == "terminal":
                    self.update_terminal_header(mod_id, *self._terminal_titles.get(mod_id, ("Untitled Chat", QDateTime.currentDateTime().toString("ddd • HH:mm"))))
                else:
                    self.lbl_chat_title.hide()
                    self.lbl_chat_time.hide()
                return

    def _update_sidebar_state(self, page_idx=None, module_selection=False):
        self.btn_hub.setChecked(page_idx == "hub" and not module_selection)
        self.btn_addons.setChecked(page_idx == "addons" and not module_selection)
        if not module_selection: self.module_strip.deselect_all()

    def update_status(self, engine_key: str, status: SystemStatus):
        if status == SystemStatus.ERROR:
            self.lbl_status.setStyleSheet(f"color: {FG_ERROR}; font-size: 8px; font-weight: bold; background: transparent;")
        elif status == SystemStatus.LOADING:
            self.lbl_status.setStyleSheet(f"color: {FG_WARN}; font-size: 8px; font-weight: bold; background: transparent;")
        else:
            self.lbl_status.setStyleSheet(f"color: #555; font-size: 8px; font-weight: bold; background: transparent;")
        status_text = status.value if hasattr(status, "value") else str(status)
        if not engine_key.startswith("llm"):
            status_text = f"{engine_key.upper()}: {status_text}"
        self.lbl_status.setText(status_text)

    def update_ctx(self, used):
        self.state.ctx_used = used

    def update_terminal_header(self, mod_id, title, timestamp):
        if mod_id:
            self._terminal_titles[mod_id] = (title or "Untitled Chat", timestamp or QDateTime.currentDateTime().toString("ddd • HH:mm"))

        current = self.stack.currentWidget()
        current_mod = getattr(current, "_mod_id", None) if current is not None else None
        if not current_mod:
            self.lbl_chat_title.clear()
            self.lbl_chat_time.clear()
            self.lbl_chat_title.hide()
            self.lbl_chat_time.hide()
            return

        current_title, current_time = self._terminal_titles.get(
            current_mod,
            ("Untitled Chat", QDateTime.currentDateTime().toString("ddd • HH:mm")),
        )
        if current_mod == mod_id or mod_id == "":
            self.lbl_chat_title.setText(current_title)
            self.lbl_chat_time.setText(current_time)
            self.lbl_chat_title.show()
            self.lbl_chat_time.show()

    def set_page(self, page_id):
        target = self.pages.get(page_id)
        if target:
            self.stack.setCurrentWidget(target)
        self._update_sidebar_state(page_idx=page_id)
        self.lbl_monolith.setVisible(page_id != "hub")
        self.update_terminal_header("", "", "")

    def _update_time_display(self):
        current = self.stack.currentWidget()
        current_mod = getattr(current, "_mod_id", None) if current is not None else None
        if current_mod and getattr(current, "_addon_id", None) == "terminal":
            now = QDateTime.currentDateTime().toString("ddd • HH:mm")
            self.lbl_chat_time.setText(now)
            if current_mod in self._terminal_titles:
                title = self._terminal_titles[current_mod][0]
                self._terminal_titles[current_mod] = (title, now)

    def _build_top_bar(self):
        bar = QFrame()
        bar.setFixedHeight(35)
        bar.setStyleSheet("background: #111; border-bottom: 1px solid #222;")
        layout = QHBoxLayout(bar)
        layout.setContentsMargins(10, 0, 10, 0)

        self.lbl_monolith = QLabel("MONOLITH")
        self.lbl_monolith.setStyleSheet(
            "color: #8a7340; font-size: 14px; font-weight: bold; "
            "letter-spacing: 3px; background: transparent;"
        )
        layout.addWidget(self.lbl_monolith)
        layout.addStretch()

        self.lbl_chat_title = QLabel(self._chat_title)
        self.lbl_chat_title.setStyleSheet("color: #dcdcdc; font-size: 10px; font-weight: bold;")
        self.lbl_chat_time = QLabel(QDateTime.currentDateTime().toString("ddd • HH:mm"))
        self.lbl_chat_time.setStyleSheet("color: #777; font-size: 10px;")
        title_box = QVBoxLayout()
        title_box.setContentsMargins(0, 0, 8, 0)
        title_box.setSpacing(0)
        title_box.addWidget(self.lbl_chat_title, alignment=Qt.AlignRight)
        title_box.addWidget(self.lbl_chat_time, alignment=Qt.AlignRight)
        layout.addLayout(title_box)

        self.win_controls = SplitControlBlock()
        self.win_controls.minClicked.connect(self.showMinimized)
        self.win_controls.maxClicked.connect(self.toggle_maximize)
        self.win_controls.closeClicked.connect(self.close)
        layout.addWidget(self.win_controls)

        return bar

    def toggle_maximize(self):
        self.showNormal() if self.isMaximized() else self.showMaximized()

    def toggle_vitals(self):
        if not self.vitals_win:
            self.vitals_win = VitalsWindow(self.state, self)
        
        if not self.vitals_win.isVisible():
            self.vitals_win.show()
        else:
            self.vitals_win.close()



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\overseer.py
================================================================================

from __future__ import annotations

from datetime import datetime

from PySide6.QtCore import QTimer, Qt
from PySide6.QtGui import QCloseEvent, QFont, QColor
from PySide6.QtWidgets import (
    QCheckBox,
    QHBoxLayout,
    QMainWindow,
    QPlainTextEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
    QFrame,
    QLabel,
    QHeaderView,
    QSplitter,
)

from core.overseer_db import OverseerDB
from core.style import (
    ACCENT_GOLD, FG_DIM, FG_TEXT, FG_ERROR, FG_WARN, FG_ACCENT,
    OVERSEER_BG, OVERSEER_FG, OVERSEER_DIM, OVERSEER_BORDER, BG_INPUT,
)
from monokernel.guard import MonoGuard
from ui.bridge import UIBridge

# Severity colors
_SEV_COLORS = {
    "ERROR": FG_ERROR,
    "WARNING": FG_WARN,
    "INFO": OVERSEER_FG,
    "DEBUG": FG_DIM,
    "STATUS": ACCENT_GOLD,
    "FINISHED": FG_ACCENT,
}

_FILTER_STYLE_ON = """
    QPushButton {{
        background: {bg};
        border: 1px solid {color};
        color: {color};
        padding: 4px 8px; font-size: 9px; font-weight: bold;
        border-radius: 2px;
    }}
    QPushButton:hover {{ background: #1a1a1a; }}
"""

_FILTER_STYLE_OFF = f"""
    QPushButton {{
        background: transparent;
        border: 1px solid #222;
        color: #333;
        padding: 4px 8px; font-size: 9px; font-weight: bold;
        border-radius: 2px;
    }}
    QPushButton:hover {{ color: {FG_DIM}; border: 1px solid #333; }}
"""

_RECIPE_PRESETS = {
    "ALL": {"ERROR", "WARNING", "INFO", "DEBUG", "STATUS", "FINISHED"},
    "ERRORS ONLY": {"ERROR"},
    "KERNEL": {"ERROR", "WARNING", "STATUS", "FINISHED"},
    "PERFORMANCE": {"INFO", "FINISHED"},
}


class _SeverityFilter(QPushButton):
    """Toggle button for a log severity level."""

    def __init__(self, label: str, color: str):
        super().__init__(label)
        self._label = label
        self._color = color
        self._active = True
        self.setCheckable(True)
        self.setChecked(True)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedHeight(24)
        self.clicked.connect(self._toggle)
        self._apply_style()

    def _toggle(self):
        self._active = self.isChecked()
        self._apply_style()

    def _apply_style(self):
        if self._active:
            self.setStyleSheet(
                _FILTER_STYLE_ON.format(bg=OVERSEER_BG, color=self._color)
            )
        else:
            self.setStyleSheet(_FILTER_STYLE_OFF)

    def is_active(self) -> bool:
        return self._active

    def set_active(self, val: bool):
        self._active = val
        self.setChecked(val)
        self._apply_style()


class ActiveTasksPanel(QWidget):
    def __init__(self) -> None:
        super().__init__()
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        lbl = QLabel("ACTIVE TASKS")
        lbl.setStyleSheet(
            f"color: {OVERSEER_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        layout.addWidget(lbl)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(["TASK", "ENGINE", "STATUS"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.setSelectionMode(QTableWidget.NoSelection)
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setStyleSheet(f"""
            QTableWidget {{
                background: {OVERSEER_BG};
                color: {OVERSEER_FG};
                border: 1px solid {OVERSEER_BORDER};
                gridline-color: {OVERSEER_BORDER};
                font-family: 'Consolas', monospace;
                font-size: 10px;
            }}
            QTableWidget::item {{
                padding: 4px;
                border-bottom: 1px solid {OVERSEER_BORDER};
            }}
            QHeaderView::section {{
                background: {OVERSEER_BG};
                color: {OVERSEER_DIM};
                border: none;
                border-bottom: 1px solid {OVERSEER_BORDER};
                font-size: 9px;
                font-weight: bold;
                padding: 4px;
            }}
        """)
        layout.addWidget(self.table)

    def set_tasks(self, rows: list[tuple[str, str, str]]) -> None:
        self.table.setRowCount(len(rows))
        for idx, (task_id, engine_key, status) in enumerate(rows):
            self.table.setItem(idx, 0, QTableWidgetItem(task_id))
            self.table.setItem(idx, 1, QTableWidgetItem(engine_key))
            item = QTableWidgetItem(status)
            color = _SEV_COLORS.get(status.upper(), OVERSEER_FG)
            item.setForeground(QColor(color))
            self.table.setItem(idx, 2, item)


class OverseerWindow(QMainWindow):
    def __init__(self, guard: MonoGuard, ui_bridge: UIBridge):
        super().__init__()
        self.guard = guard
        self.ui_bridge = ui_bridge
        self.db = OverseerDB()
        self._paused = False
        self._last_task_state: dict[str, tuple[str, str]] = {}
        self._severity_filters: dict[str, _SeverityFilter] = {}

        self.setWindowTitle("OVERSEER")
        self.resize(1000, 560)
        self.setStyleSheet(f"background: {OVERSEER_BG};")

        main = QWidget()
        self.setCentralWidget(main)
        main_layout = QVBoxLayout(main)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(8)

        # --- Top bar: title + recipe buttons ---
        top_bar = QHBoxLayout()
        lbl_title = QLabel("⬡ OVERSEER")
        lbl_title.setStyleSheet(
            f"color: {OVERSEER_FG}; font-size: 12px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        top_bar.addWidget(lbl_title)
        top_bar.addStretch()

        # Recipe presets
        for recipe_name in _RECIPE_PRESETS:
            btn = QPushButton(recipe_name)
            btn.setCursor(Qt.PointingHandCursor)
            btn.setFixedHeight(22)
            btn.setStyleSheet(f"""
                QPushButton {{
                    background: transparent;
                    border: 1px solid {OVERSEER_BORDER};
                    color: {OVERSEER_DIM};
                    padding: 2px 8px; font-size: 8px; font-weight: bold;
                    border-radius: 2px;
                }}
                QPushButton:hover {{
                    border: 1px solid {OVERSEER_FG};
                    color: {OVERSEER_FG};
                }}
            """)
            btn.clicked.connect(lambda _=False, r=recipe_name: self._apply_recipe(r))
            top_bar.addWidget(btn)

        main_layout.addLayout(top_bar)

        # --- Severity filter row ---
        filter_row = QHBoxLayout()
        filter_row.setSpacing(4)
        for sev, color in _SEV_COLORS.items():
            f = _SeverityFilter(sev, color)
            self._severity_filters[sev] = f
            filter_row.addWidget(f)
        filter_row.addStretch()
        main_layout.addLayout(filter_row)

        # --- Separator ---
        sep = QFrame()
        sep.setFixedHeight(1)
        sep.setStyleSheet(f"background: {OVERSEER_BORDER};")
        main_layout.addWidget(sep)

        # --- Content: tasks panel + log display ---
        content_split = QSplitter(Qt.Horizontal)
        content_split.setStyleSheet(f"""
            QSplitter::handle {{ background: {OVERSEER_BORDER}; width: 1px; }}
        """)
        content_split.setChildrenCollapsible(False)

        self.panel = ActiveTasksPanel()
        content_split.addWidget(self.panel)

        # Log display — command prompt style
        log_wrap = QWidget()
        log_layout = QVBoxLayout(log_wrap)
        log_layout.setContentsMargins(0, 0, 0, 0)
        log_layout.setSpacing(4)

        lbl_log = QLabel("EVENT LOG")
        lbl_log.setStyleSheet(
            f"color: {OVERSEER_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        log_layout.addWidget(lbl_log)

        self.log_display = QPlainTextEdit()
        self.log_display.setReadOnly(True)
        self.log_display.setFont(QFont("Consolas", 10))
        self.log_display.setStyleSheet(f"""
            QPlainTextEdit {{
                background: {OVERSEER_BG};
                color: {OVERSEER_FG};
                border: 1px solid {OVERSEER_BORDER};
                selection-background-color: #1a3a1a;
            }}
            QPlainTextEdit::viewport {{
                background: {OVERSEER_BG};
            }}
        """)
        log_layout.addWidget(self.log_display)
        content_split.addWidget(log_wrap)

        content_split.setStretchFactor(0, 1)
        content_split.setStretchFactor(1, 3)
        content_split.setSizes([250, 700])
        main_layout.addWidget(content_split, 1)

        # --- Bottom controls ---
        controls_layout = QHBoxLayout()
        controls_layout.setSpacing(8)

        ctrl_style = f"""
            QCheckBox {{
                color: {OVERSEER_DIM}; font-size: 9px; font-weight: bold;
                spacing: 4px;
            }}
            QCheckBox::indicator {{
                width: 10px; height: 10px;
                border: 1px solid {OVERSEER_DIM};
                background: {OVERSEER_BG};
                border-radius: 2px;
            }}
            QCheckBox::indicator:checked {{
                background: {OVERSEER_FG};
                border: 1px solid {OVERSEER_FG};
            }}
        """

        self.chk_pause = QCheckBox("PAUSE")
        self.chk_pause.setStyleSheet(ctrl_style)
        self.chk_pause.toggled.connect(self._on_pause_toggled)

        self.btn_clear = QPushButton("CLEAR")
        self.btn_clear.setCursor(Qt.PointingHandCursor)
        self.btn_clear.setFixedHeight(22)
        self.btn_clear.setStyleSheet(f"""
            QPushButton {{
                background: transparent;
                border: 1px solid {OVERSEER_BORDER};
                color: {OVERSEER_DIM};
                padding: 2px 10px; font-size: 9px; font-weight: bold;
                border-radius: 2px;
            }}
            QPushButton:hover {{ border: 1px solid {FG_ERROR}; color: {FG_ERROR}; }}
        """)
        self.btn_clear.clicked.connect(self.log_display.clear)

        self.chk_viz = QCheckBox("VIZTRACER")
        self.chk_viz.setStyleSheet(ctrl_style)
        self.chk_viz.toggled.connect(self.ui_bridge.sig_overseer_viz_toggle.emit)

        controls_layout.addWidget(self.chk_pause)
        controls_layout.addWidget(self.btn_clear)
        controls_layout.addWidget(self.chk_viz)
        controls_layout.addStretch()
        main_layout.addLayout(controls_layout)

        # --- Signal connections ---
        self.guard.sig_trace.connect(lambda _engine_key, msg: self._on_trace(msg))
        self.guard.sig_status.connect(self._on_status)
        self.guard.sig_finished.connect(self._on_finished)

        self._poll_timer = QTimer(self)
        self._poll_timer.setInterval(300)
        self._poll_timer.timeout.connect(self._refresh_active_tasks)
        self._poll_timer.start()

    # ---- Filtering ----

    def _is_severity_visible(self, severity: str) -> bool:
        f = self._severity_filters.get(severity.upper())
        return f.is_active() if f else True

    def _apply_recipe(self, recipe_name: str):
        active = _RECIPE_PRESETS.get(recipe_name, set())
        for sev, filt in self._severity_filters.items():
            filt.set_active(sev in active)

    # ---- Log helpers ----

    def _append_line(self, severity: str, text: str) -> None:
        if self._paused:
            return
        if not self._is_severity_visible(severity):
            return
        color = _SEV_COLORS.get(severity.upper(), OVERSEER_FG)
        self.log_display.appendHtml(
            f'<span style="color:{OVERSEER_DIM}">[{self._now_label()}]</span> '
            f'<span style="color:{color}">[{severity}]</span> '
            f'<span style="color:{OVERSEER_FG}">{text}</span>'
        )

    def _now_label(self) -> str:
        return datetime.now().strftime("%H:%M:%S")

    def _on_pause_toggled(self, checked: bool) -> None:
        self._paused = checked

    # ---- Signal handlers ----

    def _on_trace(self, msg: str) -> None:
        try:
            self.db.log_event("guard", "trace", {"message": msg})
        except RuntimeError:
            return
        self.db.log_event("guard", "trace", {"message": msg})
        sev = "INFO"
        lowered = msg.lower()
        if "error" in lowered:
            sev = "ERROR"
        elif "warn" in lowered:
            sev = "WARNING"
        self._append_line(sev, msg)

    def _on_status(self, engine_key: str, status) -> None:
        status_val = status.value if hasattr(status, "value") else str(status)
        self.db.log_event(engine_key, "status", {"status": status_val})
        self._append_line("STATUS", f"{engine_key} → {status_val}")

    def _on_finished(self, engine_key: str, task_id: str) -> None:
        self.db.log_task(str(task_id), engine_key, "DONE")
        self.db.log_event(engine_key, "finished", {"task_id": str(task_id)})
        self._append_line("FINISHED", f"{engine_key} task={task_id}")

    def _refresh_active_tasks(self) -> None:
        rows = []
        for engine_key, task in self.guard.active_tasks.items():
            if task is None:
                if engine_key in self._last_task_state:
                    prev = self._last_task_state.pop(engine_key)
                    self.db.log_task(prev[0], engine_key, "CLEARED")
                continue
            status_val = task.status.value if hasattr(task.status, "value") else str(task.status)
            current = (str(task.id), status_val)
            if self._last_task_state.get(engine_key) != current:
                self._last_task_state[engine_key] = current
                self.db.log_task(str(task.id), engine_key, status_val)
            rows.append((str(task.id), engine_key, status_val))
        self.panel.set_tasks(rows)

    def closeEvent(self, event: QCloseEvent) -> None:
        self._poll_timer.stop()
        if getattr(self.guard, "_viztracer", None) is not None:
            self.guard.enable_viztracer(False)
        self.db.close()
        super().closeEvent(event)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\addons\builtin.py
================================================================================

import uuid

from ui.addons.context import AddonContext
from ui.addons.registry import AddonRegistry
from ui.addons.spec import AddonSpec
from ui.modules.injector import InjectorWidget
from ui.modules.sd import SDModule
from ui.modules.audiogen import AudioGenModule
from ui.modules.manager import PageAddons
from ui.pages.chat import PageChat
from ui.pages.databank import PageFiles
from ui.pages.hub import PageHub
from core.operators import OperatorManager
from engine.bridge import EngineBridge
from engine.llm import LLMEngine


def terminal_factory(ctx: AddonContext):
    instance_id = str(uuid.uuid4())
    engine_key = f"llm_{instance_id}"

    short_id = instance_id[:8]

    def _trace(msg):
        ctx.guard.sig_trace.emit("system", msg)

    llm_engine = LLMEngine(ctx.state)
    engine_bridge = EngineBridge(llm_engine)
    ctx.guard.register_engine(engine_key, engine_bridge)

    w = PageChat(ctx.state, ctx.ui_bridge)
    w._mod_id = instance_id
    w._engine_key = engine_key
    ctx.ui_bridge.sig_apply_operator.connect(w.apply_operator)
    llm_engine.sig_model_capabilities.connect(w._on_model_capabilities)

    w.sig_set_model_path.connect(
        lambda path: ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "set_path", engine_key, payload={"path": path})
        )
    )
    w.sig_set_ctx_limit.connect(
        lambda limit: None if limit is None else ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "set_ctx_limit", engine_key, payload={"ctx_limit": int(limit)})
        )
    )

    if w.config.get("gguf_path"):
        w.sig_set_model_path.emit(str(w.config.get("gguf_path")))
    w.sig_set_ctx_limit.emit(int(w.config.get("ctx_limit", 8192)))

    # outgoing (addon -> bridge)
    def _on_generate(prompt, thinking_mode):
        try:
            model = w.config.get("gguf_path", "unknown")
            model_name = str(model).rsplit("/", 1)[-1].rsplit("\\", 1)[-1] if model else "none"
            think_label = "think=ON" if thinking_mode else "think=OFF"
            _trace(f"[LLM:{short_id}] generating — {think_label}, model={model_name}, prompt={repr(prompt[:50])}")
            task = ctx.bridge.wrap(
                "terminal",
                "generate",
                engine_key,
                payload={
                    "prompt": prompt,
                    "config": w.config,
                    "thinking_mode": thinking_mode,
                    "ctx_limit": int(w.config.get("ctx_limit", 8192)),
                },
            )
            ctx.bridge.submit(task)
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in generate: {e}")
            import traceback
            traceback.print_exc()

    w.sig_generate.connect(_on_generate)
    w.sig_load.connect(
        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "load", engine_key))
    )
    w.sig_unload.connect(
        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "unload", engine_key))
    )
    def _on_stop():
        try:
            _trace(f"[LLM:{short_id}] stopped — generation halted")
            ctx.bridge.stop(engine_key)
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in stop: {e}")
            import traceback
            traceback.print_exc()

    w.sig_stop.connect(_on_stop)

    def _on_sync_history(history):
        try:
            _trace(f"[LLM:{short_id}] syncing history — {len(history)} messages")
            ctx.bridge.submit(
                ctx.bridge.wrap(
                    "terminal",
                    "set_history",
                    engine_key,
                    payload={"history": history},
                )
            )
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in sync_history: {e}")
            import traceback
            traceback.print_exc()

    w.sig_sync_history.connect(_on_sync_history)
    ctx.guard.sig_status.connect(w.update_status)
    w.sig_debug.connect(lambda msg: ctx.guard.sig_trace.emit(engine_key, msg))
    # incoming (guard -> addon)
    ctx.guard.sig_token.connect(
        lambda ek, t: w.append_token(t) if ek == engine_key else None
    )
    ctx.guard.sig_trace.connect(
        lambda ek, m: w.append_trace(m) if ek == engine_key else None
    )
    ctx.guard.sig_finished.connect(w.on_guard_finished)

    def _cleanup_terminal(*_args):
        ctx.guard.unregister_engine(engine_key)
        engine_bridge.shutdown()

    w.destroyed.connect(_cleanup_terminal)
    return w


def addons_page_factory(ctx: AddonContext):
    w = PageAddons(ctx.state)
    # route launcher directly to host (host must exist)
    assert ctx.host is not None, "AddonHost must exist before addons page wiring"
    w.sig_launch_addon.connect(lambda addon_id: ctx.host.launch_module(addon_id))
    w.sig_open_vitals.connect(lambda: ctx.ui.toggle_vitals() if ctx.ui else None)
    w.sig_open_overseer.connect(ctx.ui_bridge.sig_open_overseer.emit)
    return w



def hub_factory(ctx: AddonContext):
    manager = OperatorManager()

    def _snapshot_workspace():
        """Capture full workspace state: all open modules + terminal config/messages."""
        if not ctx.ui:
            return {}

        modules = []
        module_order = []
        for mod_id in ctx.ui.module_strip.get_order():
            # Find widget by mod_id
            widget = None
            for i in range(ctx.ui.stack.count()):
                w = ctx.ui.stack.widget(i)
                if getattr(w, '_mod_id', None) == mod_id:
                    widget = w
                    break
            if not widget:
                continue

            addon_id = getattr(widget, '_addon_id', None)
            if not addon_id:
                continue

            module_order.append(addon_id)
            entry = {"addon_id": addon_id}

            # For terminals, capture config + chat messages
            if isinstance(widget, PageChat):
                entry["config"] = dict(widget.config)
                session = getattr(widget, '_current_session', None)
                if session:
                    entry["messages"] = list(session.get("messages", []))
                    entry["session_title"] = session.get("title")
                    entry["assistant_tokens"] = session.get("assistant_tokens", 0)

            modules.append(entry)

        ctx.guard.sig_trace.emit("system", f"[OPERATOR] snapshot: {len(modules)} modules")
        return {"modules": modules, "module_order": module_order}

    w = PageHub(config_provider=_snapshot_workspace, operator_manager=manager)

    def _load_operator(name: str):
        ctx.guard.sig_trace.emit("system", f"[OPERATOR] loading '{name}'")
        try:
            operator_data = manager.load_operator(name)
        except Exception as e:
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] failed to load: {e}")
            return

        if not ctx.ui or not ctx.host:
            return

        # --- New format: has "modules" list ---
        if "modules" in operator_data:
            modules = operator_data["modules"]
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] restoring {len(modules)} modules")

            # Close all existing modules
            for mod_id in list(ctx.ui.module_strip.get_order()):
                ctx.ui.close_module(mod_id)

            # Launch each module from snapshot
            first_terminal_mod_id = None
            for entry in modules:
                addon_id = entry.get("addon_id")
                if not addon_id:
                    continue
                new_mod_id = ctx.host.launch_module(addon_id)
                if not new_mod_id:
                    ctx.guard.sig_trace.emit("system", f"[OPERATOR] failed to launch {addon_id}")
                    continue

                # For terminals with saved state, apply config + messages
                if addon_id == "terminal" and "config" in entry:
                    for i in range(ctx.ui.stack.count()):
                        widget = ctx.ui.stack.widget(i)
                        if getattr(widget, '_mod_id', None) == new_mod_id and isinstance(widget, PageChat):
                            widget.apply_operator(entry)
                            break
                    if not first_terminal_mod_id:
                        first_terminal_mod_id = new_mod_id

            # Switch to first terminal
            if first_terminal_mod_id:
                ctx.ui.switch_to_module(first_terminal_mod_id)

        # --- Legacy format: top-level "config" only ---
        else:
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] legacy format for '{name}'")
            target_widget = None
            for i in range(ctx.ui.stack.count()):
                widget = ctx.ui.stack.widget(i)
                if isinstance(widget, PageChat):
                    target_widget = widget
                    break

            if not target_widget:
                ctx.host.launch_module("terminal")
                for i in range(ctx.ui.stack.count()):
                    widget = ctx.ui.stack.widget(i)
                    if isinstance(widget, PageChat):
                        target_widget = widget
                        break

            ctx.ui_bridge.sig_apply_operator.emit(operator_data)

            if target_widget:
                mod_id = getattr(target_widget, "_mod_id", None)
                if mod_id:
                    ctx.ui.switch_to_module(mod_id)

    w.sig_load_operator.connect(_load_operator)
    w.sig_save_operator.connect(lambda name, data: manager.save_operator(name, data))
    return w

def databank_factory(ctx: AddonContext):
    return PageFiles(ctx.state)


def injector_factory(ctx: AddonContext):
    assert ctx.ui is not None, "InjectorWidget requires UI parent"
    return InjectorWidget(ctx.ui)


def sd_factory(ctx: AddonContext):
    return SDModule(ctx.bridge, ctx.guard)


def audiogen_factory(ctx: AddonContext):
    return AudioGenModule()


def build_builtin_registry() -> AddonRegistry:
    registry = AddonRegistry()

    registry.register(
        AddonSpec(
            id="terminal",
            kind="module",
            title="TERMINAL",
            icon="⌖",
            factory=terminal_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="databank",
            kind="module",
            title="DATABANK",
            icon="▤",
            factory=databank_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="hub",
            kind="page",
            title="HUB",
            icon=None,
            factory=hub_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="addons",
            kind="page",
            title="ADDONS",
            icon=None,
            factory=addons_page_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="injector",
            kind="module",
            title="RUNTIME",
            icon="💉",
            factory=injector_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="sd",
            kind="module",
            title="VISION",
            icon="⟡",
            factory=sd_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="audiogen",
            kind="module",
            title="AUDIO",
            icon="♫",
            factory=audiogen_factory,
        )
    )

    return registry



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\addons\context.py
================================================================================

from dataclasses import dataclass
from typing import Optional, TYPE_CHECKING

from core.state import AppState
from monokernel.bridge import MonoBridge
from monokernel.guard import MonoGuard
from ui.bridge import UIBridge

if TYPE_CHECKING:
    from ui.addons.host import AddonHost
    from ui.main_window import MonolithUI


@dataclass
class AddonContext:
    state: AppState
    guard: MonoGuard
    bridge: MonoBridge
    ui: Optional["MonolithUI"]
    host: Optional["AddonHost"]
    ui_bridge: UIBridge



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\addons\host.py
================================================================================

import uuid
from typing import Dict, Optional

from PySide6.QtWidgets import QWidget

from ui.addons.context import AddonContext
from ui.addons.registry import AddonRegistry


class AddonHost:
    def __init__(self, registry: AddonRegistry, ctx: AddonContext):
        self.registry = registry
        self.ctx = ctx
        self.ctx.host = self
        self._pages: Dict[str, QWidget] = {}

    def mount_page(self, addon_id: str) -> QWidget:
        if addon_id in self._pages:
            return self._pages[addon_id]

        spec = self.registry.get(addon_id)
        if spec.kind != "page":
            raise ValueError(f"Addon '{addon_id}' is not a page")
        widget = spec.factory(self.ctx)
        self._pages[addon_id] = widget
        return widget

    def get_page_widget(self, addon_id: str) -> Optional[QWidget]:
        return self._pages.get(addon_id)

    def launch_module(self, addon_id: str) -> str:
        if not self.ctx.ui:
            raise RuntimeError("AddonHost requires UI for launching modules")

        try:
            spec = self.registry.get(addon_id)
            if spec.kind != "module":
                raise ValueError(f"Addon '{addon_id}' is not a module")
            instance_id = str(uuid.uuid4())
            widget = spec.factory(self.ctx)
        except Exception as e:
            self.ctx.guard.sig_trace.emit("system", f"<span style='color:red'>ADDON ERROR: {e}</span>")
            return ""

        widget._addon_id = addon_id
        if not hasattr(widget, "_mod_id"):
            widget._mod_id = instance_id
        else:
            instance_id = widget._mod_id
        added_stack = False
        added_strip = False
        try:
            self.ctx.ui.stack.addWidget(widget)
            added_stack = True
            self.ctx.ui.module_strip.add_module(instance_id, spec.icon or "?", spec.title)
            added_strip = True
        except Exception:
            if added_strip:
                self.ctx.ui.module_strip.remove_module(instance_id)
            if added_stack:
                self.ctx.ui.stack.removeWidget(widget)
            widget.deleteLater()
            return ""

        if hasattr(widget, "sig_closed"):
            widget.sig_closed.connect(lambda: self.ctx.ui.close_module(instance_id))
        if hasattr(widget, "sig_finished"):
            widget.sig_finished.connect(lambda: self.ctx.ui.module_strip.flash_module(instance_id))

        self.ctx.ui.switch_to_module(instance_id)
        return instance_id



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\addons\registry.py
================================================================================

from typing import Dict, Iterable

from ui.addons.spec import AddonSpec


class AddonRegistry:
    def __init__(self):
        self._specs: Dict[str, AddonSpec] = {}

    def register(self, spec: AddonSpec) -> None:
        self._specs[spec.id] = spec

    def get(self, addon_id: str) -> AddonSpec:
        if addon_id not in self._specs:
            raise KeyError(f"Addon '{addon_id}' not found. Known addons: {list(self._specs.keys())}")
        return self._specs[addon_id]

    def all(self) -> Iterable[AddonSpec]:
        return self._specs.values()



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\addons\spec.py
================================================================================

from dataclasses import dataclass
from typing import Callable, Literal

from PySide6.QtWidgets import QWidget

from ui.addons.context import AddonContext

AddonKind = Literal["page", "module"]


@dataclass(frozen=True)
class AddonSpec:
    id: str
    kind: AddonKind
    title: str
    icon: str | None
    factory: Callable[[AddonContext], QWidget]



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\addons\__init__.py
================================================================================




================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\addons\configs\llm_config.json
================================================================================

{
  "gguf_path": null,
  "temp": 0.7,
  "top_p": 0.9,
  "max_tokens": 2048,
  "ctx_limit": 8192,
  "system_prompt": "You are Monolith. Be precise.",
  "context_injection": ""
}



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\components\atoms.py
================================================================================

from PySide6.QtWidgets import (
    QWidget, QFrame, QLabel, QSlider, QHBoxLayout, 
    QPushButton, QScrollArea, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QPropertyAnimation, QEasingCurve
from PySide6.QtGui import QDragEnterEvent

from core.style import BG_GROUP, BORDER_DARK, FG_TEXT, FG_DIM, FG_ACCENT, ACCENT_GOLD

# ======================
# HELPER
# ======================
def import_vbox(widget, l=15, t=25, r=15, b=15):
    from PySide6.QtWidgets import QVBoxLayout
    v = QVBoxLayout(widget)
    v.setContentsMargins(l, t, r, b)
    v.setSpacing(10)
    return v

# ======================
# BASIC UI PRIMITIVES
# ======================

class SkeetGroupBox(QFrame):
    def __init__(self, title, parent=None):
        super().__init__(parent)
        self.setStyleSheet(f"""
            SkeetGroupBox {{
                background: {BG_GROUP};
                border: 1px solid {BORDER_DARK};
                margin-top: 10px; 
            }}
        """)
        self.layout_main = import_vbox(self)
        self.lbl_title = QLabel(title, self)
        self.lbl_title.setStyleSheet(f"""
            color: {FG_TEXT}; 
            font-weight: bold; font-size: 11px;
            background: {BG_GROUP}; padding: 0 4px;
        """)
        self.lbl_title.adjustSize()
        self.lbl_title.move(10, -3)

    def add_widget(self, widget):
        self.layout_main.addWidget(widget)

    def add_layout(self, layout):
        self.layout_main.addLayout(layout)

class SkeetButton(QPushButton):
    def __init__(self, text, accent=False):
        super().__init__(text)
        self.setCursor(Qt.PointingHandCursor)
        col = FG_ACCENT if accent else FG_TEXT
        self.setStyleSheet(f"""
            QPushButton {{ background: #181818; border: 1px solid #333; color: {FG_DIM}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
            QPushButton:hover {{ background: #222; color: {col}; border: 1px solid {col}; }}
            QPushButton:checked {{ background: #222; color: {col}; border: 1px solid {col}; }}
            QPushButton:pressed {{ background: #111; color: {col}; border: 1px solid {col}; }}
            QPushButton:disabled {{ background: #111; color: #333; border: 1px solid #222; }}
        """)

class SkeetTriangleButton(QPushButton):
    def __init__(self, text):
        super().__init__(text)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(18, 18)
        self.setFocusPolicy(Qt.NoFocus)
        self.setStyleSheet(f"""
            QPushButton {{
                background: #181818; border: 1px solid #333; color: {FG_TEXT};
                padding: 0; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:hover {{ background: #222; color: {ACCENT_GOLD}; border: 1px solid {ACCENT_GOLD}; }}
            QPushButton:disabled {{ background: #111; color: #333; border: 1px solid #222; }}
        """)

class SkeetSlider(QWidget):
    valueChanged = Signal(float)
    def __init__(self, label, min_v, max_v, init_v, is_int=False):
        super().__init__()
        self.is_int = is_int
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        self.lbl = QLabel(label)
        self.lbl.setStyleSheet(f"color: {FG_DIM}; font-size: 11px;")
        val_str = str(int(init_v) if is_int else f"{init_v:.2f}")
        self.val_lbl = QLabel(val_str)
        self.val_lbl.setStyleSheet(f"color: {FG_TEXT}; font-size: 11px; font-weight: bold;")
        self.val_lbl.setFixedWidth(40)
        self.val_lbl.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.slider = QSlider(Qt.Horizontal)
        if is_int:
            self.slider.setRange(int(min_v), int(max_v))
            self.slider.setValue(int(init_v))
        else:
            self.slider.setRange(int(min_v*100), int(max_v*100))
            self.slider.setValue(int(init_v*100))
        self.slider.setStyleSheet(f"""
            QSlider::groove:horizontal {{ height: 4px; background: #222; border-radius: 2px; }}
            QSlider::handle:horizontal {{ background: {ACCENT_GOLD}; width: 8px; margin: -2px 0; border-radius: 4px; }}
            QSlider::handle:horizontal:hover {{ background: {ACCENT_GOLD}; }}
            QSlider::sub-page:horizontal {{ background: #ffffff; border-radius: 2px; }}
        """)
        self.slider.valueChanged.connect(self._on_change)
        layout.addWidget(self.lbl)
        layout.addWidget(self.slider)
        layout.addWidget(self.val_lbl)
    def _on_change(self, val):
        real_val = val if self.is_int else val / 100.0
        val_str = str(int(real_val) if self.is_int else f"{real_val:.2f}")
        self.val_lbl.setText(val_str)
        self.valueChanged.emit(float(real_val))

class SidebarButton(QPushButton):
    def __init__(self, icon_char, text, checkable=True):
        super().__init__()
        self.setCheckable(checkable)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(60, 45) # Shorter height
        if checkable: self.setAutoExclusive(False)
        self.setAcceptDrops(True) 
        
        # Text Only Layout (Skeet Style)
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        
        self.lbl_text = QLabel(text)
        self.lbl_text.setAlignment(Qt.AlignCenter)
        self.lbl_text.setStyleSheet(f"color: {FG_DIM}; font-size: 9px; font-weight: bold;")
        
        layout.addWidget(self.lbl_text)
        self.update_style(False)

    def nextCheckState(self): pass 

    def setChecked(self, checked):
        super().setChecked(checked)
        self.update_style(checked)

    def update_style(self, checked):
        color = ACCENT_GOLD if checked else FG_DIM
        bg = "#1a1a1a" if checked else "transparent"
        # Pure text style, no icon char
        self.lbl_text.setStyleSheet(f"color: {color}; background: transparent; font-size: 10px; font-weight: bold;")
        # Add a left border indicator for active state
        border = f"border-left: 2px solid {ACCENT_GOLD};" if checked else "border: none;"
        self.setStyleSheet(f"background: {bg}; {border}")

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasUrls(): event.accept()
        else: event.ignore()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls(): event.accept()

class CollapsibleSection(QWidget):
    def __init__(self, title="", parent=None):
        super().__init__(parent)
        self.layout_main = import_vbox(self, 0, 0, 0, 0)
        self.layout_main.setSpacing(0)
        self.btn_toggle = QPushButton(title)
        self.btn_toggle.setCheckable(True)
        self.btn_toggle.setChecked(False)
        self.btn_toggle.setStyleSheet(f"""
            QPushButton {{
                color: {FG_DIM}; background: transparent; 
                border: none; text-align: left; font-weight: bold; font-size: 10px;
            }}
            QPushButton:checked {{ color: {ACCENT_GOLD}; }}
            QPushButton:hover {{ color: {FG_TEXT}; }}
        """)
        self.btn_toggle.clicked.connect(self.toggle_animation)
        self.layout_main.addWidget(self.btn_toggle)
        self.content_area = QScrollArea()
        self.content_area.setMaximumHeight(0) 
        self.content_area.setMinimumHeight(0)
        self.content_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.content_area.setFrameShape(QFrame.NoFrame)
        self.content_area.setWidgetResizable(True)
        self.content_area.setStyleSheet("background: transparent;")
        self.layout_main.addWidget(self.content_area)
        self.anim = QPropertyAnimation(self.content_area, b"maximumHeight")
        self.anim.setDuration(300)
        self.anim.setEasingCurve(QEasingCurve.InOutQuad)

    def set_content_layout(self, layout):
        w = QWidget()
        w.setLayout(layout)
        self.content_area.setWidget(w)

    def toggle_animation(self):
        checked = self.btn_toggle.isChecked()
        content_height = self.content_area.widget().layout().sizeHint().height() if self.content_area.widget() else 100
        self.anim.setStartValue(0 if checked else content_height)
        self.anim.setEndValue(content_height if checked else 0)
        self.anim.start()



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\components\complex.py
================================================================================

import math
import re
from PySide6.QtWidgets import (
    QWidget, QFrame, QLabel, QDialog, QHBoxLayout, QVBoxLayout,
    QPushButton, QProgressBar, QGridLayout, QLineEdit
)
from PySide6.QtCore import Qt, QTimer, Signal, QRectF
from PySide6.QtGui import (
    QPainter, QPen, QColor, QLinearGradient, QFont, QPainterPath, QFontMetrics
)

from core.style import ACCENT_GOLD, FG_DIM, FG_TEXT, FG_ACCENT, FG_ERROR, BG_INPUT, BORDER_DARK

# ======================
# FLAME LABEL (FIXED)
# ======================
class FlameLabel(QWidget):
    def __init__(self, text, parent=None):
        super().__init__(parent)
        self._text = text
        self.phase = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._animate)
        self.timer.start(50)
        # Use a thick, bold font for the mask to work well
        self.font_obj = QFont("Segoe UI", 14, QFont.Bold)
        self.setFixedHeight(30)
        self.setFixedWidth(120) 

    def _animate(self):
        # Move the gradient phase
        self.phase -= 0.08
        if self.phase < -1.0: self.phase = 1.0
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 1. Setup Gradient (Fire Effect)
        # The gradient moves vertically based on self.phase
        h = self.height()
        grad = QLinearGradient(0, h + (h * self.phase), 0, -h + (h * self.phase))
        grad.setSpread(QLinearGradient.RepeatSpread)
        
        # Fire Colors: Dark Grey -> Gold -> White -> Dark Grey
        grad.setColorAt(0.0, QColor("#333"))
        grad.setColorAt(0.4, QColor(ACCENT_GOLD))
        grad.setColorAt(0.5, QColor("white"))
        grad.setColorAt(0.6, QColor(ACCENT_GOLD))
        grad.setColorAt(1.0, QColor("#333"))

        # 2. Create Text Path
        # We convert text to a shape so we can fill it with the gradient
        path = QPainterPath()
        # Center the text vertically
        fm = QFontMetrics(self.font_obj)
        text_w = fm.horizontalAdvance(self._text)
        text_h = fm.ascent()
        x = (self.width() - text_w) / 2
        y = (self.height() + text_h) / 2 - fm.descent()
        
        path.addText(x, y, self.font_obj, self._text)

        # 3. Draw
        painter.setBrush(grad)
        painter.setPen(Qt.NoPen)
        painter.drawPath(path)

# ======================
# VITALS WINDOW (COMPACT)
# ======================
class VitalsWindow(QDialog):
    def __init__(self, state, parent=None):
        super().__init__(parent)
        self.state = state
        self.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        layout = QVBoxLayout(self)
        layout.setSpacing(0)
        layout.setContentsMargins(0,0,0,0)
        
        self.frame = QFrame()
        # Glassmorphic + Ultra Compact
        self.frame.setStyleSheet(f"background: rgba(8, 8, 8, 230); border: 1px solid {ACCENT_GOLD}; border-radius: 4px;")
        
        frame_layout = QVBoxLayout(self.frame)
        frame_layout.setSpacing(2) 
        frame_layout.setContentsMargins(6, 6, 6, 6)
        
        # Header
        head = QHBoxLayout()
        lbl = QLabel("SYSTEM VITALS")
        lbl.setStyleSheet(f"color: {ACCENT_GOLD}; font-weight: 900; font-size: 9px; border:none; background: transparent;")
        btn_x = QPushButton("×")
        btn_x.setFixedSize(14, 14)
        btn_x.clicked.connect(self.close)
        btn_x.setStyleSheet("color: #666; border: none; font-weight: bold; background: transparent; padding:0; margin:0;")
        head.addWidget(lbl)
        head.addStretch()
        head.addWidget(btn_x)
        frame_layout.addLayout(head)
        
        # Bars
        self.bars = {}
        for key in ["VRAM", "CTX", "CPU", "GPU"]:
            row = QHBoxLayout()
            row.setSpacing(4)
            l = QLabel(key)
            l.setStyleSheet("color: #888; font-size: 8px; font-weight: bold; border:none; background: transparent;")
            l.setFixedWidth(22)
            
            bar = QProgressBar()
            bar.setFixedHeight(2) # Ultra thin
            bar.setTextVisible(False)
            bar.setStyleSheet(f"""
                QProgressBar {{ background: #222; border: none; border-radius: 1px; }}
                QProgressBar::chunk {{ background: {FG_ACCENT}; border-radius: 1px; }}
            """)
            bar.setValue(0)
            self.bars[key] = bar
            
            row.addWidget(l)
            row.addWidget(bar)
            frame_layout.addLayout(row)
            
        layout.addWidget(self.frame)
        
        # Make the window itself small
        self.setFixedSize(140, 90)

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_stats)
        self.timer.start(1000)
        self.old_pos = None

    def update_stats(self):
        if self.state.ctx_limit > 0:
            ctx_p = int((self.state.ctx_used / self.state.ctx_limit) * 100)
            self.bars["CTX"].setValue(ctx_p)
        import random
        base_load = 10 if not self.state.model_loaded else 40
        self.bars["VRAM"].setValue(base_load + random.randint(0, 5))
        self.bars["CPU"].setValue(random.randint(5, 15))
        self.bars["GPU"].setValue(base_load + random.randint(0, 10))
        
    def mousePressEvent(self, e): self.old_pos = e.globalPosition().toPoint()
    def mouseReleaseEvent(self, e): self.old_pos = None
    def mouseMoveEvent(self, e):
        if self.old_pos:
            delta = e.globalPosition().toPoint() - self.old_pos
            self.move(self.pos() + delta)
            self.old_pos = e.globalPosition().toPoint()

# ======================
# MODE SELECTOR (GOLD)
# ======================
class ModeSelector(QWidget):
    modeChanged = Signal(str) # "OPERATOR" or "OVERSEER"

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedHeight(60)
        
        layout = QHBoxLayout(self)
        layout.setSpacing(20)
        layout.setContentsMargins(20, 5, 20, 5)
        
        self.btn_op = self._make_box("OPERATOR", True)
        self.btn_ov = self._make_box("OVERSEER", False)
        
        layout.addStretch()
        layout.addWidget(self.btn_op)
        layout.addWidget(self.btn_ov)
        layout.addStretch()

    def _make_box(self, title, active):
        btn = QPushButton(title)
        btn.setFixedSize(120, 35)
        btn.setCheckable(True)
        btn.setChecked(active)
        btn.setCursor(Qt.PointingHandCursor)
        self._style_btn(btn, active)
        btn.clicked.connect(lambda: self._select(title))
        return btn

    def _style_btn(self, btn, active):
        # GOLD highlight when active
        border = ACCENT_GOLD if active else "#333"
        bg = "#1a1a1a" if active else BG_INPUT
        color = ACCENT_GOLD if active else FG_DIM
        weight = "bold" if active else "normal"
        
        btn.setStyleSheet(f"""
            QPushButton {{
                background: {bg}; 
                border: 1px solid {border}; 
                color: {color};
                font-family: 'Segoe UI'; font-size: 10px; font-weight: {weight};
                border-radius: 2px;
            }}
            QPushButton:hover {{ border-color: {ACCENT_GOLD}; color: {FG_TEXT}; }}
        """)

    def _select(self, mode):
        is_op = (mode == "OPERATOR")
        self.btn_op.setChecked(is_op)
        self.btn_ov.setChecked(not is_op)
        
        self._style_btn(self.btn_op, is_op)
        self._style_btn(self.btn_ov, not is_op)
        
        self.modeChanged.emit(mode)

class GradientLine(QFrame):
    def __init__(self):
        super().__init__()
        self.setFixedHeight(2)
        self.offset = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._step)
        self.timer.start(33) 

    def _step(self):
        self.offset = (self.offset + 0.015) % 1.0
        self.repaint()
    
    def paintEvent(self, event):
        painter = QPainter(self)
        grad = QLinearGradient(0, 0, self.width(), 0)
        c_gold = QColor(ACCENT_GOLD)
        c_dark = QColor("#111111")
        grad.setSpread(QLinearGradient.RepeatSpread)
        w = self.width()
        start_x = -self.offset * w
        grad.setStart(start_x, 0)
        grad.setFinalStop(start_x + w, 0)
        grad.setColorAt(0.0, c_dark)
        grad.setColorAt(0.5, c_gold)
        grad.setColorAt(1.0, c_dark)
        painter.fillRect(self.rect(), grad)


class TagLineEdit(QLineEdit):
    backspaceOnEmpty = Signal()

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Backspace and not self.text():
            self.backspaceOnEmpty.emit()
            return
        super().keyPressEvent(event)


class BehaviorTagInput(QFrame):
    tagsChanged = Signal(list)

    def __init__(self, known_tags=None, parent=None):
        super().__init__(parent)
        self._known_tags = {tag.lower() for tag in (known_tags or [])}
        self._tags = []

        self.setStyleSheet(
            f"background: {BG_INPUT}; border: 1px solid #333; border-radius: 2px;"
        )
        layout = QHBoxLayout(self)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(6)

        self._chip_layout = QHBoxLayout()
        self._chip_layout.setContentsMargins(0, 0, 0, 0)
        self._chip_layout.setSpacing(6)
        layout.addLayout(self._chip_layout)

        self._input = TagLineEdit()
        self._input.setPlaceholderText("Type tags...")
        self._input.setStyleSheet(f"background: transparent; color: {FG_TEXT}; border: none;")
        self._input.textEdited.connect(self._on_text_edited)
        self._input.returnPressed.connect(self._commit_current_text)
        self._input.backspaceOnEmpty.connect(self._remove_last_tag)
        layout.addWidget(self._input, stretch=1)

    def set_tags(self, tags):
        self._clear_tags()
        for tag in tags:
            self._add_tag(tag, emit_signal=False)
        self.tagsChanged.emit(self._tags.copy())

    def tags(self):
        return self._tags.copy()

    def _clear_tags(self):
        while self._chip_layout.count():
            item = self._chip_layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()
        self._tags = []

    def _normalize_tag(self, tag):
        return tag.strip().lower()

    def _add_tag(self, tag, emit_signal=True):
        normalized = self._normalize_tag(tag)
        if not normalized:
            return
        if normalized in self._tags:
            return
        chip = QPushButton(normalized)
        chip.setCursor(Qt.PointingHandCursor)
        chip.setStyleSheet(
            f"""
            QPushButton {{
                background: #1a1a1a; border: 1px solid #333; color: {FG_TEXT};
                padding: 2px 6px; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:hover {{ color: {ACCENT_GOLD}; border: 1px solid {ACCENT_GOLD}; }}
            """
        )
        chip.clicked.connect(lambda _, t=normalized: self._remove_tag(t))
        self._chip_layout.addWidget(chip)
        self._tags.append(normalized)
        if emit_signal:
            self.tagsChanged.emit(self._tags.copy())

    def _remove_tag(self, tag):
        if tag not in self._tags:
            return
        self._tags = [t for t in self._tags if t != tag]
        for index in range(self._chip_layout.count() - 1, -1, -1):
            widget = self._chip_layout.itemAt(index).widget()
            if widget and widget.text() == tag:
                self._chip_layout.takeAt(index)
                widget.deleteLater()
                break
        self.tagsChanged.emit(self._tags.copy())

    def _remove_last_tag(self):
        if not self._tags:
            return
        self._remove_tag(self._tags[-1])

    def _commit_current_text(self):
        text = self._input.text()
        if text:
            self._add_tag(text)
        self._input.clear()

    def _on_text_edited(self, text):
        if not text:
            return
        if "," not in text and " " not in text:
            return
        parts = [part for part in re.split(r"[,\s]+", text) if part]
        trailing = ""
        if text and text[-1] not in {",", " "}:
            trailing = parts.pop() if parts else text
        for part in parts:
            self._add_tag(part)
        self._input.blockSignals(True)
        self._input.setText(trailing)
        self._input.blockSignals(False)

class SplitControlBlock(QWidget):
    minClicked = Signal()
    maxClicked = Signal()
    closeClicked = Signal()

    def __init__(self):
        super().__init__()
        self.setFixedSize(45, 34)
        layout = QGridLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(1)
        base_style = f"""
            QPushButton {{
                background: #1a1a1a; border: none; color: {FG_DIM};
                font-family: 'Segoe UI'; font-size: 8px;
            }}
            QPushButton:hover {{ background: {ACCENT_GOLD}; color: black; }}
            QPushButton:pressed {{ background: #b08d2b; color: black; }}
        """
        self.btn_min = QPushButton("─")
        self.btn_min.setFixedSize(22, 16) 
        self.btn_min.setStyleSheet(base_style)
        self.btn_min.clicked.connect(self.minClicked)
        
        self.btn_max = QPushButton("□")
        self.btn_max.setFixedSize(22, 16)
        self.btn_max.setStyleSheet(base_style)
        self.btn_max.clicked.connect(self.maxClicked)
        
        self.btn_close = QPushButton("×")
        self.btn_close.setFixedHeight(16)
        self.btn_close.setStyleSheet(f"""
            QPushButton {{
                background: #1a1a1a; border: none; color: {FG_DIM};
                font-family: 'Segoe UI'; font-size: 12px;
            }}
            QPushButton:hover {{ background: {FG_ERROR}; color: white; }}
            QPushButton:pressed {{ background: #a00; color: white; }}
        """)
        self.btn_close.clicked.connect(self.closeClicked)
        layout.addWidget(self.btn_min, 0, 0)
        layout.addWidget(self.btn_max, 0, 1)
        layout.addWidget(self.btn_close, 1, 0, 1, 2)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\components\message_widget.py
================================================================================

from PySide6.QtCore import Qt, QSize, Signal
from PySide6.QtWidgets import QHBoxLayout, QLabel, QPushButton, QSizePolicy, QVBoxLayout, QWidget

from core.style import ACCENT_GOLD, FG_DIM, FG_TEXT, BORDER_DARK


class _IconAction(QPushButton):
    """Tiny icon-only action button for message hover bar."""

    def __init__(self, icon_char: str, tooltip: str):
        super().__init__(icon_char)
        self.setToolTip(tooltip)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(22, 22)
        self.setStyleSheet(f"""
            QPushButton {{
                background: transparent;
                color: {FG_DIM};
                border: none;
                font-size: 12px;
                padding: 0;
            }}
            QPushButton:hover {{
                color: {ACCENT_GOLD};
            }}
        """)


class MessageWidget(QWidget):
    sig_delete = Signal(int)
    sig_edit = Signal(int)
    sig_regen = Signal(int)

    def __init__(self, index: int, role: str, text: str, timestamp: str):
        super().__init__()
        self._index = index
        self._role = role
        self._content = text or ""

        self.setAttribute(Qt.WA_Hover, True)
        self.setAttribute(Qt.WA_StyledBackground, True)

        is_assistant = role == "assistant"
        is_system = role == "system"
        border_color = ACCENT_GOLD if is_assistant else "#1a1a1a"
        if is_system:
            border_color = "#222"
        bottom_border = "1px solid #1a1a1a" if is_assistant else "none"

        self.setStyleSheet(f"""
            MessageWidget {{
                background: transparent;
                border-left: 2px solid {border_color};
                border-top: none; border-right: none;
                border-bottom: {bottom_border};
            }}
        """)

        root = QVBoxLayout(self)
        root.setContentsMargins(10, 3, 10, 3 if not is_assistant else 8)
        root.setSpacing(4)

        # --- Header row ---
        head = QHBoxLayout()
        head.setSpacing(6)

        role_color = ACCENT_GOLD if is_assistant else FG_TEXT
        if is_system:
            role_color = FG_DIM
        self.lbl_role = QLabel((role or "").upper())
        self.lbl_role.setStyleSheet(
            f"color: {role_color}; font-size: 9px; font-weight: bold; letter-spacing: 1px;"
        )
        head.addWidget(self.lbl_role)

        pretty_ts = (timestamp or "")
        if "T" in pretty_ts and len(pretty_ts) >= 16:
            pretty_ts = pretty_ts[11:16]
        self.lbl_time = QLabel(pretty_ts)
        self.lbl_time.setStyleSheet(f"color: #444; font-size: 9px;")
        head.addWidget(self.lbl_time)
        head.addStretch()

        # --- Hover action icons ---
        self.actions = QWidget()
        self.actions.setStyleSheet("background: transparent;")
        actions_layout = QHBoxLayout(self.actions)
        actions_layout.setContentsMargins(0, 0, 0, 0)
        actions_layout.setSpacing(2)

        if not is_system:
            if role == "user":
                self.btn_edit = _IconAction("✎", "Edit")
                self.btn_edit.clicked.connect(lambda: self.sig_edit.emit(self._index))
                actions_layout.addWidget(self.btn_edit)

            if is_assistant:
                self.btn_regen = _IconAction("⟲", "Regenerate")
                self.btn_regen.clicked.connect(lambda: self.sig_regen.emit(self._index))
                actions_layout.addWidget(self.btn_regen)

            self.btn_delete = _IconAction("✕", "Delete")
            self.btn_delete.clicked.connect(lambda: self.sig_delete.emit(self._index))
            actions_layout.addWidget(self.btn_delete)

        self.actions.setVisible(False)
        head.addWidget(self.actions)

        root.addLayout(head)

        # --- Content ---
        self.lbl_content = QLabel()
        self.lbl_content.setTextFormat(Qt.PlainText)
        self.lbl_content.setWordWrap(True)
        self.lbl_content.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
        self.lbl_content.setCursor(Qt.IBeamCursor)
        content_color = FG_TEXT if is_assistant else "#bbb"
        if is_system:
            content_color = FG_DIM
        self.lbl_content.setStyleSheet(
            f"color: {content_color}; font-size: 11px; line-height: 1.4; padding: 2px 0;"
        )
        self.lbl_content.setText(self._content)
        root.addWidget(self.lbl_content)

        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Minimum)

    # ------------------------------------------------------------------
    def sizeHint(self):
        """Compute height that accounts for word-wrapped content label."""
        w = self.width() if self.width() > 50 else 600
        margins = self.layout().contentsMargins()
        content_w = w - margins.left() - margins.right() - 2  # 2px border-left
        # heightForWidth respects word-wrap and font metrics
        content_h = self.lbl_content.heightForWidth(max(content_w, 60))
        if content_h <= 0:
            content_h = self.lbl_content.sizeHint().height()
        header_h = 20  # role label row
        spacing = self.layout().spacing()  # 4
        total = margins.top() + header_h + spacing + content_h + margins.bottom()
        return QSize(w, max(total, 30))

    def enterEvent(self, event):
        self.actions.setVisible(True)
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.actions.setVisible(False)
        super().leaveEvent(event)

    def append_token(self, token: str):
        if not token:
            return
        self._content += token
        self.lbl_content.setText(self._content)

    def finalize(self):
        self.lbl_content.setText(self._content)

    def set_index(self, idx: int):
        self._index = idx



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\components\module_strip.py
================================================================================

import math
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QScrollArea, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QTimer, QPoint, QEvent, QMimeData
from PySide6.QtGui import QPainter, QColor, QPen, QPolygonF, QDrag

from core.style import ACCENT_GOLD
from .atoms import SidebarButton

class OverflowArrow(QWidget):
    clicked = Signal()
    def __init__(self):
        super().__init__()
        self.setFixedHeight(15)
        self.setCursor(Qt.PointingHandCursor)
        self.phase = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._anim)
        self.timer.start(50)
        
    def _anim(self):
        self.phase += 0.2
        self.update()
        
    def mousePressEvent(self, e): self.clicked.emit()
        
    def paintEvent(self, e):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)
        y_off = math.sin(self.phase) * 2
        c = QColor(ACCENT_GOLD)
        c.setAlpha(150)
        p.setPen(QPen(c, 1.5))
        p.setBrush(Qt.NoBrush)
        cx = self.width() / 2
        cy = self.height() / 2 + y_off
        path = QPolygonF([QPoint(cx - 4, cy - 2), QPoint(cx, cy + 3), QPoint(cx + 4, cy - 2)])
        p.drawPolyline(path)

class ModuleIcon(SidebarButton):
    sig_close = Signal(str)
    sig_select = Signal(str)

    def __init__(self, mod_id, icon_char, label_text):
        super().__init__(icon_char, label_text, checkable=True)
        self.mod_id = mod_id
        self.code = icon_char
        self.is_pulsing = False
        
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(lambda: self.sig_close.emit(self.mod_id))
        
        self.pulse_phase = 0.0
        self._drag_start_pos = None

    def mousePressEvent(self, e):
        if e.button() == Qt.MiddleButton: self.sig_close.emit(self.mod_id)
        elif e.button() == Qt.LeftButton:
            self._drag_start_pos = e.position().toPoint()
            self.sig_select.emit(self.mod_id)

    def mouseMoveEvent(self, e):
        if not (e.buttons() & Qt.LeftButton) or self._drag_start_pos is None:
            return
        if (e.position().toPoint() - self._drag_start_pos).manhattanLength() < QApplication.startDragDistance():
            return
        drag = QDrag(self)
        mime = QMimeData()
        mime.setData("application/x-monolith-module", self.mod_id.encode())
        drag.setMimeData(mime)
        drag.exec(Qt.MoveAction)

    def set_active(self, val):
        self.setChecked(val)
        if val: self.is_pulsing = False

    def flash(self):
        if not self.isChecked():
            self.is_pulsing = True
            self.pulse_phase = 0.0
            self.update()
            QTimer.singleShot(250, lambda: self.set_pulsing(False))

    def set_pulsing(self, val):
        self.is_pulsing = val
        if val: self.pulse_phase = 0.0
        self.update()

    def paintEvent(self, e):
        super().paintEvent(e)
        if self.is_pulsing and not self.isChecked():
            p = QPainter(self)
            p.setRenderHint(QPainter.Antialiasing)
            glow = QColor(ACCENT_GOLD)
            alpha = int(((math.sin(self.pulse_phase) + 1) / 2) * 50)
            glow.setAlpha(alpha)
            p.fillRect(self.rect(), glow)

class ModuleStrip(QWidget):
    sig_module_selected = Signal(str)
    sig_module_closed = Signal(str)

    def __init__(self):
        super().__init__()
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(0)
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setStyleSheet("background: transparent; border: none;")
        self.content = QWidget()
        self.vbox = QVBoxLayout(self.content)
        self.vbox.setContentsMargins(5, 5, 5, 5)
        self.vbox.setSpacing(5)
        self.vbox.addStretch()
        self.scroll.setWidget(self.content)
        layout.addWidget(self.scroll)
        self.arrow = OverflowArrow()
        self.arrow.clicked.connect(self.scroll_down)
        self.arrow.setVisible(False)
        layout.addWidget(self.arrow)
        self.modules = {}
        self.order = []
        self.content.setAcceptDrops(True)
        self.content.installEventFilter(self)

    def add_module(self, mod_id, icon_char, label_text):
        icon = ModuleIcon(mod_id, icon_char, label_text)
        icon.sig_select.connect(self.sig_module_selected)
        icon.sig_close.connect(self.sig_module_closed)
        self.modules[mod_id] = icon
        self.order.append(mod_id)
        self.vbox.insertWidget(self.vbox.count()-1, icon)
        self._check_overflow()

    def remove_module(self, mod_id):
        if mod_id not in self.modules:
            return
        icon = self.modules.pop(mod_id)
        if mod_id in self.order:
            self.order.remove(mod_id)
        self.vbox.removeWidget(icon)
        icon.deleteLater()
        self._check_overflow()

    def select_module(self, mod_id):
        self.deselect_all()
        if mod_id in self.modules:
            self.modules[mod_id].set_active(True)
    
    def flash_module(self, mod_id):
        if mod_id in self.modules:
            self.modules[mod_id].flash()

    def deselect_all(self):
        for icon in self.modules.values(): icon.set_active(False)

    def get_order(self):
        return list(self.order)

    def eventFilter(self, obj, event):
        if obj is self.content:
            if event.type() in (QEvent.DragEnter, QEvent.DragMove):
                if event.mimeData().hasFormat("application/x-monolith-module"):
                    event.acceptProposedAction()
                    return True
            elif event.type() == QEvent.Drop:
                if event.mimeData().hasFormat("application/x-monolith-module"):
                    mod_id = bytes(event.mimeData().data("application/x-monolith-module")).decode()
                    target = self._module_at_pos(event.position().toPoint())
                    self.reorder_module(mod_id, target)
                    event.acceptProposedAction()
                    return True
        return super().eventFilter(obj, event)

    def reorder_module(self, mod_id, target_id):
        if mod_id not in self.order or mod_id == target_id:
            return
        self.order.remove(mod_id)
        if target_id and target_id in self.order:
            target_index = self.order.index(target_id)
            self.order.insert(target_index, mod_id)
        else:
            self.order.append(mod_id)
        self._rebuild_layout()

    def _module_at_pos(self, pos):
        widget = self.content.childAt(pos)
        while widget and widget is not self.content:
            if isinstance(widget, ModuleIcon):
                return widget.mod_id
            widget = widget.parent()
        return None

    def _rebuild_layout(self):
        while self.vbox.count():
            item = self.vbox.takeAt(0)
            if item.widget():
                item.widget().setParent(None)
        for mod_id in self.order:
            self.vbox.addWidget(self.modules[mod_id])
        self.vbox.addStretch()
        self._check_overflow()

    def _check_overflow(self):
        self.content.adjustSize()
        overflow = self.content.sizeHint().height() > self.scroll.height()
        self.arrow.setVisible(overflow)

    def scroll_down(self):
        vs = self.scroll.verticalScrollBar()
        vs.setValue(vs.value() + 50)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\modules\audiogen.py
================================================================================

import os
import json
from pathlib import Path
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QFrame, QComboBox, QDoubleSpinBox, QFileDialog,
    QAbstractSpinBox
)
from PySide6.QtCore import Qt, QThread, Signal, QUrl, QTimer
from PySide6.QtMultimedia import QMediaPlayer, QAudioOutput
from PySide6.QtGui import QPainter, QPen, QColor

from core.style import BG_INPUT, BORDER_DARK, FG_DIM, FG_TEXT, FG_ACCENT, FG_ERROR
from ui.components.atoms import SkeetGroupBox, SkeetButton, SkeetTriangleButton, CollapsibleSection

AUDIOCRAFT_AVAILABLE = False
try:
    import importlib
    importlib.import_module("audiocraft")
    AUDIOCRAFT_AVAILABLE = True
except ImportError:
    AUDIOCRAFT_AVAILABLE = False


class WaveformWidget(QFrame):
    def __init__(self):
        super().__init__()
        self.setFixedHeight(120)
        self.setStyleSheet(f"background: {BG_INPUT}; border: 1px solid {BORDER_DARK};")
        self.waveform_data = None
        
    def set_waveform(self, audio_array):
        if audio_array is not None and len(audio_array) > 0:
            # Downsample for display
            target_points = 500
            if len(audio_array) > target_points:
                step = len(audio_array) // target_points
                self.waveform_data = audio_array[::step]
            else:
                self.waveform_data = audio_array
        else:
            self.waveform_data = None
        self.update()
    
    def paintEvent(self, event):
        super().paintEvent(event)
        if self.waveform_data is None:
            painter = QPainter(self)
            painter.setPen(QPen(QColor(FG_DIM)))
            painter.drawText(self.rect(), Qt.AlignCenter, "NO WAVEFORM")
            return
            
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        w = self.width()
        h = self.height()
        mid_y = h / 2
        
        pen = QPen(QColor(FG_ACCENT), 1)
        painter.setPen(pen)
        
        data = self.waveform_data
        num_points = len(data)
        
        for i in range(num_points - 1):
            x1 = int((i / num_points) * w)
            x2 = int(((i + 1) / num_points) * w)
            
            y1 = int(mid_y - (data[i] * mid_y * 0.9))
            y2 = int(mid_y - (data[i + 1] * mid_y * 0.9))
            
            painter.drawLine(x1, y1, x2, y2)


class AudioGenWorker(QThread):
    progress = Signal(str)
    finished = Signal(object, int)
    error = Signal(str)

    def __init__(self, prompt, model_path, duration, sample_rate):
        super().__init__()
        self.prompt = prompt
        self.model_path = model_path
        self.duration = duration
        self.sample_rate = sample_rate

    def run(self):
        try:
            try:
                from audiocraft.models import MusicGen
            except ImportError:
                self.error.emit("ERROR: audiocraft not installed. pip install audiocraft")
                return
            import torchaudio
            import torch
            
            self.progress.emit("Loading model...")
            
            model = MusicGen.get_pretrained(self.model_path)
            model.set_generation_params(duration=self.duration)
            
            self.progress.emit("Generating audio...")
            
            wav = model.generate([self.prompt])
            
            audio_array = wav[0].cpu().numpy()
            
            self.finished.emit(audio_array, self.sample_rate)
            
        except Exception as e:
            self.error.emit(str(e))


class AudioGenModule(QWidget):
    def __init__(self):
        super().__init__()
        
        self.config_path = Path("config/audiogen_config.json")
        self.artifacts_dir = Path("artifacts/audio")
        self.artifacts_dir.mkdir(parents=True, exist_ok=True)
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.config = self._load_config()
        self.model_path = self.config.get("model_path", "")
        self.current_audio = None
        self.current_sample_rate = None
        self.current_filepath = None
        self.worker = None
        self._config_timer = QTimer(self)
        self._config_timer.setInterval(1000)
        self._config_timer.setSingleShot(True)
        self._config_timer.timeout.connect(self._save_config)
        self._status_reset_timer = QTimer(self)
        self._status_reset_timer.setInterval(1000)
        self._status_reset_timer.setSingleShot(True)
        self._status_reset_timer.timeout.connect(self._reset_status)
        
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)

        grp = SkeetGroupBox("AUDIO")
        inner = QVBoxLayout()
        inner.setSpacing(12)

        # Config Section
        config_section = CollapsibleSection("⚙ CONFIGURATION")
        config_layout = QVBoxLayout()
        config_layout.setSpacing(8)

        grp_model = SkeetGroupBox("MODEL LOADER")
        model_layout = QVBoxLayout()
        model_path_row = QHBoxLayout()
        lbl_model_path = QLabel("MODEL PATH")
        lbl_model_path.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_model_path.setFixedWidth(80)
        self.inp_model_path = QLineEdit(self.model_path)
        self.inp_model_path.setReadOnly(True)
        self.inp_model_path.setPlaceholderText("Select an AudioGen model file...")
        self.inp_model_path.setToolTip(self.model_path)
        self.inp_model_path.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_browse = SkeetButton("BROWSE...")
        btn_browse.setFixedWidth(90)
        btn_browse.clicked.connect(self._browse_model)
        model_path_row.addWidget(lbl_model_path)
        model_path_row.addWidget(self.inp_model_path)
        model_path_row.addWidget(btn_browse)
        model_layout.addLayout(model_path_row)

        model_row = QHBoxLayout()
        lbl_model = QLabel("MODEL ID")
        lbl_model.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_model.setFixedWidth(80)
        self.inp_model_id = QLineEdit()
        self.inp_model_id.setPlaceholderText("facebook/musicgen-small")
        self.inp_model_id.setText(self.config.get("model_id", "facebook/musicgen-small"))
        self.inp_model_id.setReadOnly(True)
        self.inp_model_id.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        model_row.addWidget(lbl_model)
        model_row.addWidget(self.inp_model_id)
        model_layout.addLayout(model_row)
        grp_model.add_layout(model_layout)
        config_layout.addWidget(grp_model)

        grp_audio = SkeetGroupBox("AUDIO CONFIG")
        audio_layout = QVBoxLayout()

        duration_row = QHBoxLayout()
        lbl_duration = QLabel("Duration (s)")
        lbl_duration.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_duration.setFixedWidth(80)
        self.inp_duration = QDoubleSpinBox()
        self.inp_duration.setRange(1.0, 30.0)
        self.inp_duration.setValue(self.config.get("duration", 5.0))
        self.inp_duration.setSingleStep(0.5)
        self.inp_duration.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_duration.setStyleSheet(f"""
            QDoubleSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        duration_row.addWidget(lbl_duration)
        btn_duration_down = SkeetTriangleButton("◀")
        btn_duration_down.clicked.connect(self.inp_duration.stepDown)
        btn_duration_up = SkeetTriangleButton("▶")
        btn_duration_up.clicked.connect(self.inp_duration.stepUp)
        duration_row.addWidget(btn_duration_down)
        duration_row.addWidget(self.inp_duration)
        duration_row.addWidget(btn_duration_up)
        duration_row.addStretch()
        audio_layout.addLayout(duration_row)

        sr_row = QHBoxLayout()
        lbl_sr = QLabel("Sample Rate")
        lbl_sr.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_sr.setFixedWidth(80)
        self.cmb_sr = QComboBox()
        self.cmb_sr.addItems(["32000", "44100", "48000"])
        self.cmb_sr.setCurrentText(str(self.config.get("sample_rate", 32000)))
        self.cmb_sr.setStyleSheet(f"""
            QComboBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        sr_row.addWidget(lbl_sr)
        sr_row.addWidget(self.cmb_sr)
        sr_row.addStretch()
        audio_layout.addLayout(sr_row)

        grp_audio.add_layout(audio_layout)
        config_layout.addWidget(grp_audio)
        
        config_section.set_content_layout(config_layout)
        inner.addWidget(config_section)

        # Prompt
        lbl_prompt = QLabel("Prompt")
        lbl_prompt.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")

        self.inp_prompt = QLineEdit()
        self.inp_prompt.setPlaceholderText("Describe a sound to generate...")
        self.inp_prompt.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 6px;
            }}
        """)

        # Buttons
        btn_row = QHBoxLayout()
        self.btn_generate = SkeetButton("GENERATE", accent=True)
        self.btn_generate.clicked.connect(self._start_generate)
        self.btn_play = SkeetButton("PLAY")
        self.btn_play.clicked.connect(self._play_audio)
        self.btn_play.setEnabled(False)
        self.btn_save = SkeetButton("SAVE AUDIO")
        self.btn_save.clicked.connect(self._save_audio)
        self.btn_save.setEnabled(False)
        btn_row.addWidget(self.btn_generate)
        btn_row.addWidget(self.btn_play)
        btn_row.addWidget(self.btn_save)
        btn_row.addStretch()

        # Waveform Display
        self.waveform_widget = WaveformWidget()

        # Status
        status_row = QHBoxLayout()
        lbl_status_title = QLabel("Status")
        lbl_status_title.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        self.lbl_status = QLabel("IDLE")
        self.lbl_status.setStyleSheet(f"color: {FG_TEXT}; font-size: 10px; font-weight: bold;")
        status_row.addWidget(lbl_status_title)
        status_row.addStretch()
        status_row.addWidget(self.lbl_status)

        inner.addWidget(lbl_prompt)
        inner.addWidget(self.inp_prompt)
        inner.addLayout(btn_row)
        inner.addWidget(self.waveform_widget)
        inner.addLayout(status_row)
        inner.addStretch()

        grp.add_layout(inner)
        layout.addWidget(grp)

        self.inp_duration.valueChanged.connect(self._queue_save_config)
        self.cmb_sr.currentTextChanged.connect(self._queue_save_config)

    def _load_config(self):
        if self.config_path.exists():
            try:
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                return config
            except:
                pass
        return {
            "model_path": "",
            "model_id": "facebook/musicgen-small",
            "duration": 5.0,
            "sample_rate": 32000
        }

    def _queue_save_config(self):
        self._status_reset_timer.stop()
        self._config_timer.start()

    def _save_config(self):
        config = {
            "model_path": self.model_path,
            "model_id": self.inp_model_id.text().strip() or self.inp_model_id.placeholderText(),
            "duration": self.inp_duration.value(),
            "sample_rate": int(self.cmb_sr.currentText())
        }
        with open(self.config_path, 'w') as f:
            json.dump(config, f, indent=2)
        self.config = config
        self._set_status("CONFIG SAVED", FG_ACCENT)
        self._status_reset_timer.start()

    def _browse_model(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Audio Model", "", "All Files (*)")
        if not path:
            return
        path = os.path.abspath(path)
        try:
            if not AUDIOCRAFT_AVAILABLE:
                self._set_status("ERROR: audiocraft not installed. pip install audiocraft", FG_ERROR)
                self.inp_model_path.setText(self.model_path)
                self.inp_model_path.setToolTip(self.model_path)
                return
            try:
                from audiocraft.models import MusicGen
            except ImportError:
                self._set_status("ERROR: audiocraft not installed. pip install audiocraft", FG_ERROR)
                self.inp_model_path.setText(self.model_path)
                self.inp_model_path.setToolTip(self.model_path)
                return
            MusicGen.get_pretrained(path)
        except Exception as exc:
            self._set_status(f"ERROR: {str(exc)}", FG_ERROR)
            self.inp_model_path.setText(self.model_path)
            self.inp_model_path.setToolTip(self.model_path)
            return
        self.model_path = path
        self.inp_model_path.setText(path)
        self.inp_model_path.setToolTip(path)
        self._queue_save_config()

    def _set_status(self, status, color):
        self.lbl_status.setText(status)
        self.lbl_status.setStyleSheet(f"color: {color}; font-size: 10px; font-weight: bold;")

    def _reset_status(self):
        self._set_status("IDLE", FG_TEXT)

    def _start_generate(self):
        if not AUDIOCRAFT_AVAILABLE:
            self._set_status("ERROR: audiocraft not installed. pip install audiocraft", FG_ERROR)
            return
            
        prompt = self.inp_prompt.text().strip()
        if not prompt:
            self._set_status("ERROR: No prompt", FG_ERROR)
            return

        self.btn_generate.setEnabled(False)
        self.btn_play.setEnabled(False)
        self.btn_save.setEnabled(False)
        self._set_status("INITIALIZING", FG_ACCENT)

        model_path = self.model_path
        if not model_path:
            self._set_status("ERROR: No model selected", FG_ERROR)
            return

        self.worker = AudioGenWorker(
            prompt,
            model_path,
            self.inp_duration.value(),
            int(self.cmb_sr.currentText())
        )
        self.worker.progress.connect(self._on_progress)
        self.worker.finished.connect(self._on_finished)
        self.worker.error.connect(self._on_error)
        self.worker.start()

    def _on_progress(self, msg):
        self._set_status(msg, FG_ACCENT)

    def _on_finished(self, audio_array, sample_rate):
        self.current_audio = audio_array
        self.current_sample_rate = sample_rate
        
        # Save temporarily for playback
        import time
        temp_filename = f"temp_audio_{int(time.time())}.wav"
        self.current_filepath = self.artifacts_dir / temp_filename
        
        try:
            import torch
            import torchaudio
            audio_tensor = torch.from_numpy(audio_array).unsqueeze(0)
            torchaudio.save(str(self.current_filepath), audio_tensor, sample_rate)
        except Exception as e:
            self._set_status(f"SAVE ERROR: {str(e)}", FG_ERROR)
            return
        
        # Display waveform (use mono channel)
        if len(audio_array.shape) > 1:
            display_data = audio_array[0]
        else:
            display_data = audio_array
        self.waveform_widget.set_waveform(display_data)
        
        self._set_status("DONE", FG_TEXT)
        self.btn_generate.setEnabled(True)
        self.btn_play.setEnabled(True)
        self.btn_save.setEnabled(True)

    def _on_error(self, err_msg):
        self._set_status(f"ERROR: {err_msg}", FG_ERROR)
        self.btn_generate.setEnabled(True)

    def _play_audio(self):
        if not self.current_filepath or not self.current_filepath.exists():
            return
            
        self.player.setSource(QUrl.fromLocalFile(str(self.current_filepath)))
        self.player.play()
        self._set_status("PLAYING", FG_ACCENT)

    def _save_audio(self):
        if self.current_audio is None:
            return
        
        if not self.current_filepath or not self.current_filepath.exists():
            return
            
        import time
        filename = f"audio_{int(time.time())}.wav"
        filepath = self.artifacts_dir / filename
        
        try:
            import shutil
            shutil.copy(self.current_filepath, filepath)
            self._set_status(f"SAVED: {filename}", FG_ACCENT)
        except Exception as e:
            self._set_status(f"SAVE ERROR: {str(e)}", FG_ERROR)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\modules\injector.py
================================================================================

import sys
import os
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
    QPushButton, QPlainTextEdit, QSplitter, QFrame
)
from PySide6.QtCore import Qt, Signal, QProcess, QUrl
from PySide6.QtGui import QTextCursor, QDragEnterEvent, QDropEvent

from core.style import BG_GROUP, BORDER_DARK, FG_DIM, FG_ACCENT, BG_INPUT, FG_ERROR, ACCENT_GOLD

class InjectorWidget(QWidget):
    sig_closed = Signal()
    sig_finished = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setObjectName("InjectorRoot")
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Toolbar
        toolbar = QFrame()
        toolbar.setFixedHeight(35)
        toolbar.setStyleSheet(f"background: {BG_GROUP}; border-bottom: 1px solid {BORDER_DARK};")
        tb_layout = QHBoxLayout(toolbar)
        tb_layout.setContentsMargins(10, 0, 10, 0)
        
        lbl_title = QLabel("RUNTIME")
        lbl_title.setStyleSheet(f"color: {ACCENT_GOLD}; font-weight: bold; font-size: 11px;")
        
        self.btn_run = QPushButton("▶ EXECUTE")
        self.btn_run.setCursor(Qt.PointingHandCursor)
        self.btn_run.setStyleSheet(f"""
            QPushButton {{ background: #1a1a1a; color: {FG_ACCENT}; border: 1px solid #333; padding: 4px 10px; font-weight:bold; font-size: 10px;}}
            QPushButton:hover {{ background: #222; border-color: {FG_ACCENT}; }}
        """)
        self.btn_run.clicked.connect(self.run_code)

        btn_close = QPushButton("×")
        btn_close.setFixedSize(20, 20)
        btn_close.setCursor(Qt.PointingHandCursor)
        btn_close.setStyleSheet("background: transparent; color: #555; border: none; font-weight: bold; font-size: 14px;")
        btn_close.clicked.connect(self.close_addon)
        
        tb_layout.addWidget(lbl_title)
        tb_layout.addStretch()
        tb_layout.addWidget(self.btn_run)
        tb_layout.addWidget(btn_close)
        
        layout.addWidget(toolbar)
        
        # Splitter (Code | Console)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setHandleWidth(1)
        splitter.setStyleSheet(f"QSplitter::handle {{ background: {BORDER_DARK}; }}")
        
        self.editor = QPlainTextEdit()
        self.editor.setPlaceholderText("# Drag .py file here or write code...")
        self.editor.setStyleSheet(f"""
            QPlainTextEdit {{
                background: {BG_INPUT}; color: #dcdcdc; 
                border: none; font-family: 'Consolas', monospace; font-size: 12px; padding: 10px;
            }}
        """)
        
        self.console = QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setPlaceholderText("Output...")
        self.console.setStyleSheet(f"""
            QPlainTextEdit {{
                background: #080808; color: {FG_DIM}; 
                border: none; border-left: 1px solid {BORDER_DARK};
                font-family: 'Consolas', monospace; font-size: 11px; padding: 10px;
            }}
        """)
        
        splitter.addWidget(self.editor)
        splitter.addWidget(self.console)
        splitter.setSizes([400, 400])
        
        layout.addWidget(splitter)

        self.process = QProcess(self)
        self.process.setProcessChannelMode(QProcess.MergedChannels)
        self.process.readyReadStandardOutput.connect(self._read_output)
        self.process.finished.connect(self._process_finished)

    def dragEnterEvent(self, event: QDragEnterEvent):
        # Accept if files (Explorer) or Text (Qt Tree View default drag)
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event: QDropEvent):
        file_path = None
        
        # Case 1: Dragged from Explorer (MimeType: text/uri-list)
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls:
                file_path = urls[0].toLocalFile()

        # Case 2: Dragged from Databank Tree (MimeType: text/plain usually)
        # The tree might just pass the path string
        elif event.mimeData().hasText():
            text = event.mimeData().text()
            # Clean up if it has file:/// prefix even in text mode
            if text.startswith("file:///"):
                file_path = QUrl(text).toLocalFile()
            elif os.path.exists(text):
                file_path = text

        if file_path and os.path.exists(file_path):
            self._load_file(file_path)
        else:
            self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: Could not resolve file path.</span>")

    def _load_file(self, path):
        if os.path.isfile(path) and path.endswith(".py"):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    self.editor.setPlainText(f.read())
                self.console.appendHtml(f"<span style='color:{FG_ACCENT}'>→ LOADED: {os.path.basename(path)}</span>")
            except Exception as e:
                self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: {e}</span>")
        else:
             self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: Not a .py file</span>")

    def run_code(self):
        code = self.editor.toPlainText()
        if not code.strip(): return
        
        if self.process.state() != QProcess.NotRunning:
            self.console.appendHtml(f"<span style='color:{FG_ERROR}'>BUSY: Process running...</span>")
            return

        self.console.clear()
        self.console.appendHtml(f"<span style='color:{FG_ACCENT}'>→ EXECUTING SCRIPT...</span>")
        self.process.start(sys.executable, ["-c", code])

    def _read_output(self):
        data = self.process.readAllStandardOutput().data().decode()
        self.console.moveCursor(QTextCursor.End)
        self.console.insertPlainText(data)

    def _process_finished(self):
        self.console.appendHtml(f"<br><span style='color:{FG_DIM}'>→ PROCESS TERMINATED</span>")
        self.sig_finished.emit()

    def close_addon(self):
        if self.process.state() != QProcess.NotRunning:
            self.process.kill()
        self.sig_closed.emit()
        self.deleteLater()

    def closeEvent(self, event):
        if self.process.state() != QProcess.NotRunning:
            self.process.kill()
            self.process.waitForFinished(300)
        event.accept()



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\modules\manager.py
================================================================================

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QScrollArea
from PySide6.QtCore import Signal, Qt

from ui.components.atoms import SkeetGroupBox, SkeetButton
from core.style import FG_DIM

class PageAddons(QWidget):
    sig_launch_addon = Signal(str)
    sig_open_vitals = Signal()
    sig_open_overseer = Signal()

    def __init__(self, state):
        super().__init__()
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)

        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(0, 0, 0, 0)

        grp_modules = SkeetGroupBox("AVAILABLE MODULES")
        
        mod_layout = QVBoxLayout()
        mod_layout.setSpacing(15)
        
        lbl_info = QLabel("Select a runtime module to attach to the workspace.")
        lbl_info.setStyleSheet(f"color: {FG_DIM}; font-size: 11px;")

        btn_terminal = SkeetButton("TERMINAL")
        btn_terminal.clicked.connect(lambda: self.sig_launch_addon.emit("terminal"))

        btn_databank = SkeetButton("DATABANK")
        btn_databank.clicked.connect(lambda: self.sig_launch_addon.emit("databank"))

        btn_injector = SkeetButton("INJECTOR")
        btn_injector.clicked.connect(lambda: self.sig_launch_addon.emit("injector"))

        btn_sd = SkeetButton("VISION")
        btn_sd.clicked.connect(lambda: self.sig_launch_addon.emit("sd"))

        btn_audiogen = SkeetButton("AUDIO")
        btn_audiogen.clicked.connect(lambda: self.sig_launch_addon.emit("audiogen"))

        mod_layout.addWidget(lbl_info)
        mod_layout.addWidget(btn_terminal)
        mod_layout.addWidget(btn_databank)
        mod_layout.addWidget(btn_injector)
        mod_layout.addWidget(btn_sd)
        mod_layout.addWidget(btn_audiogen)
        mod_layout.addStretch()
        
        grp_modules.add_layout(mod_layout)
        scroll_layout.addWidget(grp_modules)
        
        grp_system = SkeetGroupBox("SYSTEM")
        system_layout = QVBoxLayout()
        system_layout.setSpacing(10)

        btn_vitals = SkeetButton("VITALS")
        btn_vitals.clicked.connect(self.sig_open_vitals.emit)

        btn_overseer = SkeetButton("OVERSEER")
        btn_overseer.clicked.connect(self.sig_open_overseer.emit)

        system_layout.addWidget(btn_vitals)
        system_layout.addWidget(btn_overseer)
        grp_system.add_layout(system_layout)
        scroll_layout.addWidget(grp_system)
        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_content)
        layout.addWidget(scroll_area)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\modules\sd.py
================================================================================

import json

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QScrollArea, QFileDialog, QSpinBox, QDoubleSpinBox,
    QAbstractSpinBox
)
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QPixmap, QImage

from core.style import BG_INPUT, BORDER_DARK, FG_DIM, FG_TEXT, FG_ACCENT, FG_ERROR
from core.state import SystemStatus
from core.paths import CONFIG_DIR, MONOLITH_ROOT
from monokernel.bridge import MonoBridge
from monokernel.guard import MonoGuard
from ui.components.atoms import SkeetGroupBox, SkeetButton, SkeetTriangleButton, CollapsibleSection

class SDModule(QWidget):
    def __init__(self, bridge: MonoBridge, guard: MonoGuard):
        super().__init__()
        self.bridge = bridge
        self.guard = guard

        self.config_path = CONFIG_DIR / "vision_config.json"
        self.legacy_config_path = CONFIG_DIR / "sd_config.json"
        self.artifacts_dir = MONOLITH_ROOT / "artifacts" / "vision"
        self.artifacts_dir.mkdir(parents=True, exist_ok=True)
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.config = self._load_config()
        self.model_path = self.config.get("model_path", "")
        self.is_model_loaded = False
        self.current_image = None
        self._engine_status = SystemStatus.READY
        self._config_timer = QTimer(self)
        self._config_timer.setInterval(1000)
        self._config_timer.setSingleShot(True)
        self._config_timer.timeout.connect(self._save_config)
        self._status_reset_timer = QTimer(self)
        self._status_reset_timer.setInterval(1000)
        self._status_reset_timer.setSingleShot(True)
        self._status_reset_timer.timeout.connect(self._reset_status)
        if self.model_path:
            self.bridge.submit(
                self.bridge.wrap(
                    "vision",
                    "set_path",
                    "vision",
                    payload={"path": self.model_path},
                )
            )

        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)

        grp = SkeetGroupBox("VISION")
        inner = QVBoxLayout()
        inner.setSpacing(12)

        # Config Section
        config_section = CollapsibleSection("⚙ CONFIGURATION")
        config_layout = QVBoxLayout()
        config_layout.setSpacing(8)
        
        # Model Loader
        grp_loader = SkeetGroupBox("MODEL LOADER")
        loader_layout = QVBoxLayout()
        loader_row = QHBoxLayout()
        lbl_model = QLabel("Model Path")
        lbl_model.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        self.inp_model = QLineEdit(self.model_path)
        self.inp_model.setReadOnly(True)
        self.inp_model.setPlaceholderText("Select a model file (.ckpt or .safetensors)...")
        self.inp_model.setToolTip(self.model_path)
        self.inp_model.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_browse = SkeetButton("BROWSE...")
        btn_browse.setFixedWidth(90)
        btn_browse.clicked.connect(self._browse_model)
        loader_row.addWidget(lbl_model, 0)
        loader_row.addWidget(self.inp_model, 1)
        loader_row.addWidget(btn_browse, 0)
        self.btn_load = SkeetButton("LOAD MODEL")
        self.btn_load.setCheckable(True)
        self.btn_load.setChecked(False)
        self.btn_load.clicked.connect(self._load_model)
        loader_layout.addLayout(loader_row)
        loader_layout.addWidget(self.btn_load)
        grp_loader.add_layout(loader_layout)
        config_layout.addWidget(grp_loader)
        
        # Steps
        steps_row = QHBoxLayout()
        lbl_steps = QLabel("Steps")
        lbl_steps.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_steps.setFixedWidth(80)
        self.inp_steps = QSpinBox()
        self.inp_steps.setRange(1, 150)
        self.inp_steps.setValue(self.config.get("steps", 25))
        self.inp_steps.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_steps.setStyleSheet(f"""
            QSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        steps_row.addWidget(lbl_steps)
        btn_steps_down = SkeetTriangleButton("◀")
        btn_steps_down.clicked.connect(self.inp_steps.stepDown)
        btn_steps_up = SkeetTriangleButton("▶")
        btn_steps_up.clicked.connect(self.inp_steps.stepUp)
        steps_row.addWidget(btn_steps_down)
        steps_row.addWidget(self.inp_steps)
        steps_row.addWidget(btn_steps_up)
        steps_row.addStretch()
        config_layout.addLayout(steps_row)
        
        # Strength
        strength_row = QHBoxLayout()
        lbl_strength = QLabel("Strength")
        lbl_strength.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_strength.setFixedWidth(80)
        self.inp_strength = QDoubleSpinBox()
        self.inp_strength.setRange(1.0, 20.0)
        self.inp_strength.setValue(self.config.get("guidance_scale", 7.5))
        self.inp_strength.setSingleStep(0.5)
        self.inp_strength.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_strength.setStyleSheet(f"""
            QDoubleSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_strength_down = SkeetTriangleButton("◀")
        btn_strength_down.clicked.connect(self.inp_strength.stepDown)
        btn_strength_up = SkeetTriangleButton("▶")
        btn_strength_up.clicked.connect(self.inp_strength.stepUp)
        strength_row.addWidget(lbl_strength)
        strength_row.addWidget(btn_strength_down)
        strength_row.addWidget(self.inp_strength)
        strength_row.addWidget(btn_strength_up)
        strength_row.addStretch()
        config_layout.addLayout(strength_row)
        
        # Seed
        seed_row = QHBoxLayout()
        lbl_seed = QLabel("Seed")
        lbl_seed.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_seed.setFixedWidth(80)
        self.inp_seed = QSpinBox()
        self.inp_seed.setRange(-1, 2147483647)
        self.inp_seed.setSpecialValueText("RANDOM")
        self.inp_seed.setValue(self.config.get("seed", -1))
        self.inp_seed.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_seed.setStyleSheet(f"""
            QSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_seed_down = SkeetTriangleButton("◀")
        btn_seed_down.clicked.connect(self.inp_seed.stepDown)
        btn_seed_up = SkeetTriangleButton("▶")
        btn_seed_up.clicked.connect(self.inp_seed.stepUp)
        seed_row.addWidget(lbl_seed)
        seed_row.addWidget(btn_seed_down)
        seed_row.addWidget(self.inp_seed)
        seed_row.addWidget(btn_seed_up)
        seed_row.addStretch()
        config_layout.addLayout(seed_row)
        
        config_section.set_content_layout(config_layout)
        inner.addWidget(config_section)

        # Prompt
        lbl_prompt = QLabel("Prompt")
        lbl_prompt.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")

        self.inp_prompt = QLineEdit()
        self.inp_prompt.setPlaceholderText("Describe an image to generate...")
        self.inp_prompt.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 6px;
            }}
        """)

        # Buttons
        btn_row = QHBoxLayout()
        self.btn_generate = SkeetButton("GENERATE", accent=True)
        self.btn_generate.clicked.connect(self._start_generate)
        self.btn_generate.setEnabled(self.is_model_loaded)
        self.btn_stop = SkeetButton("STOP")
        self.btn_stop.clicked.connect(lambda: self.bridge.stop("vision"))
        self.btn_stop.setEnabled(False)
        self.btn_save = SkeetButton("SAVE IMAGE")
        self.btn_save.clicked.connect(self._save_image)
        self.btn_save.setEnabled(False)
        btn_row.addWidget(self.btn_generate)
        btn_row.addWidget(self.btn_stop)
        btn_row.addWidget(self.btn_save)
        btn_row.addStretch()

        # Preview
        preview_scroll = QScrollArea()
        preview_scroll.setWidgetResizable(True)
        preview_scroll.setFixedHeight(400)
        preview_scroll.setStyleSheet(f"background: {BG_INPUT}; border: 1px solid {BORDER_DARK};")
        
        self.lbl_preview = QLabel("NO IMAGE")
        self.lbl_preview.setAlignment(Qt.AlignCenter)
        self.lbl_preview.setStyleSheet(f"color: {FG_DIM}; font-size: 12px;")
        preview_scroll.setWidget(self.lbl_preview)

        # Status
        status_row = QHBoxLayout()
        lbl_status_title = QLabel("Status")
        lbl_status_title.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        self.lbl_status = QLabel("IDLE")
        self.lbl_status.setStyleSheet(f"color: {FG_TEXT}; font-size: 10px; font-weight: bold;")
        status_row.addWidget(lbl_status_title)
        status_row.addStretch()
        status_row.addWidget(self.lbl_status)

        inner.addWidget(lbl_prompt)
        inner.addWidget(self.inp_prompt)
        inner.addLayout(btn_row)
        inner.addWidget(preview_scroll)
        inner.addLayout(status_row)
        inner.addStretch()

        grp.add_layout(inner)
        layout.addWidget(grp)

        self.inp_steps.valueChanged.connect(self._queue_save_config)
        self.inp_strength.valueChanged.connect(self._queue_save_config)
        self.inp_seed.valueChanged.connect(self._queue_save_config)
        self.guard.sig_image.connect(self._on_image)
        self.guard.sig_status.connect(self._on_status)
        self.guard.sig_trace.connect(lambda _engine_key, message: self._on_trace(message))

    def _load_config(self):
        if self.config_path.exists():
            try:
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                return self._normalize_config(config)
            except Exception:
                pass
        if self.legacy_config_path.exists():
            try:
                with open(self.legacy_config_path, 'r') as f:
                    config = json.load(f)
                config = self._normalize_config(config)
                with open(self.config_path, 'w') as f:
                    json.dump(config, f, indent=2)
                return config
            except Exception:
                pass
        return {
            "model_path": "",
            "steps": 25,
            "guidance_scale": 7.5,
            "seed": -1
        }

    def _normalize_config(self, config):
        use_seed = config.get("use_seed")
        if use_seed is False:
            config["seed"] = -1
        config.pop("use_seed", None)
        if "seed" not in config:
            config["seed"] = -1
        return config

    def _save_config(self):
        config = {
            "model_path": self.model_path,
            "steps": self.inp_steps.value(),
            "guidance_scale": self.inp_strength.value(),
            "seed": self.inp_seed.value()
        }
        with open(self.config_path, 'w') as f:
            json.dump(config, f, indent=2)
        self.config = config
        if self._engine_status not in (
            SystemStatus.LOADING,
            SystemStatus.RUNNING,
            SystemStatus.UNLOADING,
        ):
            self._set_status("CONFIG SAVED", FG_ACCENT)
            self._status_reset_timer.start()

    def _browse_model(self):
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Vision Model",
            "",
            "Model Files (*.ckpt *.safetensors);;All Files (*)"
        )
        if path:
            self.inp_model.setText(path)
            self.inp_model.setToolTip(path)
            self.btn_load.setChecked(False)
            self.btn_load.setText("LOAD MODEL")
            self.is_model_loaded = False

    def _load_model(self):
        if self.btn_load.isChecked():
            path = self.inp_model.text().strip()
            if not path:
                self._set_status("ERROR: No model selected", FG_ERROR)
                self.btn_load.setChecked(False)
                return
            self.model_path = path
            self._queue_save_config()
            self.bridge.submit(
                self.bridge.wrap(
                    "vision",
                    "set_path",
                    "vision",
                    payload={"path": path},
                )
            )
            self.bridge.submit(self.bridge.wrap("vision", "load", "vision"))
        else:
            self.bridge.submit(self.bridge.wrap("vision", "unload", "vision"))

    def _queue_save_config(self):
        self._status_reset_timer.stop()
        self._config_timer.start()

    def _set_status(self, status, color):
        self.lbl_status.setText(status)
        self.lbl_status.setStyleSheet(f"color: {color}; font-size: 10px; font-weight: bold;")

    def _reset_status(self):
        self._set_status("IDLE", FG_TEXT)

    def _start_generate(self):
        prompt = self.inp_prompt.text().strip()
        if not prompt:
            self._set_status("ERROR: No prompt", FG_ERROR)
            return

        self.btn_generate.setEnabled(False)
        self.btn_save.setEnabled(False)
        self._set_status("REQUESTED", FG_ACCENT)

        seed_value = self.inp_seed.value()
        seed = None if seed_value < 0 else seed_value
        config = {
            "steps": self.inp_steps.value(),
            "guidance_scale": self.inp_strength.value(),
            "seed": seed,
        }
        self.bridge.submit(
            self.bridge.wrap(
                "vision",
                "generate",
                "vision",
                payload={"prompt": prompt, "config": config},
            )
        )

    def _save_image(self):
        if not self.current_image:
            return
            
        import time
        filename = f"vision_{int(time.time())}.png"
        filepath = self.artifacts_dir / filename
        
        try:
            if isinstance(self.current_image, QImage):
                self.current_image.save(str(filepath))
            else:
                self.current_image.save(filepath)
            self._set_status(f"SAVED: {filename}", FG_ACCENT)
        except Exception as e:
            self._set_status(f"SAVE ERROR: {str(e)}", FG_ERROR)

    def _on_image(self, image):
        self.current_image = image
        if isinstance(image, QImage):
            qimage = image
        else:
            pil_image = image.convert("RGB")
            data = pil_image.tobytes("raw", "RGB")
            qimage = QImage(
                data,
                pil_image.width,
                pil_image.height,
                QImage.Format_RGB888,
            ).copy()

        pixmap = QPixmap.fromImage(qimage)
        self.lbl_preview.setPixmap(pixmap.scaled(
            self.lbl_preview.width() - 20,
            self.lbl_preview.height() - 20,
            Qt.KeepAspectRatio,
            Qt.SmoothTransformation,
        ))
        self._set_status("DONE", FG_TEXT)
        self.btn_save.setEnabled(True)

    def _on_status(self, engine_key: str, status: SystemStatus) -> None:
        if engine_key != "vision":
            return
        self._engine_status = status
        is_busy = status in (
            SystemStatus.LOADING,
            SystemStatus.RUNNING,
            SystemStatus.UNLOADING,
        )
        self.btn_generate.setEnabled(not is_busy and self.is_model_loaded)
        self.btn_load.setEnabled(not is_busy)
        self.btn_stop.setEnabled(is_busy)
        if status == SystemStatus.LOADING:
            self._set_status("LOADING", FG_ACCENT)
            self.btn_load.setText("LOADING...")
        elif status == SystemStatus.RUNNING:
            self._set_status("RUNNING", FG_ACCENT)
        elif status == SystemStatus.UNLOADING:
            self._set_status("UNLOADING", FG_ACCENT)
        elif status == SystemStatus.READY:
            self._set_status("READY", FG_TEXT)
            if self.btn_load.isChecked() and self.model_path:
                self.is_model_loaded = True
                self.btn_load.setText("UNLOAD MODEL")
            else:
                self.is_model_loaded = False
                self.btn_load.setChecked(False)
                self.btn_load.setText("LOAD MODEL")
            self.btn_generate.setEnabled(self.is_model_loaded and not is_busy)
        elif status == SystemStatus.ERROR:
            self._set_status("ERROR", FG_ERROR)
            self.is_model_loaded = False
            self.btn_load.setChecked(False)
            self.btn_load.setText("LOAD MODEL")
            self.btn_generate.setEnabled(False)

    def _on_trace(self, message: str) -> None:
        if "VISION: ERROR:" in message:
            self._set_status(message.replace("VISION: ", ""), FG_ERROR)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\pages\chat.py
================================================================================

import json
import re
from datetime import datetime, timezone
from pathlib import Path

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTextEdit,
    QLineEdit, QPushButton, QLabel, QFileDialog,
    QSplitter, QListWidget, QListWidgetItem, QStackedWidget,
    QMessageBox, QButtonGroup, QMenu
)
from PySide6.QtCore import Signal, Qt, QTimer, QDateTime
from PySide6.QtGui import QActionGroup

from core.state import SystemStatus
from core.style import BG_INPUT, FG_DIM, FG_TEXT, ACCENT_GOLD, FG_ERROR, SCROLLBAR_STYLE
from ui.components.atoms import SkeetGroupBox, SkeetButton, SkeetSlider
from ui.components.complex import BehaviorTagInput
from ui.components.message_widget import MessageWidget
from core.llm_config import DEFAULT_CONFIG, MASTER_PROMPT, load_config, save_config
from core.paths import ARCHIVE_DIR

class PageChat(QWidget):
    sig_generate = Signal(str, bool)
    sig_load = Signal()
    sig_unload = Signal()
    sig_stop = Signal()
    sig_sync_history = Signal(list)
    sig_set_model_path = Signal(str)
    sig_set_ctx_limit = Signal(int)
    sig_operator_loaded = Signal(str)
    sig_debug = Signal(str)

    def __init__(self, state, ui_bridge):
        super().__init__()
        self.state = state
        self.ui_bridge = ui_bridge
        self.config = load_config()
        self._token_buf: list[str] = []
        self._flush_timer = QTimer(self)
        self._flush_timer.setInterval(25)
        self._flush_timer.timeout.connect(self._flush_tokens)
        self._archive_dir = self._get_archive_dir()
        self._archive_dir.mkdir(parents=True, exist_ok=True)
        self._session_counter = 0
        self._current_session = self._create_session()
        self._undo_snapshot = None
        self._title_generated = False
        self._suppress_title_regen = False
        self._active_assistant_index = None
        self._rewrite_assistant_index = None
        self._active_widget: MessageWidget | None = None
        self._last_status = None
        self._is_running = False
        self._is_model_loaded = False
        self._pending_update_text = None
        self._awaiting_update_restart = False
        self._update_trace_state = None
        self._update_token_count = 0
        self._update_progress_index = 0
        self._config_dirty = False
        self._thinking_mode = bool(self.config.get("thinking_mode", False))
        # When user clicks Edit/Regen/Delete while a generation is running, we STOP first,
        # then apply the mutation on the next READY.
        self._pending_mutation = None  # type: ignore[assignment]


        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(20)

        main_split = QSplitter(Qt.Horizontal)
        main_split.setChildrenCollapsible(False)
        layout.addWidget(main_split)

        # === MODEL LOADER (lives in CONTROL tab) ===
        grp_load = SkeetGroupBox("MODEL LOADER")
        self.path_display = QLineEdit()
        self.path_display.setReadOnly(True)
        self.path_display.setPlaceholderText("No GGUF Selected")
        self.path_display.setStyleSheet(
            f"background: {BG_INPUT}; color: #555; border: 1px solid #333; padding: 5px;"
        )
        btn_browse = SkeetButton("...")
        btn_browse.setFixedWidth(30)
        btn_browse.clicked.connect(self.pick_file)
        row_file = QHBoxLayout()
        row_file.addWidget(self.path_display)
        row_file.addWidget(btn_browse)
        self.btn_load = SkeetButton("LOAD MODEL")
        self.btn_load.clicked.connect(self.toggle_load)
        grp_load.add_layout(row_file)
        grp_load.add_widget(self.btn_load)

        # === AI CONFIGURATION (lives in SETTINGS tab) ===
        self.s_temp = SkeetSlider("Temperature", 0.1, 2.0, self.config.get("temp", 0.7))
        self.s_temp.valueChanged.connect(lambda v: self._update_config_value("temp", v))
        self.s_top = SkeetSlider("Top-P", 0.1, 1.0, self.config.get("top_p", 0.9))
        self.s_top.valueChanged.connect(lambda v: self._update_config_value("top_p", v))
        self.s_tok = SkeetSlider(
            "Max Tokens", 512, 8192, self.config.get("max_tokens", 2048), is_int=True
        )
        self.s_tok.valueChanged.connect(
            lambda v: self._update_config_value("max_tokens", int(v))
        )
        self.s_ctx = SkeetSlider(
            "Context Limit", 1024, 16384, self.config.get("ctx_limit", 8192), is_int=True
        )
        self.s_ctx.valueChanged.connect(self._on_ctx_limit_changed)

        save_row = QHBoxLayout()
        self.lbl_config_state = QLabel("SAVED")
        self.lbl_config_state.setStyleSheet(f"color: {FG_DIM}; font-size: 10px; font-weight: bold;")
        self.btn_save_config = SkeetButton("SAVE SETTINGS")
        self.btn_save_config.clicked.connect(self._save_config)
        btn_reset_config = SkeetButton("RESET")
        btn_reset_config.clicked.connect(self._reset_config)
        save_row.addWidget(self.lbl_config_state)
        save_row.addStretch()
        save_row.addWidget(btn_reset_config)
        save_row.addWidget(self.btn_save_config)

        # === OPERATIONS GROUP with 3 tabs ===
        operations_group = SkeetGroupBox("OPERATIONS")
        operations_layout = QVBoxLayout()
        operations_layout.setSpacing(10)

        tab_row = QHBoxLayout()
        tab_style = f"""
            QPushButton {{
                background: #181818; border: 1px solid #333; color: {FG_DIM};
                padding: 6px 12px; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:checked {{
                background: #222; color: {ACCENT_GOLD}; border: 1px solid {ACCENT_GOLD};
            }}
            QPushButton:hover {{ color: {FG_TEXT}; border: 1px solid {FG_TEXT}; }}
        """
        self.btn_tab_control = SkeetButton("CONTROL")
        self.btn_tab_control.setCheckable(True)
        self.btn_tab_control.setChecked(True)
        self.btn_tab_control.setStyleSheet(tab_style)
        self.btn_tab_archive = SkeetButton("ARCHIVE")
        self.btn_tab_archive.setCheckable(True)
        self.btn_tab_archive.setStyleSheet(tab_style)
        self.btn_tab_settings = SkeetButton("SETTINGS")
        self.btn_tab_settings.setCheckable(True)
        self.btn_tab_settings.setStyleSheet(tab_style)
        tab_group = QButtonGroup(self)
        tab_group.setExclusive(True)
        tab_group.addButton(self.btn_tab_control)
        tab_group.addButton(self.btn_tab_archive)
        tab_group.addButton(self.btn_tab_settings)
        tab_row.addWidget(self.btn_tab_control)
        tab_row.addWidget(self.btn_tab_archive)
        tab_row.addWidget(self.btn_tab_settings)
        tab_row.addStretch()
        operations_layout.addLayout(tab_row)

        self.ops_stack = QStackedWidget()
        operations_layout.addWidget(self.ops_stack)

        # --- CONTROL tab: Model Loader (top-level, no collapsible) ---
        control_tab = QWidget()
        control_layout = QVBoxLayout(control_tab)
        control_layout.setSpacing(12)
        control_layout.addWidget(grp_load)

        # --- Collapsible OPTIONS panel ---
        self._options_expanded = False
        self.btn_options_toggle = QPushButton("▸ OPTIONS")
        self.btn_options_toggle.setCursor(Qt.PointingHandCursor)
        self.btn_options_toggle.setStyleSheet(f"""
            QPushButton {{
                background: transparent; border: none;
                color: {FG_DIM}; font-size: 9px; font-weight: bold;
                letter-spacing: 1px; text-align: left; padding: 4px 0;
            }}
            QPushButton:hover {{ color: {ACCENT_GOLD}; }}
        """)
        self.btn_options_toggle.clicked.connect(self._toggle_options_panel)
        control_layout.addWidget(self.btn_options_toggle)

        self.options_panel = QWidget()
        self.options_panel.setVisible(False)
        options_layout = QVBoxLayout(self.options_panel)
        options_layout.setContentsMargins(0, 0, 0, 0)
        options_layout.setSpacing(8)

        # Attach file button
        self.btn_attach = SkeetButton("📎  ATTACH FILE")
        self.btn_attach.clicked.connect(self._attach_file_placeholder)
        options_layout.addWidget(self.btn_attach)

        # Think mode toggle row
        think_row = QHBoxLayout()
        think_row.setSpacing(4)
        lbl_think = QLabel("THINK")
        lbl_think.setStyleSheet(f"color: {FG_DIM}; font-size: 9px; font-weight: bold; letter-spacing: 1px;")
        think_row.addWidget(lbl_think)

        think_style = f"""
            QPushButton {{
                background: #181818; border: 1px solid #333; color: {FG_DIM};
                padding: 4px 10px; font-size: 9px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:checked {{
                background: #222; color: {ACCENT_GOLD}; border: 1px solid {ACCENT_GOLD};
            }}
            QPushButton:hover {{ color: {FG_TEXT}; border: 1px solid {FG_TEXT}; }}
        """
        self.btn_think_off = QPushButton("OFF")
        self.btn_think_off.setCheckable(True)
        self.btn_think_off.setStyleSheet(think_style)
        self.btn_think_std = QPushButton("STD")
        self.btn_think_std.setCheckable(True)
        self.btn_think_std.setStyleSheet(think_style)
        self.btn_think_ext = QPushButton("EXT")
        self.btn_think_ext.setCheckable(True)
        self.btn_think_ext.setStyleSheet(think_style)

        self._think_group = QButtonGroup(self)
        self._think_group.setExclusive(True)
        self._think_group.addButton(self.btn_think_off)
        self._think_group.addButton(self.btn_think_std)
        self._think_group.addButton(self.btn_think_ext)
        if self._thinking_mode:
            self.btn_think_std.setChecked(True)
        else:
            self.btn_think_off.setChecked(True)
        self.btn_think_off.clicked.connect(lambda: self._set_thinking_mode(False, "Off"))
        self.btn_think_std.clicked.connect(lambda: self._set_thinking_mode(True, "Standard"))
        self.btn_think_ext.clicked.connect(lambda: self._set_thinking_mode(True, "Extended"))

        think_row.addWidget(self.btn_think_off)
        think_row.addWidget(self.btn_think_std)
        think_row.addWidget(self.btn_think_ext)
        think_row.addStretch()
        options_layout.addLayout(think_row)

        control_layout.addWidget(self.options_panel)
        control_layout.addStretch()

        # --- ARCHIVE tab ---
        archive_tab = QWidget()
        archive_layout = QVBoxLayout(archive_tab)
        archive_layout.setSpacing(10)

        archive_controls = QHBoxLayout()
        self.btn_save_chat = SkeetButton("SAVE")
        self.btn_save_chat.clicked.connect(self._save_chat_archive)
        self.btn_load_chat = SkeetButton("LOAD")
        self.btn_load_chat.clicked.connect(self._load_chat_archive)
        self.btn_delete_chat = SkeetButton("DELETE")
        self.btn_delete_chat.clicked.connect(self._delete_selected_archive)
        self.btn_clear_chat = SkeetButton("CLEAR")
        self.btn_clear_chat.clicked.connect(lambda: self._clear_current_session(delete_archive=False))
        archive_controls.addWidget(self.btn_save_chat)
        archive_controls.addWidget(self.btn_load_chat)
        archive_controls.addWidget(self.btn_delete_chat)
        archive_controls.addWidget(self.btn_clear_chat)
        archive_controls.addStretch()
        archive_layout.addLayout(archive_controls)

        self.archive_list = QListWidget()
        self.archive_list.setStyleSheet(f"""
            QListWidget {{
                background: {BG_INPUT}; color: {FG_TEXT}; border: 1px solid #222;
                font-family: 'Consolas', monospace; font-size: 10px;
            }}
            QListWidget::item {{ padding: 6px; }}
            QListWidget::item:selected {{ background: #222; color: {ACCENT_GOLD}; }}
            {SCROLLBAR_STYLE}
        """)
        archive_layout.addWidget(self.archive_list)

        self.lbl_behavior = QLabel("BEHAVIOR TAGS")
        self.lbl_behavior.setStyleSheet(
            f"color: #444; font-size: 8px; font-weight: bold; letter-spacing: 1px;"
        )
        self.behavior_tags = BehaviorTagInput([])
        self.behavior_tags.tagsChanged.connect(self._on_behavior_tags_changed)
        self.behavior_tags.setStyleSheet(
            f"background: #111; border: 1px solid #1a1a1a; border-radius: 2px;"
        )
        self.behavior_tags.setMaximumHeight(36)

        # --- SETTINGS tab: AI Configuration + Save/Reset ---
        settings_tab = QWidget()
        settings_layout = QVBoxLayout(settings_tab)
        settings_layout.setSpacing(10)
        settings_layout.addWidget(self.s_temp)
        settings_layout.addWidget(self.s_top)
        settings_layout.addWidget(self.s_tok)
        settings_layout.addWidget(self.s_ctx)
        settings_layout.addWidget(self.lbl_behavior)
        settings_layout.addWidget(self.behavior_tags)
        settings_layout.addLayout(save_row)
        settings_layout.addStretch()

        self.ops_stack.addWidget(control_tab)
        self.ops_stack.addWidget(archive_tab)
        self.ops_stack.addWidget(settings_tab)
        self.btn_tab_control.toggled.connect(lambda checked: self._switch_ops_tab(0, checked))
        self.btn_tab_archive.toggled.connect(lambda checked: self._switch_ops_tab(1, checked))
        self.btn_tab_settings.toggled.connect(lambda checked: self._switch_ops_tab(2, checked))

        operations_group.add_layout(operations_layout)

        chat_group = SkeetGroupBox("TERMINAL")
        chat_layout = QVBoxLayout()
        chat_layout.setSpacing(10)

        self.message_list = QListWidget()
        self.message_list.setVerticalScrollMode(QListWidget.ScrollPerPixel)
        self.message_list.setStyleSheet(f"""
            QListWidget {{
                background: transparent; color: #ccc; border: 1px solid #222;
                font-family: 'Consolas', monospace; font-size: 12px;
            }}
            QListWidget::item {{
                border: none;
                background: transparent;
                padding: 0px;
            }}
            {SCROLLBAR_STYLE}
        """)
        chat_layout.addWidget(self.message_list)
        
        # --- Input toolbar (between separator and input box) ---
        # --- Input row ---
        input_row = QHBoxLayout()
        self.input = QLineEdit()
        self.input.setPlaceholderText("Enter command...")
        self.input.returnPressed.connect(self.handle_send_click)
        self.input.textChanged.connect(self._on_input_changed)
        self.input.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: white; border: 1px solid #333;
                padding: 8px; font-family: 'Verdana'; font-size: 11px;
            }}
            QLineEdit:focus {{ border: 1px solid {ACCENT_GOLD}; }}
        """)
        
        self.btn_send = QPushButton("SEND")
        self.btn_send.setCursor(Qt.PointingHandCursor)
        self.btn_send.setFixedWidth(80)
        self._btn_style_template = """
            QPushButton {{
                background: {bg};
                border: 1px solid {color};
                color: {color};
                padding: 8px;
                font-size: 11px;
                font-weight: bold;
                border-radius: 2px;
            }}
            QPushButton:hover {{ background: {color}; color: black; }}
            QPushButton:pressed {{ background: #b08d2b; }}
        """
        self._set_send_button_state(is_running=False)
        self.btn_send.clicked.connect(self.handle_send_click)

        input_row.addWidget(self.input)
        input_row.addWidget(self.btn_send)
        chat_layout.addLayout(input_row)
        
        chat_group.add_layout(chat_layout)

        right_stack = QSplitter(Qt.Vertical)
        right_stack.setChildrenCollapsible(False)

        trace_group = SkeetGroupBox("REASONING TRACE")
        self.trace = QTextEdit()
        self.trace.setReadOnly(True)
        self.trace.setStyleSheet(f"""
            QTextEdit {{
                background-color: {BG_INPUT};
                color: {FG_TEXT};
                border: 1px solid #222;
                font-family: 'Consolas', monospace;
                font-size: 10px;
            }}
            QTextEdit::viewport {{
                background-color: {BG_INPUT};
            }}
            {SCROLLBAR_STYLE}
        """)
        self.lbl_config_update = QLabel("")
        self.lbl_config_update.setStyleSheet(f"color: {ACCENT_GOLD}; font-size: 10px; font-weight: bold;")
        self.lbl_config_update.hide()
        self._config_update_fade = QTimer(self)
        self._config_update_fade.setSingleShot(True)
        self._config_update_fade.timeout.connect(self.lbl_config_update.hide)
        trace_group.add_widget(self.trace)
        trace_group.add_widget(self.lbl_config_update)

        right_stack.addWidget(trace_group)
        right_stack.addWidget(operations_group)
        right_stack.setStretchFactor(0, 1)
        right_stack.setStretchFactor(1, 1)
        right_stack.setSizes([200, 200])

        main_split.addWidget(chat_group)
        main_split.addWidget(right_stack)
        main_split.setStretchFactor(0, 3)
        main_split.setStretchFactor(1, 2)
        self._active_assistant_started = False
        self._active_assistant_token_count = 0

        self._sync_path_display()
        self._update_load_button_text()
        self._refresh_archive_list()
        self._apply_behavior_prompt(self.config.get("behavior_tags", []))
        self.behavior_tags.set_tags(self.config.get("behavior_tags", []))
        self._set_config_dirty(False)
        if not self._is_model_loaded:
            self._apply_default_limits()

    def send(self):
        txt = self.input.text().strip()
        if not txt:
            return
        self.sig_debug.emit(f"[CHAT] send: text={repr(txt[:60])}, msgs={len(self._current_session['messages'])}")
        self._set_send_button_state(is_running=True)
        self.input.clear()
        user_idx = self._add_message("user", txt)
        self._append_message_widget(user_idx)
        self._start_assistant_stream()
        self.message_list.scrollToBottom()
        self.sig_debug.emit(f"[CHAT] about to emit sig_generate: txt={repr(txt[:60])}")
        self.sig_generate.emit(txt, self._thinking_mode)
        self.sig_debug.emit(f"[CHAT] sig_generate emitted")

    def handle_send_click(self):
        txt = self.input.text().strip()

        if not self._is_running:
            self.send()
            return

        if not txt:
            self._set_send_button_state(is_running=True, stopping=True)
            self.sig_stop.emit()
            return

        self._pending_update_text = txt
        self._awaiting_update_restart = True
        self.btn_send.setEnabled(False)
        self._begin_update_trace(txt)
        self.sig_stop.emit()

    def _set_send_button_state(self, is_running: bool, stopping: bool = False):
        self._is_running = is_running
        if is_running:
            has_input = bool(self.input.text().strip())
            if has_input:
                self.btn_send.setText("UPDATE")
                color = ACCENT_GOLD
            else:
                self.btn_send.setText("■")
                color = FG_ERROR
            self.btn_send.setStyleSheet(
                self._btn_style_template.format(
                    bg=BG_INPUT,
                    color=color,
                )
            )
            self.btn_send.setEnabled(not stopping)
        else:
            self.btn_send.setText("SEND")
            self.btn_send.setStyleSheet(
                self._btn_style_template.format(
                    bg=BG_INPUT,
                    color=ACCENT_GOLD,
                )
            )
            self.btn_send.setEnabled(True)

    def _on_input_changed(self, text):
        if not self._is_running:
            return
        self._set_send_button_state(is_running=True)

    def _send_message(self, text):
        self.input.setText(text)
        self.send()

    def _submit_update(self, update_text):
        self._set_send_button_state(is_running=True)
        self._rewrite_assistant_index = self._active_assistant_index
        partial = "(no output yet)"
        if self._active_assistant_index is not None:
            txt = self._current_session["messages"][self._active_assistant_index]["text"]
            if txt:
                partial = txt

        original = ""
        for msg in reversed(self._current_session["messages"]):
            if msg["role"] == "user":
                original = msg["text"]
                break

        injected = f"""
You were interrupted mid-generation.

Original user request:
{original}

Partial assistant output so far:
{partial}

User update:
{update_text}

Continue from the interruption point. Do not repeat earlier content. Prioritize the user update.
"""

        self.input.clear()
        self._start_update_streaming()
        self.sig_generate.emit(injected, self._thinking_mode)

    def _start_assistant_stream(self):
        self.sig_debug.emit(f"[CHAT] _start_assistant_stream: msgs_before={len(self._current_session['messages'])}")
        self._active_assistant_started = True
        self._active_assistant_token_count = 0

        self._active_assistant_index = self._add_message("assistant", "")
        self._active_widget = self._append_message_widget(self._active_assistant_index)
    

    def _flush_tokens(self):
        if not self._token_buf:
            self._flush_timer.stop()
            return
        chunk = "".join(self._token_buf)
        self._token_buf.clear()
        if self._active_widget is None:
            target_index = self._rewrite_assistant_index
            if target_index is None:
                target_index = self._active_assistant_index
            if target_index is not None:
                self._active_widget = self._widget_for_index(target_index)
        if self._active_widget is None:
            return
        # Check if user is near the bottom before appending (so we don't yank them down)
        sb = self.message_list.verticalScrollBar()
        at_bottom = sb.value() >= sb.maximum() - 40

        self._active_widget.append_token(chunk)
        vw = self.message_list.viewport().width()
        for row in range(self.message_list.count()):
            item = self.message_list.item(row)
            widget = self.message_list.itemWidget(item)
            if widget is self._active_widget:
                if vw > 50:
                    widget.setFixedWidth(vw)
                item.setSizeHint(widget.sizeHint())
                break
        if at_bottom:
            self.message_list.scrollToBottom()

    def append_token(self, t):
        self._token_buf.append(t)
        self._append_assistant_token(t)
        self._update_progress_markers()
        if not self._flush_timer.isActive():
            self._flush_timer.start()

    def on_guard_finished(self, engine_key, task_id):
        if engine_key != getattr(self, "_engine_key", "llm"):
            return
        if not self._current_session.get("messages"):
            return
        try:
            self._save_chat_archive()
        except Exception:
            pass

    def append_trace(self, trace_msg):
        lowered = trace_msg.lower()

        # --- Filter: only show LLM-relevant trace info ---
        # Skip guard internals, status transitions, and noise
        skip_patterns = [
            "guard", "dispatch", "route", "bridge", "dock",
            "addon", "registry", "host", "mount",
        ]
        for pat in skip_patterns:
            if pat in lowered and "error" not in lowered:
                return

        # Categorize what we show
        if "system online" in lowered:
            self._is_model_loaded = True
        elif "model unloaded" in lowered:
            self._is_model_loaded = False

        if "error" in lowered:
            state = "ERROR"
        elif "token" in lowered:
            state = "TOKENIZING"
        elif "inference started" in lowered:
            state = "INFERENCE"
        elif "inference" in lowered and ("complete" in lowered or "aborted" in lowered):
            state = "COMPLETE"
        elif "init backend" in lowered or "system online" in lowered:
            state = "MODEL"
        elif "unload" in lowered or "cancel" in lowered:
            state = "MODEL"
        elif "ctx" in lowered or "context" in lowered:
            state = "CTX"
        else:
            state = "INFO"

        display_msg = trace_msg
        if "→" in display_msg:
            display_msg = display_msg[display_msg.index("→") + 1:].strip()
        elif display_msg.startswith("ERROR"):
            display_msg = display_msg.replace("ERROR:", "").strip()

        self._trace_html(display_msg, state, error=(state == "ERROR"))

    def clear_chat(self):
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)

    def _sync_path_display(self):
        gguf_path = self.config.get("gguf_path")
        if gguf_path:
            self.path_display.setText(gguf_path)
            self.path_display.setToolTip(str(gguf_path))
        else:
            self.path_display.clear()
            self.path_display.setToolTip("")

    def _set_config_dirty(self, dirty=True):
        self._config_dirty = dirty
        self.lbl_config_state.setText("UNSAVED" if dirty else "SAVED")
        self.lbl_config_state.setStyleSheet(
            f"color: {ACCENT_GOLD if dirty else FG_DIM}; font-size: 10px; font-weight: bold;"
        )
        # Save button: gold when dirty (action needed), gray when clean
        if dirty:
            self.btn_save_config.setStyleSheet(f"""
                QPushButton {{ background: #181818; border: 1px solid {ACCENT_GOLD}; color: {ACCENT_GOLD}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                QPushButton:hover {{ background: {ACCENT_GOLD}; color: black; }}
                QPushButton:pressed {{ background: #b08d2b; color: black; }}
            """)
        else:
            self.btn_save_config.setStyleSheet(f"""
                QPushButton {{ background: #181818; border: 1px solid #333; color: {FG_DIM}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                QPushButton:hover {{ background: #222; color: {FG_DIM}; }}
            """)

    def _save_config(self):
        save_config(self.config)
        self._last_config_update = QDateTime.currentDateTime()
        stamp = self._last_config_update.toString("HH:mm:ss")
        self.lbl_config_update.setText(f"USER (UPDATED): {stamp}")
        self.lbl_config_update.show()
        self._config_update_fade.start(2500)
        self._set_config_dirty(False)

    def _update_config_value(self, key, value):
        self.config[key] = value
        self._set_config_dirty(True)

    def _set_slider_limits(self, slider, max_value, value):
        qt_slider = slider.slider
        qt_slider.blockSignals(True)
        if slider.is_int:
            min_value = qt_slider.minimum()
            if max_value < min_value:
                min_value = max_value
            qt_slider.setRange(int(min_value), int(max_value))
            qt_slider.setValue(int(value))
            slider.val_lbl.setText(str(int(value)))
        else:
            min_value = qt_slider.minimum()
            max_scaled = int(max_value * 100)
            if max_scaled < min_value:
                min_value = max_scaled
            qt_slider.setRange(min_value, max_scaled)
            qt_slider.setValue(int(value * 100))
            slider.val_lbl.setText(f"{value:.2f}")
        qt_slider.blockSignals(False)

    def _apply_default_limits(self):
        self._set_slider_limits(
            self.s_ctx,
            DEFAULT_CONFIG["ctx_limit"],
            DEFAULT_CONFIG["ctx_limit"],
        )
        self._set_slider_limits(
            self.s_tok,
            DEFAULT_CONFIG["max_tokens"],
            DEFAULT_CONFIG["max_tokens"],
        )

    def _trace_html(self, msg, tag="INFO", error=False):
        arrow_color = FG_ERROR if error else ACCENT_GOLD
        tag_color = FG_ERROR if error else "#555"
        self.trace.append(
            f"<table width='100%' cellpadding='0' cellspacing='0'><tr>"
            f"<td><span style='color:{arrow_color}'>→</span> {msg}</td>"
            f"<td align='right' style='color:{tag_color}; white-space:nowrap'>[{tag}]</td>"
            f"</tr></table>"
        )

    def _trace_plain(self, msg):
        self.trace.append(f"<span style='color:#555'>{msg}</span>")

    def _on_model_capabilities(self, payload):
        model_ctx_length = payload.get("model_ctx_length")
        if model_ctx_length is None:
            self._apply_default_limits()
            return
        configured_ctx = int(self.config.get("ctx_limit", 8192))
        self._set_slider_limits(self.s_ctx, model_ctx_length, model_ctx_length)
        self._set_slider_limits(
            self.s_tok,
            model_ctx_length,
            min(8192, model_ctx_length),
        )
        # Surface context capacity info in reasoning trace
        if configured_ctx < model_ctx_length:
            pct = int((configured_ctx / model_ctx_length) * 100)
            self._trace_html(
                f"Context: {configured_ctx:,} / {model_ctx_length:,} tokens "
                f"({pct}% of model capacity)",
                "CTX",
            )
            self._trace_html(
                f"Increase context limit in SETTINGS to use full {model_ctx_length:,} capacity",
                "CTX",
            )
        else:
            self._trace_html(
                f"Context: {model_ctx_length:,} tokens (full capacity)",
                "CTX",
            )

    def _on_ctx_limit_changed(self, value):
        self._update_config_value("ctx_limit", int(value))
        self.sig_set_ctx_limit.emit(int(value))

    def _on_behavior_tags_changed(self, tags):
        self._apply_behavior_prompt(tags)

    def _on_thinking_mode_toggled(self, checked):
        self._thinking_mode = bool(checked)
        self.config["thinking_mode"] = self._thinking_mode
        self._set_config_dirty(True)
        self._update_thinking_button_style()

    def _set_thinking_mode(self, enabled, label="Off"):
        self._thinking_mode = enabled
        self.config["thinking_mode"] = enabled
        self._set_config_dirty(True)
        self._update_thinking_button_style()

    def _toggle_options_panel(self):
        self._options_expanded = not self._options_expanded
        self.options_panel.setVisible(self._options_expanded)
        self.btn_options_toggle.setText("▾ OPTIONS" if self._options_expanded else "▸ OPTIONS")

    def _update_thinking_button_style(self):
        # Update the think toggle buttons in the OPTIONS panel
        if hasattr(self, 'btn_think_off'):
            if self._thinking_mode:
                self.btn_think_std.setChecked(True)
            else:
                self.btn_think_off.setChecked(True)

    def _attach_file_placeholder(self):
        """Placeholder for file attachment — backend will be implemented later."""
        pass

    def _reset_config(self):
        """Reset all settings to DEFAULT_CONFIG values."""
        for key, val in DEFAULT_CONFIG.items():
            self.config[key] = val
        self.s_temp.slider.blockSignals(True)
        self.s_top.slider.blockSignals(True)
        self.s_tok.slider.blockSignals(True)
        self.s_ctx.slider.blockSignals(True)
        self.s_temp.slider.setValue(int(DEFAULT_CONFIG["temp"] * 100))
        self.s_temp.val_lbl.setText(f"{DEFAULT_CONFIG['temp']:.2f}")
        self.s_top.slider.setValue(int(DEFAULT_CONFIG["top_p"] * 100))
        self.s_top.val_lbl.setText(f"{DEFAULT_CONFIG['top_p']:.2f}")
        self.s_tok.slider.setValue(int(DEFAULT_CONFIG["max_tokens"]))
        self.s_tok.val_lbl.setText(str(int(DEFAULT_CONFIG["max_tokens"])))
        self.s_ctx.slider.setValue(int(DEFAULT_CONFIG["ctx_limit"]))
        self.s_ctx.val_lbl.setText(str(int(DEFAULT_CONFIG["ctx_limit"])))
        self.s_temp.slider.blockSignals(False)
        self.s_top.slider.blockSignals(False)
        self.s_tok.slider.blockSignals(False)
        self.s_ctx.slider.blockSignals(False)
        self.sig_set_ctx_limit.emit(int(DEFAULT_CONFIG["ctx_limit"]))
        self.behavior_tags.set_tags(DEFAULT_CONFIG.get("behavior_tags", []))
        self._set_thinking_mode(False)
        self._set_config_dirty(True)

    def pick_file(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select GGUF", "", "GGUF (*.gguf)")
        if path:
            self.config["gguf_path"] = path
            self.sig_set_model_path.emit(path)
            self._sync_path_display()
            self._set_config_dirty(True)

    def toggle_load(self):
        if self._is_model_loaded:
            self.sig_unload.emit()
        else:
            self.sig_load.emit()

    def _update_load_button_text(self):
        self.btn_load.setText("UNLOAD MODEL" if self._is_model_loaded else "LOAD MODEL")

    def _request_mutation(self, fn):
        """Run a session mutation safely.

        If a generation is currently running, STOP first, then run `fn` on the next READY.
        This prevents stale indices / widgets during streaming.
        """
        if self._is_running:
            # Cancel any queued UPDATE-restart; mutation wins.
            self._awaiting_update_restart = False
            self._pending_update_text = None
            self._pending_mutation = fn
            self._set_send_button_state(is_running=True, stopping=True)
            self.sig_stop.emit()
            return
        fn()

    def update_status(self, engine_key: str, status: SystemStatus):
        ek_short = engine_key[-8:] if engine_key else "?"
        prev = getattr(self, '_last_status', None)
        transition = f"{prev.name if prev else '?'}→{status.name}" if hasattr(status, 'name') else str(status)
        self.sig_debug.emit(f"[CHAT:{ek_short}] status {transition}, running={self._is_running}, mutation={'yes' if self._pending_mutation else 'no'}")
        if engine_key != getattr(self, "_engine_key", "llm"):
            return
        is_processing = status in (SystemStatus.LOADING, SystemStatus.RUNNING, SystemStatus.UNLOADING)
        self.btn_load.setEnabled(not is_processing)
        if is_processing:
            self.btn_load.setText("PROCESSING...")
        else:
            self._update_load_button_text()
        if status == SystemStatus.READY and self._pending_mutation is not None:
            # Finish transition to READY (stop state) first, then mutate.
            # Keep this path above UPDATE-restart.
            self._set_send_button_state(is_running=False)
            self._rewrite_assistant_index = None
            if self._active_widget is not None:
                self._active_widget.finalize()
            self._active_widget = None
            if self._update_trace_state == "streaming":
                self._finalize_update_progress()
            # If generation ended before any tokens arrived, remove the empty assistant bubble.
            self._cleanup_empty_assistant_if_needed()
            # Reset assistant stream trackers after end-of-generation.
            self._active_assistant_started = False
            self._active_assistant_token_count = 0
            self._suppress_title_regen = False
            pending = self._pending_mutation
            self._pending_mutation = None
            try:
                pending()
            finally:
                self._last_status = status
            return

        if status == SystemStatus.READY and self._awaiting_update_restart:
            self._awaiting_update_restart = False
            self.btn_send.setEnabled(True)

            update_text = self._pending_update_text
            self._pending_update_text = None
            self._submit_update(update_text)
            return
        if status == SystemStatus.RUNNING:
            self._set_send_button_state(is_running=True)
        elif status == SystemStatus.READY:
            if self._last_status == SystemStatus.LOADING:
                self._is_model_loaded = True
                self._update_load_button_text()
            elif self._last_status == SystemStatus.UNLOADING:
                self._is_model_loaded = False
                self._update_load_button_text()
            self._set_send_button_state(is_running=False)
            self._rewrite_assistant_index = None
            if self._active_widget is not None:
                self._active_widget.finalize()
            self._active_widget = None
            if self._update_trace_state == "streaming":
                self._finalize_update_progress()
            # If generation ended before any tokens arrived, remove the empty assistant bubble.
            self._cleanup_empty_assistant_if_needed()
            # Reset assistant stream trackers after end-of-generation.
            self._active_assistant_started = False
            self._active_assistant_token_count = 0
            # Title generation is finalized ONLY on READY.

            # READY is emitted after _on_gen_finish completes and assistant text is final.
            # STOP also transitions to READY; _maybe_generate_title self-guards.
            # Do NOT call this method from token flush, send paths, or mutation handlers.
            if self._pending_mutation is None:
                self._maybe_generate_title()
            self._suppress_title_regen = False
        elif status == SystemStatus.LOADING:
            self._set_send_button_state(is_running=False)
            self.btn_send.setEnabled(False)
        elif status in (SystemStatus.UNLOADING, SystemStatus.ERROR):
            self._is_model_loaded = False
            if not is_processing:
                self._update_load_button_text()

        if status == SystemStatus.READY and not self._is_model_loaded:
            self._apply_default_limits()
        self._last_status = status

    def _switch_ops_tab(self, index, checked):
        if checked:
            self.ops_stack.setCurrentIndex(index)


    def apply_operator(self, operator_data: dict):
        if not isinstance(operator_data, dict):
            return
        config = operator_data.get("config")
        if not isinstance(config, dict):
            return

        slider_values = {
            "temp": float(config.get("temp", self.config.get("temp", 0.7))),
            "top_p": float(config.get("top_p", self.config.get("top_p", 0.9))),
            "max_tokens": int(config.get("max_tokens", self.config.get("max_tokens", 2048))),
            "ctx_limit": int(config.get("ctx_limit", self.config.get("ctx_limit", 8192))),
        }

        self.config.update(config)

        self.s_temp.slider.blockSignals(True)
        self.s_top.slider.blockSignals(True)
        self.s_tok.slider.blockSignals(True)
        self.s_ctx.slider.blockSignals(True)
        self.s_temp.slider.setValue(int(slider_values["temp"] * 100))
        self.s_temp.val_lbl.setText(f"{slider_values['temp']:.2f}")
        self.s_top.slider.setValue(int(slider_values["top_p"] * 100))
        self.s_top.val_lbl.setText(f"{slider_values['top_p']:.2f}")
        self.s_tok.slider.setValue(int(slider_values["max_tokens"]))
        self.s_tok.val_lbl.setText(str(int(slider_values["max_tokens"])))
        self.s_ctx.slider.setValue(int(slider_values["ctx_limit"]))
        self.s_ctx.val_lbl.setText(str(int(slider_values["ctx_limit"])))
        self.s_temp.slider.blockSignals(False)
        self.s_top.slider.blockSignals(False)
        self.s_tok.slider.blockSignals(False)
        self.s_ctx.slider.blockSignals(False)

        self.sig_set_ctx_limit.emit(int(slider_values["ctx_limit"]))

        tags = config.get("behavior_tags", [])
        self.behavior_tags.set_tags(tags if isinstance(tags, list) else [])

        thinking_mode = bool(config.get("thinking_mode", False))
        self._set_thinking_mode(thinking_mode, "Standard" if thinking_mode else "Off")

        gguf_path = config.get("gguf_path")
        if gguf_path:
            self.config["gguf_path"] = gguf_path
            self.sig_set_model_path.emit(str(gguf_path))
        self._sync_path_display()

        # Restore chat messages if snapshot included them, otherwise fresh session
        messages = operator_data.get("messages")
        if isinstance(messages, list) and messages:
            session = self._create_session(
                messages=messages,
                title=operator_data.get("session_title"),
                assistant_tokens=operator_data.get("assistant_tokens", 0),
            )
            self._set_current_session(session, show_reset=True, sync_history=True)
        else:
            self._start_new_session()

        self._set_config_dirty(True)
        self.sig_operator_loaded.emit(str(operator_data.get("name", "")))

    def _start_new_session(self):
        self._title_generated = False
        self._suppress_title_regen = False
        self.trace.clear()
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._trace_plain("--- TRACE RESET ---")

    def _prompt_clear_session(self):
        dialog = QMessageBox(self)
        dialog.setWindowTitle("Clear Session")
        dialog.setText("Choose how to clear the current session.")
        dialog.setStyleSheet(f"""
            QMessageBox {{
                background: {BG_INPUT};
                color: {FG_TEXT};
            }}
            QLabel {{
                color: {FG_TEXT};
            }}
            QPushButton {{
                color: {FG_TEXT};
                background: transparent;
                border: 1px solid #333;
                padding: 6px 12px;
                font-size: 10px;
                font-weight: bold;
                border-radius: 2px;
            }}
            QPushButton:hover {{
                border: 1px solid {ACCENT_GOLD};
                color: {ACCENT_GOLD};
            }}
            QPushButton:checked {{
                border: 1px solid {ACCENT_GOLD};
                color: {ACCENT_GOLD};
            }}
        """)
        btn_clear = dialog.addButton("Clear Logs", QMessageBox.AcceptRole)
        btn_delete = dialog.addButton("Delete Chat", QMessageBox.DestructiveRole)
        dialog.addButton("Cancel", QMessageBox.RejectRole)
        dialog.exec()
        clicked = dialog.clickedButton()
        if clicked == btn_clear:
            self._clear_current_session(delete_archive=False)
        elif clicked == btn_delete:
            self._clear_current_session(delete_archive=True)

    def _clear_current_session(self, delete_archive):
        archive_path = self._current_session.get("archive_path")
        if delete_archive and archive_path:
            try:
                Path(archive_path).unlink()
            except OSError:
                pass
        self.trace.clear()
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._refresh_archive_list()

    def _delete_selected_archive(self):
        item = self.archive_list.currentItem()
        if not item:
            return
        archive_path = Path(item.data(Qt.UserRole))
        try:
            archive_path.unlink()
        except OSError:
            return
        if self._current_session.get("archive_path") == str(archive_path):
            self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._refresh_archive_list()

    def _save_chat_archive(self):
        session = self._current_session
        messages = session["messages"]
        now = self._now_iso()
        created_at = session.get("created_at") or now
        updated_at = now
        title = self._current_session.get("title") or self._derive_title(messages)
        summary = self._build_summary(messages)
        message_payload = []
        for idx, msg in enumerate(messages, start=1):
            message_payload.append({
                "i": idx,
                "time": msg.get("time") or now,
                "role": msg.get("role", "user"),
                "text": msg.get("text", "")
            })
        meta = {
            "title": title,
            "created_at": created_at,
            "updated_at": updated_at,
            "message_count": len(message_payload),
            "assistant_tokens": int(session.get("assistant_tokens", 0)),
            "summary": summary
        }
        payload = {"meta": meta, "messages": message_payload}
        archive_path = session.get("archive_path")
        if not archive_path:
            slug = self._slugify(title)
            stamp = now.replace(":", "-").replace(".", "-")
            archive_path = self._archive_dir / f"{slug}_{stamp}.json"
        else:
            archive_path = Path(archive_path)
        archive_path.parent.mkdir(parents=True, exist_ok=True)
        with archive_path.open("w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2)
        session["archive_path"] = str(archive_path)
        session["created_at"] = created_at
        session["updated_at"] = updated_at
        session["summary"] = summary
        self._refresh_archive_list()

    def _load_chat_archive(self):
        item = self.archive_list.currentItem()
        if not item:
            return
        archive_path = Path(item.data(Qt.UserRole))
        try:
            with archive_path.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
        except Exception:
            QMessageBox.warning(self, "Load Failed", "Could not read archive file.")
            return
        meta = data.get("meta", {})
        messages = []
        for msg in data.get("messages", []):
            role = msg.get("role", "user")
            text = msg.get("text", "")
            time = msg.get("time", meta.get("updated_at", self._now_iso()))
            messages.append({"i": msg.get("i"), "time": time, "role": role, "text": text})
        session = self._create_session(
            messages=messages,
            created_at=meta.get("created_at"),
            updated_at=meta.get("updated_at"),
            archive_path=str(archive_path),
            summary=meta.get("summary", []),
            title=meta.get("title"),
            assistant_tokens=int(meta.get("assistant_tokens", meta.get("token_count", 0)))
        )
        self._set_current_session(session, show_reset=False, sync_history=True)
        self._notify_header_update()

    def _refresh_archive_list(self):
        self.archive_list.clear()
        items = []
        for path in sorted(self._archive_dir.glob("*.json")):
            try:
                with path.open("r", encoding="utf-8") as handle:
                    data = json.load(handle)
            except Exception:
                continue
            meta = data.get("meta", {})
            title = meta.get("title", path.stem)
            summary = meta.get("summary", [])
            tooltip = "\n".join(summary) if summary else title
            updated_at = meta.get("updated_at", "")
            message_count = meta.get("message_count", len(data.get("messages", [])))
            assistant_tokens = int(meta.get("assistant_tokens", meta.get("token_count", 0)))
            items.append((updated_at, title, message_count, assistant_tokens, str(path), tooltip))
        items.sort(key=lambda item: item[0], reverse=True)
        for updated_at, title, message_count, assistant_tokens, path, tooltip in items:
            date_label = updated_at.split("T")[0] if updated_at else "Unknown date"
            subtext = f"{date_label} • {message_count} msgs • {assistant_tokens} assistant tokens"
            list_item = QListWidgetItem(f"{title}\n{subtext}")
            list_item.setData(Qt.UserRole, path)
            list_item.setToolTip(tooltip)
            self.archive_list.addItem(list_item)

    def _create_session(self, messages=None, created_at=None, updated_at=None, archive_path=None, summary=None, title=None, assistant_tokens=0):
        self._session_counter += 1
        now = self._now_iso()
        return {
            "id": self._session_counter,
            "created_at": created_at or now,
            "updated_at": updated_at or now,
            "messages": messages or [],
            "archive_path": archive_path,
            "summary": summary or [],
            "title": title,
            "assistant_tokens": int(assistant_tokens),
        }

    def _set_current_session(self, session, show_reset=False, sync_history=False):
        self._current_session = session
        self._undo_snapshot = None
        self._active_assistant_index = None
        self._rewrite_assistant_index = None
        self._active_widget = None
        self._title_generated = bool(session.get("title"))
        self._suppress_title_regen = False
        self._render_session(session, show_reset=show_reset)
        if sync_history:
            history = self._build_engine_history_from_session()
            self.sig_sync_history.emit(history)
        self._notify_header_update()

    def _build_engine_history_from_session(self):
        """
        Convert _current_session["messages"] into engine-ready history.

        Always include:
          {"role": "system", "content": MASTER_PROMPT}

        Then append each session message as:
          {"role": msg["role"], "content": msg["text"]}

        Behavior tags are NOT included here.
        Engine recompiles system prompt at generation time.
        """
        history = [{"role": "system", "content": MASTER_PROMPT}]
        for msg in self._current_session.get("messages", []):
            if not isinstance(msg, dict):
                continue
            role = msg.get("role")
            text = msg.get("text")
            if not isinstance(role, str) or not isinstance(text, str):
                continue
            history.append({"role": role, "content": text})
        return history

    def _snapshot_session(self):
        self._undo_snapshot = [dict(m) for m in self._current_session["messages"]]

    def _undo_last_mutation(self):
        if not self._undo_snapshot:
            return
        self._current_session["messages"] = self._undo_snapshot
        self._undo_snapshot = None
        self._render_session()
        self.sig_sync_history.emit(
            self._build_engine_history_from_session()
        )

    def _delete_from_index(self, idx: int):
        self.sig_debug.emit(f"[CHAT] _delete_from_index: idx={idx}, msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_delete():
            self._snapshot_session()
            msgs = self._current_session["messages"]
            if idx < 0 or idx >= len(msgs):
                return
            del msgs[idx:]
            # Reset any stale streaming pointers.
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )

        self._request_mutation(_do_delete)

    def _edit_from_index(self, idx: int):
        self.sig_debug.emit(f"[CHAT] _edit_from_index: idx={idx}, msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_edit():
            msgs = self._current_session["messages"]
            if idx < 0 or idx >= len(msgs):
                return
            text = msgs[idx].get("text", "")
            self._suppress_title_regen = True
            # Inline delete to avoid nested mutation requests.
            self._snapshot_session()
            del msgs[idx:]
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )
            self.input.setText(text)

        self._request_mutation(_do_edit)

    def _regen_last_assistant(self):
        self.sig_debug.emit(f"[CHAT] _regen_last_assistant: msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_regen():
            msgs = self._current_session["messages"]
            if not msgs or msgs[-1].get("role") != "assistant":
                return
            self._snapshot_session()
            self._suppress_title_regen = True
            del msgs[-1]
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )

            for m in reversed(msgs):
                if m.get("role") == "user":
                    self._set_send_button_state(is_running=True)
                    self._start_assistant_stream()
                    self.message_list.scrollToBottom()
                    self.sig_generate.emit(m.get("text", ""), self._thinking_mode)
                    break

        self._request_mutation(_do_regen)

    def _render_session(self, session=None, show_reset=False):
        if session is None:
            session = self._current_session
        self.sig_debug.emit(f"[CHAT] _render_session: msgs={len(session['messages'])}, show_reset={show_reset}")
        self.message_list.clear()
        self._active_widget = None
        if not session["messages"]:
            return
        for idx, _msg in enumerate(session["messages"]):
            self._append_message_widget(idx)
        self.message_list.scrollToBottom()

    def _append_message_widget(self, idx: int, role=None, text=None, timestamp=None):
        if idx >= 0:
            msg = self._current_session["messages"][idx]
            role = msg.get("role", "")
            text = msg.get("text", "")
            timestamp = msg.get("time", "")
        item = QListWidgetItem()
        widget = MessageWidget(idx, role or "", text or "", timestamp or "")
        widget.sig_delete.connect(self._delete_from_index)
        widget.sig_edit.connect(self._edit_from_index)
        widget.sig_regen.connect(lambda _idx: self._regen_last_assistant())
        vw = self.message_list.viewport().width()
        if vw > 50:
            widget.setFixedWidth(vw)
        item.setSizeHint(widget.sizeHint())
        self.message_list.addItem(item)
        self.message_list.setItemWidget(item, widget)
        return widget

    def _widget_for_index(self, idx: int):
        for row in range(self.message_list.count()):
            item = self.message_list.item(row)
            widget = self.message_list.itemWidget(item)
            if isinstance(widget, MessageWidget) and getattr(widget, "_index", None) == idx:
                return widget
        return None

    def _apply_behavior_prompt(self, tags):
        cleaned = [tag.strip() for tag in tags if tag.strip()]
        self.config["behavior_tags"] = cleaned
        self._set_config_dirty(True)

    def _begin_update_trace(self, update_text):
        self._update_trace_state = "requested"
        self._update_token_count = 0
        self._update_progress_index = 0
        self._trace_html("UPDATE REQUESTED", "UPDATE")
        self._trace_html(f'USER PATCH: "{update_text}"', "UPDATE")

    def _start_update_streaming(self):
        self._update_trace_state = "streaming"
        self._update_token_count = 0
        self._update_progress_index = 0

    def _update_progress_markers(self):
        if self._update_trace_state != "streaming":
            return
        self._update_token_count += 1
        thresholds = [25, 50, 100]
        pct = min(
            100,
            int((self._update_token_count / self.config["max_tokens"]) * 100),
        )
        while self._update_progress_index < len(thresholds):
            if pct >= thresholds[self._update_progress_index]:
                percent = thresholds[self._update_progress_index]
                self._trace_html(f"UPDATE PROGRESS {percent}%", "UPDATE")
                self._update_progress_index += 1
                continue
            break

    def _finalize_update_progress(self):
        if self._update_trace_state != "streaming":
            return
        thresholds = [25, 50, 100]
        while self._update_progress_index < len(thresholds):
            percent = thresholds[self._update_progress_index]
            self._trace_html(f"UPDATE PROGRESS {percent}%", "UPDATE")
            self._update_progress_index += 1
        self._update_trace_state = None

    def _add_message(self, role, text):
        now = self._now_iso()
        message = {
            "i": len(self._current_session["messages"]) + 1,
            "time": now,
            "role": role,
            "text": text
        }
        self._current_session["messages"].append(message)
        self._current_session["updated_at"] = now
        return len(self._current_session["messages"]) - 1

    def _append_assistant_token(self, token):
        target_index = self._rewrite_assistant_index
        if target_index is None:
            target_index = self._active_assistant_index
        if target_index is None:
            return

        msg = self._current_session["messages"][target_index]
        msg["text"] += token
        self._active_assistant_token_count += 1
        msg["time"] = self._now_iso()
        self._current_session["updated_at"] = msg["time"]
        self._current_session["assistant_tokens"] = int(self._current_session.get("assistant_tokens", 0)) + 1


    def _cleanup_empty_assistant_if_needed(self):
        """Remove a placeholder assistant message if generation ended before any tokens arrived."""
        idx = self._active_assistant_index
        if idx is None:
            return
        if not getattr(self, "_active_assistant_started", False):
            return
        if int(getattr(self, "_active_assistant_token_count", 0)) > 0:
            return

        msgs = self._current_session.get("messages", [])
        if 0 <= idx < len(msgs):
            msg = msgs[idx]
            if msg.get("role") == "assistant" and (msg.get("text") or "") == "":
                del msgs[idx]
                # After deletion, any stored indices are stale.
                self._active_assistant_index = None
                self._rewrite_assistant_index = None
                self._active_widget = None
                self._token_buf.clear()
                if self._flush_timer.isActive():
                    self._flush_timer.stop()
                self._render_session()
                self.sig_sync_history.emit(self._build_engine_history_from_session())
                return
    def _maybe_generate_title(self):
        if self._suppress_title_regen:
            return
        if self._title_generated:
            return
        if self._current_session.get("title"):
            self._title_generated = True
            return
        if not any(m.get("role") == "user" and m.get("text", "").strip() for m in self._current_session["messages"]):
            return
        title = self._derive_title(self._current_session["messages"])
        self._current_session["title"] = title
        self._title_generated = True
        self._notify_header_update()

    def _topic_dominant(self):
        user_text = " ".join([m.get("text", "") for m in self._current_session["messages"] if m.get("role") == "user"])
        words = [w.lower() for w in re.findall(r"[a-zA-Z]{4,}", user_text)]
        if not words:
            return False
        counts = {}
        for word in words:
            counts[word] = counts.get(word, 0) + 1
        return max(counts.values()) >= 3

    def _notify_header_update(self):
        dt = QDateTime.currentDateTime().toString("ddd • HH:mm")
        title = self._current_session.get("title") or self._derive_title(self._current_session.get("messages", []))
        self.ui_bridge.sig_terminal_header.emit(getattr(self, "_mod_id", ""), title, dt)

    def _derive_title(self, messages):
        stopwords = {
            "a", "an", "and", "are", "as", "at", "be", "but", "by", "for", "from",
            "how", "i", "if", "in", "into", "is", "it", "me", "my", "of", "on", "or",
            "our", "please", "so", "that", "the", "their", "them", "then", "there", "these",
            "this", "to", "us", "we", "what", "when", "where", "which", "who", "why", "with",
            "you", "your",
        }
        user_texts = []
        for msg in messages:
            if msg.get("role") != "user":
                continue
            text = " ".join((msg.get("text") or "").lower().split())
            if text:
                user_texts.append(text)
            if len(user_texts) == 3:
                break

        if not user_texts:
            return "chat"

        candidates = []
        counts = {}
        for text in user_texts:
            for token in re.findall(r"[a-z0-9]+", text):
                if token in stopwords or len(token) < 3:
                    continue
                if token not in counts:
                    candidates.append(token)
                    counts[token] = 0
                counts[token] += 1

        ranked = sorted(candidates, key=lambda token: (-counts[token], candidates.index(token)))
        title_tokens = ranked[:6]
        title = " ".join(title_tokens)
        title = re.sub(r"\s+", " ", title).strip()
        title = re.sub(r"[^a-z0-9\- ]+", "", title)
        if len(title) > 40:
            title = title[:40].rstrip()
        return title or "chat"

    def _build_summary(self, messages):
        summary = []
        title = self._current_session.get("title") or self._derive_title(messages)
        summary.append(f"Title: {title}")
        user_msgs = [m["text"] for m in messages if m.get("role") == "user" and m.get("text")]
        assistant_msgs = [m["text"] for m in messages if m.get("role") == "assistant" and m.get("text")]

        def _trim(text, limit=120):
            return text if len(text) <= limit else f"{text[:limit]}…"

        for msg in user_msgs[-3:]:
            summary.append(f"User: {_trim(msg)}")
        for msg in assistant_msgs[-3:]:
            summary.append(f"Assistant: {_trim(msg)}")
        if len(summary) < 3:
            summary.append(f"Messages: {len(messages)}")
        if len(summary) < 3:
            summary.append("Summary: Not enough messages yet.")
        return summary[:6]

    def _slugify(self, text):
        slug = re.sub(r"[^a-z0-9]+", "-", text.lower()).strip("-")
        return slug or "chat"

    def _now_iso(self):
        return datetime.now(timezone.utc).isoformat()

    def _get_archive_dir(self):
        return ARCHIVE_DIR


================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\pages\databank.py
================================================================================

import os
import shutil
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, 
    QTreeView, QHeaderView, QFileSystemModel, QInputDialog, 
    QLabel, QMessageBox, QMenu
)
from PySide6.QtCore import QDir, Qt
from PySide6.QtGui import QAction

from ui.components.atoms import SkeetGroupBox, SkeetButton
from core.style import BG_INPUT, BORDER_DARK, FG_DIM, ACCENT_GOLD, BG_MAIN, FG_TEXT

class TerminalFileTree(QTreeView):
    def __init__(self, start_path):
        super().__init__()
        self.model = QFileSystemModel()
        
        self.model.setReadOnly(False)
        self.model.setFilter(QDir.AllEntries | QDir.NoDotAndDotDot)
        self.model.setNameFilterDisables(False)
        
        self.change_root(start_path)
        self.setModel(self.model)

        self.setDragEnabled(True) 
        self.setDragDropMode(QTreeView.DragOnly)

        self.setStyleSheet(f"""
            QTreeView {{
                background: {BG_INPUT};
                color: #ccc;
                border: 1px solid {BORDER_DARK};
                font-family: 'Consolas', monospace;
                font-size: 12px;
                outline: 0;
            }}
            QTreeView::item {{ padding: 4px; }}
            QTreeView::item:hover {{ background: #222; }}
            QTreeView::item:selected {{ background: {ACCENT_GOLD}; color: black; }}
            
            QHeaderView::section {{
                background: #111;
                color: {FG_DIM};
                border: none;
                padding: 4px;
                font-weight: bold;
            }}
        """)
        
        self.header().setSectionResizeMode(0, QHeaderView.Stretch)
        self.setColumnWidth(1, 80)
        self.setColumnHidden(2, True) 
        self.setColumnHidden(3, True) 
        self.setAnimated(False)
        self.setIndentation(20)
        self.setSortingEnabled(False)
        self.setContextMenuPolicy(Qt.CustomContextMenu)

    def change_root(self, path):
        abs_path = os.path.abspath(path)
        if not os.path.exists(abs_path):
            try:
                os.makedirs(abs_path)
            except OSError:
                pass 
                
        self.model.setRootPath(abs_path)
        self.setRootIndex(self.model.index(abs_path))

class PageFiles(QWidget):
    def __init__(self, state):
        super().__init__()
        self.state = state
        
        base_dir = "C:\\Models\\knowledge_base"
        if not os.path.exists("C:\\Models"):
            base_dir = os.path.join(os.getcwd(), "knowledge_base")
            
        self.current_path = base_dir
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        
        grp = SkeetGroupBox("DATABANK")
        gl = QVBoxLayout()
        gl.setSpacing(10)
        
        # --- TOP EXPLORER BAR ---
        nav_bar = QHBoxLayout()
        
        self.inp_path = QLineEdit()
        self.inp_path.setText(self.current_path)
        self.inp_path.setPlaceholderText("Path...")
        self.inp_path.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {ACCENT_GOLD}; 
                border: 1px solid #333; padding: 6px; font-family: 'Consolas';
            }}
        """)
        self.inp_path.returnPressed.connect(self.navigate_to_path)
        
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText("Search files...")
        self.inp_search.setFixedWidth(200)
        self.inp_search.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: white; 
                border: 1px solid #333; padding: 6px;
            }}
        """)
        self.inp_search.textChanged.connect(self.on_search)
        
        nav_bar.addWidget(QLabel("📂"))
        nav_bar.addWidget(self.inp_path)
        nav_bar.addSpacing(10)
        nav_bar.addWidget(QLabel("🔍"))
        nav_bar.addWidget(self.inp_search)
        gl.addLayout(nav_bar)
        
        # --- FILE TREE ---
        self.tree = TerminalFileTree(self.current_path)
        self.tree.customContextMenuRequested.connect(self.open_menu)
        self.tree.clicked.connect(self.on_click_item) 
        gl.addWidget(self.tree)
        
        # --- BOTTOM ACTION BAR ---
        actions = QHBoxLayout()
        
        btn_add = SkeetButton("+ MKDIR")
        btn_add.clicked.connect(self.new_folder)
        
        btn_del = SkeetButton("× DELETE")
        btn_del.clicked.connect(self.delete_item)
        
        btn_ref = SkeetButton("⟳ REFRESH")
        btn_ref.clicked.connect(self.refresh)
        
        self.lbl_status = QLabel("Ready")
        self.lbl_status.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        
        actions.addWidget(btn_add)
        actions.addWidget(btn_del)
        actions.addWidget(btn_ref)
        actions.addStretch()
        actions.addWidget(self.lbl_status)
        
        gl.addLayout(actions)
        grp.add_layout(gl)
        layout.addWidget(grp)

    def navigate_to_path(self):
        new_path = self.inp_path.text()
        if os.path.exists(new_path):
            self.current_path = new_path
            self.tree.change_root(new_path)
            self.lbl_status.setText(f"Navigated to: {new_path}")
        else:
            self.lbl_status.setText("Error: Path does not exist")

    def on_click_item(self, index):
        path = self.tree.model.filePath(index)
        if os.path.isdir(path):
            self.inp_path.setText(path)

    def refresh(self):
        self.tree.change_root(self.current_path)
        self.lbl_status.setText("Refreshed")

    def on_search(self, text):
        if text:
            self.tree.model.setNameFilters([f"*{text}*"])
        else:
            self.tree.model.setNameFilters([])

    def get_selected_path(self):
        indexes = self.tree.selectedIndexes()
        if indexes:
            return self.tree.model.filePath(indexes[0])
        return self.current_path

    def new_folder(self):
        target_path = self.get_selected_path()
        if os.path.isfile(target_path):
            target_path = os.path.dirname(target_path)
            
        name, ok = self.ask_input("New Folder", "Folder Name:")
        if ok and name:
            new_dir = os.path.join(target_path, name)
            try:
                os.makedirs(new_dir, exist_ok=True)
                self.lbl_status.setText(f"Created: {name}")
            except Exception as e:
                self.lbl_status.setText(f"Error: {e}")

    def delete_item(self):
        target = self.get_selected_path()
        if target == self.current_path:
            self.lbl_status.setText("Cannot delete root folder")
            return
            
        if os.path.exists(target):
            msg = QMessageBox(self)
            msg.setWindowTitle("Confirm Delete")
            msg.setText(f"Are you sure you want to delete:\\n{os.path.basename(target)}?")
            msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            msg.setStyleSheet(f"""
                QMessageBox {{ background: {BG_MAIN}; }}
                QLabel {{ color: {FG_TEXT}; }}
                QPushButton {{ background: #222; color: #ccc; border: 1px solid #444; padding: 5px; }}
            """)
            if msg.exec() == QMessageBox.Yes:
                try:
                    if os.path.isdir(target):
                        shutil.rmtree(target)
                    else:
                        os.remove(target)
                    self.lbl_status.setText("Item deleted")
                except Exception as e:
                    self.lbl_status.setText(f"Delete Error: {e}")

    def open_menu(self, position):
        menu = QMenu()
        menu.setStyleSheet(f"""
            QMenu {{ background: #111; color: {FG_TEXT}; border: 1px solid {ACCENT_GOLD}; }}
            QMenu::item:selected {{ background: {ACCENT_GOLD}; color: black; }}
        """)
        
        act_del = QAction("Delete", self)
        act_del.triggered.connect(self.delete_item)
        
        act_new = QAction("New Folder", self)
        act_new.triggered.connect(self.new_folder)
        
        menu.addAction(act_new)
        menu.addAction(act_del)
        menu.exec(self.tree.viewport().mapToGlobal(position))

    def ask_input(self, title, label):
        dlg = QInputDialog(self)
        dlg.setWindowTitle(title)
        dlg.setLabelText(label)
        dlg.setStyleSheet(f"""
            QDialog {{ background: {BG_MAIN}; border: 1px solid {ACCENT_GOLD}; }}
            QLabel {{ color: {FG_TEXT}; }}
            QLineEdit {{ background: {BG_INPUT}; color: white; border: 1px solid #333; }}
            QPushButton {{ background: #222; color: #ccc; border: 1px solid #444; padding: 5px; }}
        """)
        ok = dlg.exec()
        return dlg.textValue(), (ok == 1)



================================================================================
FILE: .\.claude\worktrees\cool-mayer\ui\pages\hub.py
================================================================================

from PySide6.QtCore import Signal, Qt
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QLabel,
    QGridLayout,
    QFrame,
    QPushButton,
    QHBoxLayout,
    QDialog,
    QLineEdit,
    QMessageBox,
)

from core.operators import OperatorManager
from core.style import (
    BG_GROUP, BG_INPUT, BG_MAIN, FG_TEXT, FG_DIM, ACCENT_GOLD,
    BORDER_DARK, GLASS_BG, GLASS_BORDER, GLASS_HOVER,
)
from ui.components.atoms import SkeetButton


class _NameDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("New Operator")
        self.setModal(True)
        self.setStyleSheet(f"""
            QDialog {{ background: {BG_INPUT}; color: {FG_TEXT}; }}
            QLineEdit {{ background: #101010; color: {FG_TEXT}; border: 1px solid #333; padding: 6px; }}
            QPushButton {{ color: {FG_TEXT}; background: transparent; border: 1px solid #333; padding: 6px 12px; }}
            QPushButton:hover {{ border: 1px solid {ACCENT_GOLD}; color: {ACCENT_GOLD}; }}
        """)
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Operator name:"))
        self.input = QLineEdit()
        layout.addWidget(self.input)
        row = QHBoxLayout()
        row.addStretch()
        ok_btn = SkeetButton("OK")
        cancel_btn = SkeetButton("CANCEL")
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)
        row.addWidget(ok_btn)
        row.addWidget(cancel_btn)
        layout.addLayout(row)

    def value(self) -> str:
        return self.input.text().strip()

class _OperatorCard(QPushButton):
    """Glassmorphic operator card with structured info."""
    sig_double_clicked = Signal(str)

    def __init__(self, name: str, gguf_path: str, tag_count: int, module_count: int = 0):
        super().__init__()
        self.op_name = name
        self.setCursor(Qt.PointingHandCursor)
        self.setMinimumHeight(80)
        self.setMinimumWidth(180)
        self._selected = False

        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 10, 12, 10)
        layout.setSpacing(4)

        lbl_name = QLabel(name.upper())
        lbl_name.setStyleSheet(f"color: {FG_TEXT}; font-size: 11px; font-weight: bold; background: transparent; letter-spacing: 1px;")
        layout.addWidget(lbl_name)

        lbl_model = QLabel(gguf_path)
        lbl_model.setStyleSheet(f"color: {FG_DIM}; font-size: 9px; background: transparent;")
        lbl_model.setWordWrap(True)
        layout.addWidget(lbl_model)

        info_parts = []
        if module_count > 0:
            info_parts.append(f"{module_count} module{'s' if module_count != 1 else ''}")
        if tag_count > 0:
            info_parts.append(f"{tag_count} tag{'s' if tag_count != 1 else ''}")
        lbl_info = QLabel(" · ".join(info_parts) if info_parts else "empty")
        lbl_info.setStyleSheet(f"color: #444; font-size: 9px; background: transparent;")
        layout.addWidget(lbl_info)

        layout.addStretch()
        self._apply_style(False)

    def _apply_style(self, selected: bool):
        self._selected = selected
        border = ACCENT_GOLD if selected else BORDER_DARK
        bg = "#1a1a1a" if selected else BG_INPUT
        self.setStyleSheet(f"""
            _OperatorCard {{
                background: {bg};
                border: 1px solid {border};
                border-radius: 3px;
            }}
            _OperatorCard:hover {{
                border: 1px solid {ACCENT_GOLD};
                background: #141414;
            }}
        """)

    def set_selected(self, selected: bool):
        self._apply_style(selected)

    def mouseDoubleClickEvent(self, event):
        self.sig_double_clicked.emit(self.op_name)


class PageHub(QWidget):
    sig_load_operator = Signal(str)
    sig_save_operator = Signal(str, dict)

    def __init__(self, config_provider=None, operator_manager: OperatorManager | None = None):
        super().__init__()
        self._operator_manager = operator_manager or OperatorManager()
        self._config_provider = config_provider
        self._selected_name: str | None = None
        self._cards: dict[str, _OperatorCard] = {}

        self.setStyleSheet(f"background: {BG_MAIN};")

        layout = QVBoxLayout(self)
        layout.setContentsMargins(30, 30, 30, 30)
        layout.setSpacing(0)

        # --- Welcome header ---
        header = QWidget()
        header.setStyleSheet("background: transparent;")
        header_layout = QVBoxLayout(header)
        header_layout.setContentsMargins(0, 0, 0, 20)
        header_layout.setSpacing(4)

        lbl_welcome = QLabel("MONOLITH")
        lbl_welcome.setStyleSheet(
            f"color: {ACCENT_GOLD}; font-size: 20px; font-weight: bold; "
            f"letter-spacing: 4px; background: transparent;"
        )
        header_layout.addWidget(lbl_welcome)

        lbl_sub = QLabel("Select an operator to restore your workspace, or create a new one.")
        lbl_sub.setStyleSheet(f"color: {FG_DIM}; font-size: 10px; background: transparent;")
        header_layout.addWidget(lbl_sub)

        layout.addWidget(header)

        # --- Separator ---
        sep = QFrame()
        sep.setFixedHeight(1)
        sep.setStyleSheet(f"background: {BORDER_DARK};")
        layout.addWidget(sep)
        layout.addSpacing(16)

        # --- Operator label ---
        ops_header = QHBoxLayout()
        lbl_ops = QLabel("OPERATORS")
        lbl_ops.setStyleSheet(
            f"color: {FG_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        ops_header.addWidget(lbl_ops)
        ops_header.addStretch()
        layout.addLayout(ops_header)
        layout.addSpacing(10)

        # --- Card grid ---
        self.grid_wrap = QWidget()
        self.grid_wrap.setStyleSheet("background: transparent;")
        self.grid = QGridLayout(self.grid_wrap)
        self.grid.setContentsMargins(0, 0, 0, 0)
        self.grid.setSpacing(10)
        layout.addWidget(self.grid_wrap, 1)

        # --- Empty state ---
        self.empty_label = QLabel("No operators saved yet.\nCreate one to snapshot your current workspace.")
        self.empty_label.setAlignment(Qt.AlignCenter)
        self.empty_label.setStyleSheet(f"color: #333; font-size: 11px; padding: 40px; background: transparent;")
        self.grid.addWidget(self.empty_label, 0, 0, 1, 3, Qt.AlignCenter)

        layout.addStretch()

        # --- Bottom action bar ---
        sep2 = QFrame()
        sep2.setFixedHeight(1)
        sep2.setStyleSheet(f"background: {BORDER_DARK};")
        layout.addWidget(sep2)
        layout.addSpacing(10)

        btn_row = QHBoxLayout()
        btn_row.setSpacing(8)
        self.btn_new = SkeetButton("＋ NEW")
        self.btn_new.setFixedHeight(28)
        self.btn_new.clicked.connect(self._create_operator_from_current)
        self.btn_load = SkeetButton("▶ LOAD")
        self.btn_load.setFixedHeight(28)
        self.btn_load.clicked.connect(self._load_selected)
        self.btn_load.setEnabled(False)
        self.btn_delete = SkeetButton("— DELETE")
        self.btn_delete.setFixedHeight(28)
        self.btn_delete.clicked.connect(self._delete_selected)
        self.btn_delete.setEnabled(False)
        btn_row.addWidget(self.btn_new)
        btn_row.addWidget(self.btn_load)
        btn_row.addWidget(self.btn_delete)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.refresh_cards()

    def refresh_cards(self):
        # Clear existing cards (but not empty_label — we control it separately)
        for card in self._cards.values():
            self.grid.removeWidget(card)
            card.deleteLater()
        self._cards.clear()

        operators = self._operator_manager.list_operators()

        self.empty_label.setVisible(len(operators) == 0)

        for idx, item in enumerate(operators):
            name = item["name"]
            try:
                data = self._operator_manager.load_operator(name)
            except Exception:
                continue
            # New format: modules list; legacy: top-level config
            modules = data.get("modules", [])
            module_count = len(modules)
            if modules:
                # Find first terminal's config for display
                term = next((m for m in modules if m.get("addon_id") == "terminal"), None)
                cfg = term.get("config", {}) if term else {}
            else:
                cfg = data.get("config", {})
            gguf_path = self._truncate_path(cfg.get("gguf_path"))
            tag_count = len(cfg.get("behavior_tags") or [])

            card = _OperatorCard(name, gguf_path, tag_count, module_count)
            card.clicked.connect(lambda _checked=False, op_name=name: self._on_card_clicked(op_name))
            card.sig_double_clicked.connect(self._load_operator)
            row, col = divmod(idx, 3)
            self.grid.addWidget(card, row + 1, col)  # +1 to skip row 0 (empty_label)
            self._cards[name] = card

        if self._selected_name not in self._cards:
            self._selected_name = None
            self.btn_load.setEnabled(False)
            self.btn_delete.setEnabled(False)

    def _on_card_clicked(self, name: str):
        self._selected_name = name
        for op_name, card in self._cards.items():
            card.set_selected(op_name == name)
        self.btn_load.setEnabled(True)
        self.btn_delete.setEnabled(True)

    def _load_selected(self):
        if self._selected_name:
            self.sig_load_operator.emit(self._selected_name)

    def _load_operator(self, name: str):
        self._on_card_clicked(name)
        self.sig_load_operator.emit(name)

    def _create_operator_from_current(self):
        if self._config_provider is None:
            QMessageBox.warning(self, "Operator", "Terminal page is not mounted.")
            return
        dialog = _NameDialog(self)
        if dialog.exec() != QDialog.Accepted:
            return
        clean_name = dialog.value()
        if not clean_name:
            return
        snapshot = dict(self._config_provider() or {})
        data = {"name": clean_name, "layout": {}, "geometry": {}}
        data.update(snapshot)  # merges "modules" and "module_order" into top level
        # Keep a "config" key for backward compat if snapshot has no modules
        if "modules" not in data:
            data["config"] = snapshot
        self.sig_save_operator.emit(clean_name, data)
        self.refresh_cards()

    def _delete_selected(self):
        if not self._selected_name:
            return
        if not self._operator_manager.delete_operator(self._selected_name):
            QMessageBox.warning(self, "Operator", "Delete failed.")
            return
        self._selected_name = None
        self.btn_load.setEnabled(False)
        self.btn_delete.setEnabled(False)
        self.refresh_cards()

    def _truncate_path(self, value) -> str:
        if not value:
            return "No model path"
        path = str(value)
        if len(path) <= 42:
            return path
        return f"...{path[-39:]}"



================================================================================
FILE: .\.claude\worktrees\gallant-allen\.git
================================================================================

gitdir: C:/Users/ascan/Desktop/Monolith/.git/worktrees/gallant-allen



================================================================================
FILE: .\.claude\worktrees\gallant-allen\.gitignore
================================================================================

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python

# Virtual Environment
venv/
env/
ENV/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Monolith specific
ui/addons/configs/
*.db
*.log
.env

# Model files (optional - user downloads these)
*.gguf
*.safetensors
*.ckpt
*.pth

# Generated content
generated_images/
generated_audio/
chat_history/



================================================================================
FILE: .\.claude\worktrees\gallant-allen\bootstrap.py
================================================================================

import sys

from PySide6.QtWidgets import QApplication

from core.state import AppState
from engine.bridge import EngineBridge
from engine.vision import VisionEngine
from monokernel.bridge import MonoBridge
from monokernel.dock import MonoDock
from monokernel.guard import MonoGuard
from ui.addons.builtin import build_builtin_registry
from ui.addons.context import AddonContext
from ui.addons.host import AddonHost
from ui.bridge import UIBridge
from ui.main_window import MonolithUI
from ui.overseer import OverseerWindow


def main():
    app = QApplication(sys.argv)

    # Load saved theme before any UI is created
    from core.theme_config import load_theme_config
    from core.themes import apply_theme
    from core.style import refresh_styles
    theme_cfg = load_theme_config()
    apply_theme(theme_cfg.get("theme", "monolithic"))
    refresh_styles()

    state = AppState()
    vision_engine_impl = VisionEngine(state)
    vision_engine = EngineBridge(vision_engine_impl)
    guard = MonoGuard(state, {"vision": vision_engine})
    dock = MonoDock(guard)
    bridge = MonoBridge(dock)

    ui_bridge = UIBridge()
    ui = MonolithUI(state, ui_bridge)
    overseer = OverseerWindow(guard, ui_bridge)

    registry = build_builtin_registry()
    ctx = AddonContext(state=state, guard=guard, bridge=bridge, ui=ui, host=None, ui_bridge=ui_bridge)
    host = AddonHost(registry, ctx)
    ui.attach_host(host)

    ui_bridge.sig_open_overseer.connect(overseer.show)
    ui_bridge.sig_overseer_viz_toggle.connect(guard.enable_viztracer)

    # Theme change: refresh style constants and rebuild UI stylesheets
    def _on_theme_changed(theme_name):
        apply_theme(theme_name)
        refresh_styles()
        ui.apply_theme_refresh()
        # Refresh hub page if mounted
        hub_page = ui.pages.get("hub")
        if hub_page and hasattr(hub_page, "apply_theme_refresh"):
            hub_page.apply_theme_refresh()

    ui_bridge.sig_theme_changed.connect(_on_theme_changed)

    # global chrome-only wiring stays here
    guard.sig_status.connect(ui.update_status)
    guard.sig_usage.connect(lambda _ek, used: ui.update_ctx(used))
    app.aboutToQuit.connect(guard.stop)
    app.aboutToQuit.connect(overseer.db.close)
    app.aboutToQuit.connect(lambda: guard.enable_viztracer(False) if guard._viztracer is not None else None)
    app.aboutToQuit.connect(vision_engine.shutdown)

    ui.show()
    return app.exec()


if __name__ == "__main__":
    raise SystemExit(main())



================================================================================
FILE: .\.claude\worktrees\gallant-allen\CHANGELOG.md
================================================================================

# Changelog

## v0.2a — 2025-02-09

### New Systems

- **Operator System** — Save and restore full workspace snapshots (all open modules, terminal configs, chat history). Load via LOAD button or double-click. Legacy single-config format backward compatible.
- **Overseer** — Real-time trace viewer and debug dashboard. Tracks kernel tasks, engine events, and LLM generation with searchable log. VizTracer integration for profiling.
- **UI Bridge** — Dedicated signal bus (`ui/bridge.py`) decoupling UI events from kernel internals. Handles operator apply, terminal headers, overseer toggling.
- **Operator Manager** (`core/operators.py`) — JSON-based operator storage with save/load/delete/list. Supports both legacy (single config) and new (multi-module snapshot) formats.
- **Overseer Database** (`core/overseer_db.py`) — Persistent trace storage for session history.

### New Files

- `ui/pages/hub.py` — Operator hub page with card grid, LOAD/NEW/DELETE actions, double-click to open
- `ui/components/message_widget.py` — Dedicated message bubble widget with per-message edit/delete/regenerate actions, proper word-wrap sizing
- `ui/bridge.py` — UI signal bridge
- `ui/overseer.py` — Overseer trace window
- `core/operators.py` — Operator persistence layer
- `core/overseer_db.py` — Trace database
- `core/paths.py` — Centralized config/data path resolution
- `combiner.py` — Source bundler utility
- `requirements.txt` — Dependency manifest

### Chat Overhaul

- Replaced monolithic QTextEdit chat with individual `MessageWidget` bubbles in a QListWidget
- Per-message actions on hover: edit, delete, regenerate
- Thinking mode support (Off / Standard / Extended) via collapsible OPTIONS panel in CONTROL tab
- File attachment support via OPTIONS panel
- Race condition prevention (`_pending_mutation` system) — safe edit/delete/regen during active generation
- Ghost bubble cleanup (`_cleanup_empty_assistant_if_needed`)
- `sig_debug` signal for structured trace output to Overseer
- Streaming state cleanup on interruption (UNLOADING handling)

### UI Changes

- **Top bar**: MONOLITH label is now static muted gold, left-aligned (removed fire animation)
- **Status**: Moved from top bar to small label in bottom-right corner
- **Chat title/time**: Only visible when viewing terminal modules (hidden for SD, audio, runtime)
- **Live clock**: 60-second timer keeps chat timestamp current
- **Gradient line**: Kept at top of window (unchanged)
- **Input toolbar**: Removed + and THINK buttons from chat input area
- **OPTIONS panel**: Collapsible panel in CONTROL tab with attach file + think mode toggles

### Addon System

- `AddonHost.launch_module()` now stamps `widget._addon_id` on every module instance for type identification
- `hub_factory` added to builtin registry — wires operator hub with snapshot/load/save
- Terminal factory enhanced with named exception-wrapped handlers, short engine ID traces (`[LLM:xxxx]`), descriptive generation messages
- Operator trace messages routed to Overseer via `ctx.guard.sig_trace`

### Architecture

- Removed direct `LLMEngine` instantiation from bootstrap — engine creation delegated to addon system
- Added `UIBridge` to bootstrap wiring
- Added `OverseerWindow` to bootstrap with guard connection
- `aboutToQuit` now cleans up viztracer and overseer database

### Bug Fixes

- Fixed operator loading doing nothing (missing view switch + module creation)
- Fixed assistant bubble showing large empty gap during streaming (sizeHint override for word-wrap)
- Fixed `btn_thinking` AttributeError when applying operators (removed stale reference)
- Fixed race conditions during edit/delete/regenerate while LLM is generating
- Fixed ghost empty assistant bubbles appearing after interrupted generation



================================================================================
FILE: .\.claude\worktrees\gallant-allen\install.bat
================================================================================

@echo off
echo Creating virtual environment...
python -m venv venv

echo Activating venv...
call venv\Scripts\activate.bat

echo Installing dependencies...
pip install --upgrade pip
pip install PySide6

echo.
echo Optional: Install LLM support?
set /p llm="Install llama-cpp-python? (y/n): "
if /i "%llm%"=="y" pip install llama-cpp-python

echo.
echo Optional: Install Audio generation?
set /p audio="Install audiocraft? (y/n): "
if /i "%audio%"=="y" pip install audiocraft torch torchaudio

echo.
echo Optional: Install Stable Diffusion?
set /p sd="Install diffusers? (y/n): "
if /i "%sd%"=="y" pip install diffusers torch transformers accelerate

echo.
echo Installation complete!
echo Run start.bat to launch Monolith
pause



================================================================================
FILE: .\.claude\worktrees\gallant-allen\LICENSE
================================================================================

MIT License

Copyright (c) 2026 Eryndel (Erick Ascano-Marin)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================================================
FILE: .\.claude\worktrees\gallant-allen\main.py
================================================================================

__version__ = "0.2.1a"

from bootstrap import main

if __name__ == "__main__":
    raise SystemExit(main())



================================================================================
FILE: .\.claude\worktrees\gallant-allen\nul
================================================================================




================================================================================
FILE: .\.claude\worktrees\gallant-allen\README.md
================================================================================

<p align="center">
<img width="642" height="118" alt="monolith" src="https://github.com/user-attachments/assets/17bc1107-9fdd-4d9d-9c7d-6c9a1f00fed6" />
</p>

<p align="center">
<b>Stop chatting with AI. Start commanding it.</b><br/>
A local-first AI workstation for running LLMs, Stable Diffusion, and audio generation through a modular kernel.
</p>

---

## Screenshots

<table style="border: none;">
<tr>
<td width="50%" align="center" style="border:none;">
<img src="https://github.com/user-attachments/assets/817d57a3-fb4a-4210-80a4-511116faad0b" width="98%">
</td>
<td width="50%" align="center" style="border:none;">
<img src="https://github.com/user-attachments/assets/f6f2af83-3038-42a0-b0aa-dbfa79489485" width="98%">
</td>
</tr>
</table>

<p align="center">
<img src="https://github.com/user-attachments/assets/7bb47e3d-0b12-413b-8fa7-24c174a4ddc4" width="88%">
</p>

<p align="center">
<i>Top: idle kernel + LLM chat · Bottom: Vision tab generating an image</i>
</p>

---

## Quick Start

### Windows
1. Clone repo  
2. Run `install.bat`  
3. Run `start.bat`

### Linux / macOS

```bash
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python main.py
```


## Core Overview

**Status**
v0.2.1a — Early alpha. Built for personal use and active experimentation. Shared publicly for builders & creators.

**Features**
* **Local LLM Chat:** GGUF models via llama.cpp
* **Image Generation:** Stable Diffusion
* **Audio Generation:** AudioCraft
* **System:** Persistent conversation history, modular kernel architecture, dark mode

**Architecture**
Kernel + Engines + Addons model. Engines run isolated processes; Addons control them. The Kernel enforces contracts and lifecycle boundaries.

See [Kernel Contract (V2)](/monokernel/kernel_contract.md) for details.

---

## Requirements

* **Python:** 3.10+
* **GPU:** NVIDIA GPU with 8GB+ VRAM recommended (required for SD/Audio)
* **Storage:** ~10GB disk space for base models

---

<p align="center">
  Built by <a href="https://eryndel.us">Eryndel</a>
</p>



================================================================================
FILE: .\.claude\worktrees\gallant-allen\requirements.txt
================================================================================

# Core (required)
PySide6>=6.10.0

# LLM support (optional — needed for chat/terminal)
llama-cpp-python>=0.3.0

# Image generation (optional — needed for Stable Diffusion module)
diffusers>=0.35.0
transformers>=4.57.0
accelerate>=1.11.0
torch>=2.4.0

# Audio generation (optional — needed for audio module)
audiocraft>=1.3.0
torchaudio>=2.4.0



================================================================================
FILE: .\.claude\worktrees\gallant-allen\start.bat
================================================================================

@echo off
call venv\Scripts\activate.bat
python main.py
pause



================================================================================
FILE: .\.claude\worktrees\gallant-allen\.claude\settings.local.json
================================================================================

{
  "permissions": {
    "allow": [
      "mcp__gitnexus__context"
    ]
  }
}



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\llm_config.py
================================================================================

import json

from core.paths import CONFIG_DIR

MASTER_PROMPT = """
You are Monolith.

CORE RULES:
- Treat inference as a threat.
- Only assert facts explicitly present in the user-visible context or provided by the system.
- If information is missing or uncertain: respond with "Unknown" or "I don’t know" and stop.
- Do not guess user intent.
- Do not invent system state.
- Do not assume defaults.
- Never upgrade uncertainty into certainty.
- Do not fabricate files, tools, processes, or runtime conditions.
- Re-check provided information before answering.
- If verification is impossible: say so.

OUTPUT RULES:
- Be precise.
- Be literal.
- Avoid speculation.
- Avoid narrative filler.

WORLD MODEL:
- No persistent memory unless explicitly stored.
- No assumptions about environment.
- No hidden state.
- Only the current session text is authoritative.
""".strip()

TAG_MAP = {
    "helpful": "[TONE] neutral\n[DETAIL] medium",
    "teacher": "[TONE] explanatory\n[DETAIL] high\n[STEPWISE]",
    "emotional": "[TONE] supportive\n[VALIDATING]",
    "concise": "[LENGTH] short",
    "strict": "[EPISTEMIC] maximal",
}

DEFAULT_CONFIG = {
    "gguf_path": None,
    "temp": 0.7,
    "top_p": 0.9,
    "max_tokens": 2048,
    "ctx_limit": 8192,
    "system_prompt": MASTER_PROMPT,
    "behavior_tags": [],
}

CONFIG_PATH = CONFIG_DIR / "llm_config.json"


def load_config():
    config = DEFAULT_CONFIG.copy()
    resave_config = False
    if CONFIG_PATH.exists():
        try:
            with CONFIG_PATH.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
                if isinstance(data, dict):
                    if "system_prompt" in data or "context_injection" in data:
                        data.pop("system_prompt", None)
                        data.pop("context_injection", None)
                        resave_config = True
                    config.update(data)
        except Exception:
            pass
    config.setdefault("behavior_tags", [])
    if not isinstance(config.get("behavior_tags"), list):
        config["behavior_tags"] = []
    config["system_prompt"] = MASTER_PROMPT
    if resave_config:
        save_config(config)
    return config


def save_config(config):
    persisted = dict(config)
    persisted.pop("system_prompt", None)
    persisted.pop("context_injection", None)
    CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    with CONFIG_PATH.open("w", encoding="utf-8") as handle:
        json.dump(persisted, handle, indent=2)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\operators.py
================================================================================

import json
import re
from pathlib import Path

from core.paths import CONFIG_DIR


class OperatorManager:
    def __init__(self):
        self._operators_dir = CONFIG_DIR / "operators"

    def _ensure_dir(self) -> Path:
        self._operators_dir.mkdir(parents=True, exist_ok=True)
        return self._operators_dir

    def _slugify(self, name: str) -> str:
        value = re.sub(r"[^a-z0-9]+", "-", (name or "").strip().lower())
        value = re.sub(r"-+", "-", value).strip("-")
        return value or "operator"

    def _path_for_name(self, name: str) -> Path:
        return self._ensure_dir() / f"{self._slugify(name)}.json"

    def list_operators(self) -> list[dict]:
        operators = []
        for path in self._ensure_dir().glob("*.json"):
            try:
                with path.open("r", encoding="utf-8") as handle:
                    data = json.load(handle)
            except Exception:
                continue
            if isinstance(data, dict) and isinstance(data.get("name"), str):
                # Accept both new format (has "modules") and legacy (has "config")
                if isinstance(data.get("modules"), list) or isinstance(data.get("config"), dict):
                    operators.append({"name": data["name"], "path": path})
        operators.sort(key=lambda item: item["name"].lower())
        return operators

    def load_operator(self, name: str) -> dict:
        path = self._path_for_name(name)
        with path.open("r", encoding="utf-8") as handle:
            data = json.load(handle)
        if not isinstance(data, dict):
            raise ValueError("Operator payload must be a JSON object")
        return data

    def save_operator(self, name: str, data: dict) -> Path:
        payload = dict(data or {})
        payload["name"] = name
        payload.setdefault("layout", {})
        payload.setdefault("geometry", {})
        # Strip system_prompt from config (legacy format) or module configs (new format)
        if isinstance(payload.get("config"), dict):
            payload["config"].pop("system_prompt", None)
        for mod in payload.get("modules", []):
            if isinstance(mod.get("config"), dict):
                mod["config"].pop("system_prompt", None)
        path = self._path_for_name(name)
        with path.open("w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2)
        return path

    def delete_operator(self, name: str) -> bool:
        path = self._path_for_name(name)
        if not path.exists():
            return False
        try:
            path.unlink()
        except OSError:
            return False
        return True



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\overseer_db.py
================================================================================

from __future__ import annotations

import json
import sqlite3
import threading
from datetime import datetime, timezone
from typing import Any

from core.paths import LOG_DIR


class OverseerDB:
    def __init__(self) -> None:
        self._lock = threading.Lock()
        self._conn: sqlite3.Connection | None = sqlite3.connect(LOG_DIR / "overseer.sqlite3", check_same_thread=False)
        self._conn.row_factory = sqlite3.Row
        self._conn.execute("PRAGMA journal_mode=WAL")
        self._create_schema()

    def _get_conn(self) -> sqlite3.Connection:
        if self._conn is None:
            raise RuntimeError("OverseerDB connection is closed")
        return self._conn

    def _create_schema(self) -> None:
        with self._lock:
            conn = self._get_conn()
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS events(
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ts TEXT NOT NULL,
                    engine_key TEXT NOT NULL,
                    event TEXT NOT NULL,
                    payload TEXT
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS tasks(
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id TEXT NOT NULL,
                    engine_key TEXT NOT NULL,
                    status TEXT NOT NULL,
                    ts TEXT NOT NULL
                )
                """
            )
            conn.commit()

    def _now(self) -> str:
        return datetime.now(timezone.utc).isoformat()

    def log_event(self, engine_key: str, event: str, payload: Any) -> int:
        payload_text = json.dumps(payload)
        with self._lock:
            conn = self._get_conn()
            cur = conn.execute(
                "INSERT INTO events(ts, engine_key, event, payload) VALUES(?, ?, ?, ?)",
                (self._now(), engine_key, event, payload_text),
            )
            conn.commit()
            return int(cur.lastrowid)

    def log_task(self, task_id: str, engine_key: str, status: str) -> int:
        with self._lock:
            conn = self._get_conn()
            cur = conn.execute(
                "INSERT INTO tasks(task_id, engine_key, status, ts) VALUES(?, ?, ?, ?)",
                (task_id, engine_key, status, self._now()),
            )
            conn.commit()
            return int(cur.lastrowid)

    def get_recent_events(self, limit: int = 500) -> list[dict[str, Any]]:
        with self._lock:
            cur = self._get_conn().execute(
                "SELECT id, ts, engine_key, event, payload FROM events ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            rows = [self._row_to_event_dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def get_recent_tasks(self, limit: int = 500) -> list[dict[str, Any]]:
        with self._lock:
            cur = self._get_conn().execute(
                "SELECT id, task_id, engine_key, status, ts FROM tasks ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            rows = [dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def query_events(
        self,
        engine_key: str | None = None,
        event: str | None = None,
        after: str | None = None,
        before: str | None = None,
        limit: int = 500,
    ) -> list[dict[str, Any]]:
        clauses: list[str] = []
        params: list[Any] = []

        if engine_key is not None:
            clauses.append("engine_key = ?")
            params.append(engine_key)
        if event is not None:
            clauses.append("event = ?")
            params.append(event)
        if after is not None:
            clauses.append("ts >= ?")
            params.append(after)
        if before is not None:
            clauses.append("ts <= ?")
            params.append(before)

        where = f"WHERE {' AND '.join(clauses)}" if clauses else ""
        params.append(limit)
        with self._lock:
            cur = self._get_conn().execute(
                f"SELECT id, ts, engine_key, event, payload FROM events {where} ORDER BY id DESC LIMIT ?",
                params,
            )
            rows = [self._row_to_event_dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def _row_to_event_dict(self, row: sqlite3.Row) -> dict[str, Any]:
        payload_raw = row["payload"]
        payload: Any = payload_raw
        if payload_raw is not None:
            try:
                payload = json.loads(payload_raw)
            except Exception:
                payload = payload_raw
        return {
            "id": row["id"],
            "ts": row["ts"],
            "engine_key": row["engine_key"],
            "event": row["event"],
            "payload": payload,
        }

    def close(self) -> None:
        with self._lock:
            if self._conn is None:
                return
            self._conn.close()
            self._conn = None



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\paths.py
================================================================================

import os
from pathlib import Path


if "MONOLITH_ROOT" in os.environ:
    MONOLITH_ROOT = Path(os.environ["MONOLITH_ROOT"]).expanduser()
elif os.name == "nt":
    appdata = os.getenv("APPDATA")
    if appdata:
        MONOLITH_ROOT = Path(appdata) / "Monolith"
    else:
        MONOLITH_ROOT = Path.home() / "AppData" / "Roaming" / "Monolith"
else:
    MONOLITH_ROOT = Path.home() / "Monolith"

CONFIG_DIR = MONOLITH_ROOT / "config"
ARCHIVE_DIR = MONOLITH_ROOT / "chats"
LOG_DIR = MONOLITH_ROOT / "logs"
ADDON_CONFIG_DIR = MONOLITH_ROOT / "addons" / "configs"

for _dir in (MONOLITH_ROOT, CONFIG_DIR, ARCHIVE_DIR, LOG_DIR, ADDON_CONFIG_DIR):
    _dir.mkdir(parents=True, exist_ok=True)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\state.py
================================================================================

from enum import Enum

# System Status Enum
class SystemStatus(Enum):
    READY = "READY"
    LOADING = "LOADING"
    RUNNING = "RUNNING"
    ERROR = "ERROR"
    UNLOADING = "UNLOADING"

# Shared Application State
class AppState:
    def __init__(self):
        # System
        self.gguf_path: str | None = None
        self.model_loaded: bool = False
        self.status: SystemStatus = SystemStatus.READY
        
        # Resources
        self.ctx_limit: int = 8192
        self.ctx_used: int = 0



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\style.py
================================================================================

# ======================
# DYNAMIC THEME BRIDGE
# ======================
# All constants are populated from the active theme.
# Other files import these names as before — no import changes needed.

from core.themes import current_theme


def _t():
    return current_theme()


# Backgrounds
BG_MAIN = _t().bg_main
BG_SIDEBAR = _t().bg_sidebar
BG_PANEL = _t().bg_panel
BG_GROUP = _t().bg_group
BG_INPUT = _t().bg_input

# Button states
BG_BUTTON = _t().bg_button
BG_BUTTON_HOVER = _t().bg_button_hover
BG_BUTTON_PRESSED = _t().bg_button_pressed
BG_BUTTON_DISABLED = _t().bg_button_disabled

# Borders
BORDER_DARK = _t().border_dark
BORDER_LIGHT = _t().border_light
BORDER_SUBTLE = _t().border_subtle

# Foreground / text
FG_TEXT = _t().fg_text
FG_DIM = _t().fg_dim
FG_ACCENT = _t().fg_accent
FG_ERROR = _t().fg_error
FG_WARN = _t().fg_warn
FG_PLACEHOLDER = _t().fg_placeholder
FG_INFO = _t().fg_info
FG_SECONDARY = _t().fg_secondary

# Primary accent
ACCENT_GOLD = _t().accent_primary
ACCENT_PRIMARY = _t().accent_primary
ACCENT_PRIMARY_DARK = _t().accent_primary_dark

# Glass surfaces
GLASS_BG = _t().glass_bg
GLASS_BORDER = _t().glass_border
GLASS_HOVER = _t().glass_hover

# Overseer palette
OVERSEER_BG = _t().overseer_bg
OVERSEER_FG = _t().overseer_fg
OVERSEER_DIM = _t().overseer_dim
OVERSEER_BORDER = _t().overseer_border

# Scrollbar
SCROLLBAR_HANDLE = _t().scrollbar_handle
SCROLLBAR_HANDLE_HOVER = _t().scrollbar_handle_hover

# Gradient
GRADIENT_COLOR = _t().gradient_color


def _build_scrollbar_style():
    t = _t()
    return f"""
QScrollBar:vertical {{
    background: {t.bg_input};
    width: 10px;
    margin: 0px;
    border: 1px solid {t.border_dark};
}}
QScrollBar::handle:vertical {{
    background: {t.scrollbar_handle};
    min-height: 24px;
    border: 1px solid {t.accent_primary};
    border-radius: 2px;
}}
QScrollBar::handle:vertical:hover {{
    background: {t.scrollbar_handle_hover};
}}
QScrollBar::add-line:vertical,
QScrollBar::sub-line:vertical {{
    height: 0px;
    width: 0px;
}}
QScrollBar:horizontal {{
    background: {t.bg_input};
    height: 10px;
    margin: 0px;
    border: 1px solid {t.border_dark};
}}
QScrollBar::handle:horizontal {{
    background: {t.scrollbar_handle};
    min-width: 24px;
    border: 1px solid {t.accent_primary};
    border-radius: 2px;
}}
QScrollBar::handle:horizontal:hover {{
    background: {t.scrollbar_handle_hover};
}}
QScrollBar::add-line:horizontal,
QScrollBar::sub-line:horizontal {{
    height: 0px;
    width: 0px;
}}
"""


SCROLLBAR_STYLE = _build_scrollbar_style()


def refresh_styles():
    """Rebuild all module-level constants from the currently active theme."""
    g = globals()
    t = _t()
    g["BG_MAIN"] = t.bg_main
    g["BG_SIDEBAR"] = t.bg_sidebar
    g["BG_PANEL"] = t.bg_panel
    g["BG_GROUP"] = t.bg_group
    g["BG_INPUT"] = t.bg_input
    g["BG_BUTTON"] = t.bg_button
    g["BG_BUTTON_HOVER"] = t.bg_button_hover
    g["BG_BUTTON_PRESSED"] = t.bg_button_pressed
    g["BG_BUTTON_DISABLED"] = t.bg_button_disabled
    g["BORDER_DARK"] = t.border_dark
    g["BORDER_LIGHT"] = t.border_light
    g["BORDER_SUBTLE"] = t.border_subtle
    g["FG_TEXT"] = t.fg_text
    g["FG_DIM"] = t.fg_dim
    g["FG_ACCENT"] = t.fg_accent
    g["FG_ERROR"] = t.fg_error
    g["FG_WARN"] = t.fg_warn
    g["FG_PLACEHOLDER"] = t.fg_placeholder
    g["FG_INFO"] = t.fg_info
    g["FG_SECONDARY"] = t.fg_secondary
    g["ACCENT_GOLD"] = t.accent_primary
    g["ACCENT_PRIMARY"] = t.accent_primary
    g["ACCENT_PRIMARY_DARK"] = t.accent_primary_dark
    g["GLASS_BG"] = t.glass_bg
    g["GLASS_BORDER"] = t.glass_border
    g["GLASS_HOVER"] = t.glass_hover
    g["OVERSEER_BG"] = t.overseer_bg
    g["OVERSEER_FG"] = t.overseer_fg
    g["OVERSEER_DIM"] = t.overseer_dim
    g["OVERSEER_BORDER"] = t.overseer_border
    g["SCROLLBAR_HANDLE"] = t.scrollbar_handle
    g["SCROLLBAR_HANDLE_HOVER"] = t.scrollbar_handle_hover
    g["GRADIENT_COLOR"] = t.gradient_color
    g["SCROLLBAR_STYLE"] = _build_scrollbar_style()



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\task.py
================================================================================

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from time import time
from uuid import UUID, uuid4


class TaskStatus(Enum):
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    DONE = "DONE"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


@dataclass
class Task:
    id: UUID
    addon_pid: str
    target: str
    command: str
    payload: dict
    priority: int
    status: TaskStatus
    timestamp: float

    @classmethod
    def new(
        cls,
        addon_pid: str,
        target: str,
        command: str,
        payload: dict,
        priority: int = 2,
    ) -> "Task":
        return cls(
            id=uuid4(),
            addon_pid=addon_pid,
            target=target,
            command=command,
            payload=payload,
            priority=priority,
            status=TaskStatus.PENDING,
            timestamp=time(),
        )



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\themes.py
================================================================================

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, Optional


@dataclass(frozen=True)
class Theme:
    name: str

    # Backgrounds
    bg_main: str
    bg_sidebar: str
    bg_panel: str
    bg_group: str
    bg_input: str

    # Button states
    bg_button: str
    bg_button_hover: str
    bg_button_pressed: str
    bg_button_disabled: str

    # Borders
    border_dark: str
    border_light: str
    border_subtle: str

    # Foreground / text
    fg_text: str
    fg_dim: str
    fg_accent: str
    fg_error: str
    fg_warn: str
    fg_placeholder: str
    fg_info: str
    fg_secondary: str

    # Primary accent (identity color)
    accent_primary: str
    accent_primary_dark: str

    # Glass surfaces
    glass_bg: str
    glass_border: str
    glass_hover: str

    # Overseer palette
    overseer_bg: str
    overseer_fg: str
    overseer_dim: str
    overseer_border: str

    # Scrollbar
    scrollbar_handle: str
    scrollbar_handle_hover: str

    # Gradient / animated elements
    gradient_color: str


# ---------------------
# BUILT-IN PRESETS
# ---------------------

MIDNIGHT = Theme(
    name="Midnight",
    bg_main="#0e1117",
    bg_sidebar="#12151c",
    bg_panel="#161922",
    bg_group="#0e1117",
    bg_input="#0c0f14",
    bg_button="#171b24",
    bg_button_hover="#1e2330",
    bg_button_pressed="#0e1117",
    bg_button_disabled="#0e1117",
    border_dark="#252a36",
    border_light="#2e3442",
    border_subtle="#1a1f2b",
    fg_text="#d4d8e0",
    fg_dim="#6b7280",
    fg_accent="#4ade80",
    fg_error="#ef4444",
    fg_warn="#f59e0b",
    fg_placeholder="#4b5563",
    fg_info="#3b4252",
    fg_secondary="#9ca3af",
    accent_primary="#6d8cff",
    accent_primary_dark="#5a72cc",
    glass_bg="rgba(14, 17, 23, 220)",
    glass_border="rgba(109, 140, 255, 40)",
    glass_hover="rgba(109, 140, 255, 15)",
    overseer_bg="#080a0f",
    overseer_fg="#33ff33",
    overseer_dim="#1a7a1a",
    overseer_border="#151a24",
    scrollbar_handle="#1e2330",
    scrollbar_handle_hover="#2a3040",
    gradient_color="#6d8cff",
)

OBSIDIAN = Theme(
    name="Obsidian",
    bg_main="#0C0C0C",
    bg_sidebar="#111111",
    bg_panel="#141414",
    bg_group="#0C0C0C",
    bg_input="#0f0f0f",
    bg_button="#181818",
    bg_button_hover="#222222",
    bg_button_pressed="#111111",
    bg_button_disabled="#111111",
    border_dark="#2a2a2a",
    border_light="#333333",
    border_subtle="#1a1a1a",
    fg_text="#dcdcdc",
    fg_dim="#777777",
    fg_accent="#96c93d",
    fg_error="#d44e4e",
    fg_warn="#e0b020",
    fg_placeholder="#555555",
    fg_info="#444444",
    fg_secondary="#bbbbbb",
    accent_primary="#6d8cff",
    accent_primary_dark="#5a72cc",
    glass_bg="rgba(12, 12, 12, 220)",
    glass_border="rgba(109, 140, 255, 40)",
    glass_hover="rgba(109, 140, 255, 15)",
    overseer_bg="#080808",
    overseer_fg="#33ff33",
    overseer_dim="#1a7a1a",
    overseer_border="#1a1a1a",
    scrollbar_handle="#1c1c1c",
    scrollbar_handle_hover="#252525",
    gradient_color="#6d8cff",
)

MONOLITHIC = Theme(
    name="Monolithic",
    bg_main="#0C0C0C",
    bg_sidebar="#111111",
    bg_panel="#141414",
    bg_group="#0C0C0C",
    bg_input="#0f0f0f",
    bg_button="#181818",
    bg_button_hover="#222222",
    bg_button_pressed="#111111",
    bg_button_disabled="#111111",
    border_dark="#2a2a2a",
    border_light="#333333",
    border_subtle="#1a1a1a",
    fg_text="#dcdcdc",
    fg_dim="#777777",
    fg_accent="#96c93d",
    fg_error="#d44e4e",
    fg_warn="#e0b020",
    fg_placeholder="#555555",
    fg_info="#444444",
    fg_secondary="#bbbbbb",
    accent_primary="#D4AF37",
    accent_primary_dark="#8a7340",
    glass_bg="rgba(12, 12, 12, 220)",
    glass_border="rgba(212, 175, 55, 40)",
    glass_hover="rgba(212, 175, 55, 15)",
    overseer_bg="#080808",
    overseer_fg="#33ff33",
    overseer_dim="#1a7a1a",
    overseer_border="#1a1a1a",
    scrollbar_handle="#1c1c1c",
    scrollbar_handle_hover="#252525",
    gradient_color="#D4AF37",
)

SLATE = Theme(
    name="Slate",
    bg_main="#343541",
    bg_sidebar="#202123",
    bg_panel="#40414f",
    bg_group="#343541",
    bg_input="#40414f",
    bg_button="#40414f",
    bg_button_hover="#4a4b5a",
    bg_button_pressed="#353640",
    bg_button_disabled="#2a2b32",
    border_dark="#4e4f60",
    border_light="#565869",
    border_subtle="#3e3f4b",
    fg_text="#ececf1",
    fg_dim="#8e8ea0",
    fg_accent="#10a37f",
    fg_error="#ef4444",
    fg_warn="#f59e0b",
    fg_placeholder="#6b6b7b",
    fg_info="#565869",
    fg_secondary="#c5c5d2",
    accent_primary="#10a37f",
    accent_primary_dark="#0d8a6a",
    glass_bg="rgba(52, 53, 65, 230)",
    glass_border="rgba(16, 163, 127, 35)",
    glass_hover="rgba(16, 163, 127, 12)",
    overseer_bg="#202123",
    overseer_fg="#10a37f",
    overseer_dim="#0d7a5f",
    overseer_border="#3e3f4b",
    scrollbar_handle="#4a4b5a",
    scrollbar_handle_hover="#565869",
    gradient_color="#10a37f",
)


# ---------------------
# THEME REGISTRY
# ---------------------

THEMES: Dict[str, Theme] = {
    "midnight": MIDNIGHT,
    "obsidian": OBSIDIAN,
    "monolithic": MONOLITHIC,
    "slate": SLATE,
}

_active_theme: Theme = MONOLITHIC


def current_theme() -> Theme:
    return _active_theme


def apply_theme(name: str) -> None:
    global _active_theme
    key = name.lower()
    # Migration: arctic was renamed to monolithic
    if key == "arctic":
        key = "monolithic"
    if key not in THEMES:
        key = "monolithic"
    _active_theme = THEMES[key]


def list_themes() -> list[str]:
    return [t.name for t in THEMES.values()]



================================================================================
FILE: .\.claude\worktrees\gallant-allen\core\theme_config.py
================================================================================

import json
from core.paths import CONFIG_DIR

THEME_CONFIG_PATH = CONFIG_DIR / "theme.json"
DEFAULT_THEME = "monolithic"


def load_theme_config() -> dict:
    config = {"theme": DEFAULT_THEME}
    if THEME_CONFIG_PATH.exists():
        try:
            with THEME_CONFIG_PATH.open("r", encoding="utf-8") as f:
                data = json.load(f)
                config.update(data)
        except Exception:
            pass
    return config


def save_theme_config(config: dict) -> None:
    THEME_CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    with THEME_CONFIG_PATH.open("w", encoding="utf-8") as f:
        json.dump(config, f, indent=2)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\engine\base.py
================================================================================

from __future__ import annotations

from typing import Protocol, runtime_checkable

from PySide6.QtCore import Signal


@runtime_checkable
class EnginePort(Protocol):
    """
    EnginePort protocol defines the minimal interface all engines must implement.

    Required signals:
        sig_token: Text output stream (for LLM-style engines)
        sig_trace: Debug/status messages
        sig_status: SystemStatus transitions (LOADING/RUNNING/READY/ERROR)

    Optional signals (check with hasattr before use):
        sig_usage: Token/step count tracking (LLM-specific)
        sig_image: Image output (vision engines)
        sig_audio: Audio output (audio engines)
        sig_finished: Optional completion notification

    The protocol intentionally keeps optional signals out to prevent forcing
    LLM-centric requirements onto vision/audio engines.
    """
    sig_status: Signal
    sig_trace: Signal
    sig_token: Signal

    def set_model_path(self, payload: dict) -> None:
        ...

    def load_model(self) -> None:
        ...

    def unload_model(self) -> None:
        ...

    def generate(self, payload: dict) -> None:
        ...

    def stop_generation(self) -> None:
        ...

    def shutdown(self) -> None:
        ...



================================================================================
FILE: .\.claude\worktrees\gallant-allen\engine\bridge.py
================================================================================

from PySide6.QtCore import QObject, Signal

from core.state import SystemStatus
from engine.base import EnginePort


class EngineBridge(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_usage = Signal(int)
    sig_image = Signal(object)
    sig_finished = Signal()

    def __init__(self, impl: EnginePort):
        super().__init__()
        self.impl = impl
        self._gen_id = 0
        self._active_gid = 0

        impl.sig_status.connect(self.sig_status)
        if hasattr(impl, "sig_finished"):
            impl.sig_finished.connect(self.sig_finished)

        impl.sig_token.connect(self._on_token)
        impl.sig_trace.connect(self._on_trace)
        if hasattr(impl, "sig_usage"):
            impl.sig_usage.connect(self._on_usage)
        if hasattr(impl, "sig_image"):
            impl.sig_image.connect(self._on_image)

    def _is_current_generation(self) -> bool:
        return self._active_gid == self._gen_id

    def _on_token(self, token: str) -> None:
        if self._is_current_generation():
            self.sig_token.emit(token)

    def _on_trace(self, message: str) -> None:
        if self._is_current_generation():
            self.sig_trace.emit(message)

    def _on_usage(self, usage: int) -> None:
        if self._is_current_generation():
            self.sig_usage.emit(usage)

    def _on_image(self, image: object) -> None:
        if self._is_current_generation():
            self.sig_image.emit(image)

    def set_history(self, payload: dict) -> None:
        if hasattr(self.impl, "set_history"):
            self.impl.set_history(payload)

    def set_model_path(self, payload: dict) -> None:
        if hasattr(self.impl, "set_model_path"):
            self.impl.set_model_path(payload)

    def set_ctx_limit(self, payload: dict) -> None:
        if hasattr(self.impl, "set_ctx_limit"):
            self.impl.set_ctx_limit(payload)

    def load_model(self) -> None:
        self.impl.load_model()

    def unload_model(self) -> None:
        self.impl.unload_model()

    def generate(self, payload: dict) -> None:
        self._gen_id += 1
        self._active_gid = self._gen_id
        self.impl.generate(payload)

    def stop_generation(self) -> None:
        self._gen_id += 1
        self._active_gid = 0
        self.impl.stop_generation()

    def shutdown(self) -> None:
        self.impl.shutdown()



================================================================================
FILE: .\.claude\worktrees\gallant-allen\engine\llm.py
================================================================================

from PySide6.QtCore import QObject, QThread, Signal, QTimer
from core.state import AppState, SystemStatus
from core.llm_config import load_config, MASTER_PROMPT

class ModelLoader(QThread):
    trace = Signal(str)
    finished = Signal(object, int)
    error = Signal(str)

    def __init__(self, path, n_ctx=8192, n_gpu_layers=-1):
        super().__init__()
        self.path = path
        self.n_ctx = n_ctx
        self.n_gpu_layers = n_gpu_layers

    def run(self):
        try:
            try:
                from llama_cpp import Llama
            except ImportError as exc:
                raise RuntimeError(
                    "llama-cpp-python is not installed. Install it to use the local LLM engine."
                ) from exc
            self.trace.emit(f"→ init backend: {self.path}")
            llm_instance = Llama(
                model_path=self.path,
                n_ctx=self.n_ctx,
                n_gpu_layers=self.n_gpu_layers,
                verbose=False
            )
            model_ctx_length = llm_instance._model.n_ctx_train()
            self.finished.emit(llm_instance, model_ctx_length)
        except Exception as e:
            self.error.emit(f"Load Failed: {str(e)}")

class GeneratorWorker(QThread):
    token = Signal(str)
    trace = Signal(str)
    done = Signal(bool, str)
    usage = Signal(int)

    def __init__(self, llm, messages, temp, top_p, max_tokens):
        super().__init__()
        self.llm = llm
        self.messages = messages
        self.temp = temp
        self.top_p = top_p
        self.max_tokens = max_tokens

    def run(self):
        self.trace.emit(f"[WORKER] started: msgs={len(self.messages)}, temp={self.temp}, max_tokens={self.max_tokens}")
        self.trace.emit("→ inference started")
        assistant_chunks = []
        completed = False
        try:
            if self.isInterruptionRequested():
                self.trace.emit("[WORKER] interrupted before inference")
                return

            stream = self.llm.create_chat_completion(
                messages=self.messages,
                temperature=self.temp,
                top_p=self.top_p,
                max_tokens=self.max_tokens,
                stream=True
            )

            total_generated = 0
            for chunk in stream:
                if self.isInterruptionRequested():
                    self.trace.emit("→ inference aborted")
                    break

                if "content" in chunk["choices"][0]["delta"]:
                    text = chunk["choices"][0]["delta"]["content"]
                    assistant_chunks.append(text)
                    self.token.emit(text)
                    total_generated += 1
                    self.usage.emit(total_generated)

            if not self.isInterruptionRequested():
                completed = True
                self.trace.emit("→ inference complete")
        except Exception as e:
            self.trace.emit(f"[WORKER] EXCEPTION: {e}")
            self.trace.emit(f"<span style='color:red'>ERROR: {e}</span>")
        finally:
            self.trace.emit(f"[WORKER] finished: completed={completed}, chunks={len(assistant_chunks)}")
            self.done.emit(completed, "".join(assistant_chunks))

class LLMEngine(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_finished = Signal()
    sig_usage = Signal(int)
    sig_image = Signal(object)
    sig_model_capabilities = Signal(dict)

    def __init__(self, state: AppState):
        super().__init__()
        self.state = state
        self.llm = None
        self.loader = None
        self.worker = None
        self.model_path: str | None = None
        self.conversation_history: list[dict] = []
        self._pending_user_index: int | None = None
        self._load_cancel_requested: bool = False
        self._shutdown_requested: bool = False
        self._status: SystemStatus = SystemStatus.READY
        self._ephemeral_generation: bool = False
        self.model_loaded: bool = False
        self.model_ctx_length: int | None = None
        self.ctx_limit: int = int(getattr(self.state, "ctx_limit", 8192))
        self.gguf_path: str | None = None

    def set_ctx_limit(self, payload: dict) -> None:
        value = payload.get("ctx_limit") if isinstance(payload, dict) else None
        if value is None:
            return
        try:
            self.ctx_limit = int(value)
        except (TypeError, ValueError):
            return

    def set_model_path(self, payload: dict) -> None:
        path = payload.get("path") if isinstance(payload, dict) else None
        self.model_path = path
        self.gguf_path = path
        QTimer.singleShot(0, lambda: self.set_status(SystemStatus.READY))

    def load_model(self):
        if self._status == SystemStatus.LOADING:
            self.sig_trace.emit("ERROR: Load already in progress.")
            self.set_status(SystemStatus.ERROR)
            return
        
        model_path = self.model_path or self.gguf_path
        if not model_path:
            self.sig_trace.emit("ERROR: No GGUF selected.")
            self.set_status(SystemStatus.ERROR)
            return

        self.set_status(SystemStatus.LOADING)
        self._load_cancel_requested = False
        # Keep reference to loader to prevent GC
        n_ctx = (
            min(self.ctx_limit, self.model_ctx_length)
            if self.model_ctx_length
            else self.ctx_limit
        )
        self.loader = ModelLoader(model_path, n_ctx)
        self.loader.trace.connect(self.sig_trace)
        self.loader.error.connect(self._on_load_error)
        self.loader.finished.connect(self._on_load_success)
        self.loader.finished.connect(self._cleanup_loader)
        self.loader.error.connect(self._cleanup_loader)
        self.loader.start()

    def _on_load_success(self, llm_instance, model_ctx_length):
        if self._shutdown_requested:
            del llm_instance
            self.set_status(SystemStatus.READY)
            return

        if self._load_cancel_requested:
            del llm_instance
            self.llm = None
            self.model_loaded = False
            self.set_status(SystemStatus.READY)
            self.sig_trace.emit("→ load cancelled")
            self.loader = None
            return

        self.llm = llm_instance
        self.model_ctx_length = int(model_ctx_length)
        self.ctx_limit = min(self.ctx_limit, self.model_ctx_length)
        self.sig_model_capabilities.emit(
            {
                "model_ctx_length": self.model_ctx_length,
                "ctx_limit": self.ctx_limit,
            }
        )
        self.model_loaded = True
        self.set_status(SystemStatus.READY)
        self.reset_conversation(MASTER_PROMPT)
        self.sig_trace.emit("→ system online")
        self.loader = None

    def _on_load_error(self, err_msg):
        self.sig_trace.emit(f"<span style='color:red'>{err_msg}</span>")
        if self._shutdown_requested:
            self.set_status(SystemStatus.READY)
        else:
            self.set_status(SystemStatus.ERROR)
        self.loader = None

    def _cleanup_loader(self, *args, **kwargs):
        self.loader = None

    def unload_model(self):
        if self._status == SystemStatus.LOADING and self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit("→ unload requested during load; will cancel when init completes")
            return

        if self._status == SystemStatus.RUNNING:
            self.sig_trace.emit("ERROR: Cannot unload while generating.")
            return

        if self.llm:
            self.set_status(SystemStatus.UNLOADING)
            del self.llm
            self.llm = None
        self.model_loaded = False
        self.model_ctx_length = None
        self.reset_conversation(MASTER_PROMPT)
        QTimer.singleShot(0, lambda: self.set_status(SystemStatus.READY))
        self.sig_trace.emit("→ model unloaded")

    def reset_conversation(self, system_prompt):
        self.conversation_history = [{"role": "system", "content": system_prompt}]
        self._pending_user_index = None

    def set_history(self, payload: dict):
        history = payload.get("history", []) if isinstance(payload, dict) else []
        if not isinstance(history, list):
            return
        self.conversation_history = [h for h in history if isinstance(h, dict)]
        self._pending_user_index = None

    def _compile_system_prompt(self, config):
        tags = config.get("behavior_tags", [])
        cleaned = [tag.strip() for tag in tags if isinstance(tag, str) and tag.strip()]
        if not cleaned:
            return MASTER_PROMPT
        return f"{MASTER_PROMPT}\n\n[BEHAVIOR TAGS]\n" + "\n".join(cleaned)

    def generate(self, payload: dict):
        if not self.model_loaded:
            self.sig_trace.emit("ERROR: Model offline.")
            self.set_status(SystemStatus.ERROR)
            return

        if isinstance(payload, dict) and "ctx_limit" in payload:
            try:
                self.ctx_limit = int(payload.get("ctx_limit", self.ctx_limit))
            except (TypeError, ValueError):
                pass

        if self._status == SystemStatus.RUNNING:
            self.sig_trace.emit("ERROR: Busy. Wait for completion.")
            self.set_status(SystemStatus.ERROR)
            return

        self.set_status(SystemStatus.RUNNING)

        prompt = payload.get("prompt", "")
        self.sig_trace.emit(f"[ENGINE] generate: history_len={len(self.conversation_history)}, prompt={repr(prompt[:80])}, model_loaded={self.model_loaded}")
        config = payload.get("config")
        if config is None:
            config = load_config()

        system_prompt = self._compile_system_prompt(config)
        temp = float(config.get("temp", 0.7))
        top_p = float(config.get("top_p", 0.9))
        max_tokens = int(config.get("max_tokens", 2048))

        self._ephemeral_generation = bool(payload.get("ephemeral", False))
        thinking_mode = bool(payload.get("thinking_mode", False))

        if not self.conversation_history:
            self.reset_conversation(MASTER_PROMPT)

        system_entry = {"role": "system", "content": system_prompt}
        if self.conversation_history[0].get("role") != "system":
            self.conversation_history.insert(0, system_entry)
        else:
            self.conversation_history[0] = system_entry

        is_update = prompt.startswith("You were interrupted mid-generation.")
        if not self._ephemeral_generation and not is_update:
            self.conversation_history.append({"role": "user", "content": prompt})
            self._pending_user_index = len(self.conversation_history) - 1
            messages = list(self.conversation_history)
        else:
            messages = list(self.conversation_history)
            if not is_update:
                messages.append({"role": "user", "content": prompt})
            self._pending_user_index = None

        if thinking_mode and not self._ephemeral_generation:
            messages = list(messages)
            messages.append(
                {
                    "role": "system",
                    "content": "Use private reasoning to think step-by-step, then provide a concise final answer.",
                }
            )

        self.worker = GeneratorWorker(
            self.llm, messages, temp,
            top_p, max_tokens
        )
        self.worker.token.connect(self.sig_token)
        self.worker.trace.connect(self.sig_trace)
        self.worker.usage.connect(self._on_usage_update)
        self.worker.done.connect(self._on_gen_finish)
        self.worker.start()

    def stop_generation(self):
        if self._status == SystemStatus.LOADING and self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit("→ load cancel requested; will stop after initialization completes")
            return

        self._ephemeral_generation = False
        if self.worker and self.worker.isRunning():
            self.worker.requestInterruption()

    def _on_usage_update(self, count):
        self.sig_usage.emit(count)

    def _on_gen_finish(self, completed, assistant_text):
        self.sig_trace.emit(f"[ENGINE] _on_gen_finish: completed={completed}, text_len={len(assistant_text)}")
        if completed and not self._ephemeral_generation:
            self.conversation_history.append(
                {"role": "assistant", "content": assistant_text}
            )
        self._pending_user_index = None
        self._ephemeral_generation = False
        self.sig_token.emit("\n")
        self.sig_finished.emit()
        self.set_status(SystemStatus.READY)

    def set_status(self, s):
        self._status = s
        self.sig_status.emit(s)

    def shutdown(self):
        self._shutdown_requested = True
        self.stop_generation()

        if self.worker:
            self.worker.requestInterruption()
            self.worker.wait(1500)
            self.worker = None

        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.loader.wait(150)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\engine\vision.py
================================================================================

from __future__ import annotations

from PySide6.QtCore import QObject, QThread, Signal, QTimer

from core.state import AppState, SystemStatus


class PipelineLoader(QThread):
    trace = Signal(str)
    finished = Signal(object)
    error = Signal(str)

    def __init__(self, model_path: str):
        super().__init__()
        self.model_path = model_path

    def run(self) -> None:
        try:
            try:
                import torch
                from diffusers import StableDiffusionPipeline
            except ImportError as exc:
                raise RuntimeError(
                    "diffusers is not installed. pip install diffusers"
                ) from exc

            device = "cuda" if torch.cuda.is_available() else "cpu"
            dtype = torch.float16 if device == "cuda" else torch.float32

            if self.isInterruptionRequested():
                return

            self.trace.emit(f"loading pipeline: {self.model_path}")
            if self.model_path.endswith((".safetensors", ".ckpt")):
                pipe = StableDiffusionPipeline.from_single_file(
                    self.model_path,
                    torch_dtype=dtype,
                    safety_checker=None,
                    requires_safety_checker=False,
                )
            else:
                pipe = StableDiffusionPipeline.from_pretrained(
                    self.model_path,
                    torch_dtype=dtype,
                    safety_checker=None,
                    requires_safety_checker=False,
                )

            pipe = pipe.to(device)
            self.finished.emit(pipe)
        except Exception as exc:
            self.error.emit(str(exc))


class GenerationWorker(QThread):
    image = Signal(object)
    trace = Signal(str)
    done = Signal(bool, str)

    def __init__(
        self,
        pipe,
        prompt: str,
        steps: int,
        guidance: float,
        seed: int | None,
    ):
        super().__init__()
        self.pipe = pipe
        self.prompt = prompt
        self.steps = steps
        self.guidance = guidance
        self.seed = seed

    def run(self) -> None:
        completed = False
        err_msg = ""
        try:
            import torch

            if self.isInterruptionRequested():
                return

            device = "cuda" if torch.cuda.is_available() else "cpu"
            generator = None
            if self.seed is not None:
                generator = torch.Generator(device=device).manual_seed(self.seed)

            def _callback(step: int, timestep: int, latents) -> None:
                if self.isInterruptionRequested():
                    raise RuntimeError("Generation interrupted")

            self.trace.emit("generation started")
            result = self.pipe(
                self.prompt,
                num_inference_steps=self.steps,
                guidance_scale=self.guidance,
                generator=generator,
                callback=_callback,
                callback_steps=1,
            )
            if self.isInterruptionRequested():
                return
            self.image.emit(result.images[0])
            self.trace.emit("generation complete")
            completed = True
        except Exception as exc:
            err_msg = str(exc)
        finally:
            self.done.emit(completed, err_msg)


class VisionEngine(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_usage = Signal(int)
    sig_finished = Signal()
    sig_image = Signal(object)

    def __init__(self, state: AppState):
        super().__init__()
        self.state = state
        self.pipe = None
        self.model_path: str | None = None
        self._loaded_path: str | None = None
        self.loader: PipelineLoader | None = None
        self.worker: GenerationWorker | None = None
        self._load_cancel_requested = False
        self._shutdown_requested = False

    def set_model_path(self, payload: dict) -> None:
        path = payload.get("path") if isinstance(payload, dict) else None
        self.model_path = path
        QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))

    def load_model(self) -> None:
        if self.loader and self.loader.isRunning():
            self.sig_trace.emit("VISION: load already in progress.")
            QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))
            return

        if not self.model_path:
            self.sig_trace.emit("VISION: ERROR: No model selected.")
            self.sig_status.emit(SystemStatus.ERROR)
            return

        if self.pipe and self._loaded_path == self.model_path:
            self.sig_trace.emit("VISION: pipeline already loaded.")
            QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))
            return

        if self.pipe and self._loaded_path != self.model_path:
            self.unload_model()

        self.sig_status.emit(SystemStatus.LOADING)
        self.sig_trace.emit("VISION: loading pipeline")
        self._load_cancel_requested = False
        self.loader = PipelineLoader(self.model_path)
        self.loader.trace.connect(self._emit_trace)
        self.loader.error.connect(self._on_load_error)
        self.loader.finished.connect(self._on_load_success)
        self.loader.finished.connect(self._cleanup_loader)
        self.loader.error.connect(self._cleanup_loader)
        self.loader.start()

    def _emit_trace(self, message: str) -> None:
        self.sig_trace.emit(f"VISION: {message}")

    def _on_load_success(self, pipe) -> None:
        if self._shutdown_requested:
            del pipe
            self.sig_status.emit(SystemStatus.READY)
            return

        if self._load_cancel_requested:
            del pipe
            self.pipe = None
            self._loaded_path = None
            self.sig_status.emit(SystemStatus.READY)
            self.sig_trace.emit("VISION: load cancelled")
            self.loader = None
            return

        self.pipe = pipe
        self._loaded_path = self.model_path
        self.sig_trace.emit("VISION: pipeline ready")
        self.sig_status.emit(SystemStatus.READY)
        self.loader = None

    def _on_load_error(self, err_msg: str) -> None:
        self.sig_trace.emit(f"VISION: ERROR: {err_msg}")
        self.sig_status.emit(SystemStatus.ERROR)
        self.loader = None

    def _cleanup_loader(self, *args, **kwargs) -> None:
        self.loader = None

    def unload_model(self) -> None:
        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit(
                "VISION: unload requested during load; will cancel after init completes"
            )
            return

        if self.worker and self.worker.isRunning():
            self.sig_trace.emit("VISION: ERROR: Cannot unload while generating.")
            return

        self.sig_status.emit(SystemStatus.UNLOADING)
        if self.pipe:
            del self.pipe
            self.pipe = None
            self._loaded_path = None

        try:
            import torch

            if torch.cuda.is_available():
                torch.cuda.empty_cache()
        except Exception:
            pass

        QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))

    def generate(self, payload: dict) -> None:
        if not self.pipe:
            self.sig_trace.emit("VISION: ERROR: Model offline.")
            self.sig_status.emit(SystemStatus.READY)
            return

        if self.worker and self.worker.isRunning():
            self.sig_trace.emit("VISION: ERROR: Busy. Wait for completion.")
            return

        config = payload.get("config", payload)
        prompt = config.get("prompt", payload.get("prompt", ""))

        steps = int(config.get("steps", 25))
        guidance_scale = float(config.get("guidance_scale", 7.5))
        seed = config.get("seed")
        if isinstance(seed, int) and seed < 0:
            seed = None

        self.sig_status.emit(SystemStatus.RUNNING)
        self.worker = GenerationWorker(
            self.pipe,
            prompt,
            steps,
            guidance_scale,
            seed,
        )
        self.worker.image.connect(self.sig_image)
        self.worker.trace.connect(self._emit_trace)
        self.worker.done.connect(self._on_gen_finish)
        self.worker.start()

    def stop_generation(self) -> None:
        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit(
                "VISION: load cancel requested; will stop after initialization completes"
            )
            return

        if self.worker and self.worker.isRunning():
            self.worker.requestInterruption()

    def _on_gen_finish(self, completed: bool, err_msg: str) -> None:
        if completed:
            self.sig_finished.emit()
            self.sig_status.emit(SystemStatus.READY)
        elif err_msg == "Generation interrupted":
            self.sig_trace.emit("VISION: generation interrupted")
            self.sig_status.emit(SystemStatus.READY)
        else:
            self.sig_trace.emit(f"VISION: ERROR: {err_msg}")
            self.sig_status.emit(SystemStatus.ERROR)
        self.worker = None

    def shutdown(self) -> None:
        self._shutdown_requested = True
        self.stop_generation()

        if self.worker:
            self.worker.requestInterruption()
            self.worker.wait(1500)
            self.worker = None

        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.loader.wait(150)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\monokernel\bridge.py
================================================================================

from __future__ import annotations

from core.task import Task
from monokernel.dock import MonoDock


class MonoBridge:
    def __init__(self, dock: MonoDock):
        self.dock = dock

    def wrap(self, source: str, command: str, target: str, **kwargs) -> Task:
        priority = int(kwargs.pop("priority", 2))
        payload = kwargs.pop("payload", kwargs)
        return Task.new(
            addon_pid=source,
            target=target,
            command=command,
            payload=payload,
            priority=priority,
        )

    def submit(self, task: Task) -> None:
        self.dock.enqueue(task)

    def cancel(self, task_id: str) -> None:
        self.dock.cancel_task(task_id)

    def cancel_addon(self, addon_pid: str) -> None:
        self.dock.cancel_addon(addon_pid)

    def stop(self, target: str = "all") -> None:
        self.dock.on_stop(target)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\monokernel\dock.py
================================================================================

from __future__ import annotations

from collections import deque
from typing import Deque

from core.task import Task, TaskStatus
from monokernel.guard import MonoGuard


class MonoDock:
    def __init__(self, guard: MonoGuard):
        self.guard = guard
        self.queues: dict[str, Deque[Task]] = {}
        self.cancelled_task_ids: set[str] = set()
        self.cancelled_addons: set[str] = set()
        self._in_submit: dict[str, bool] = {}
        self.guard.sig_engine_ready.connect(self._on_engine_ready)

    def enqueue(self, task: Task) -> None:
        self.guard.sig_trace.emit("system", f"[DOCK] enqueue: task={task.id}, cmd={task.command}, target={task.target}, priority={task.priority}")
        if task.priority == 1:
            self.on_stop(task.target)
            return
        queue = self.queues.setdefault(task.target, deque())
        self._insert_task(queue, task)
        self._try_submit(task.target)

    def cancel_task(self, task_id: str) -> None:
        self.cancelled_task_ids.add(task_id)
        for engine_key in self.guard.engines.keys():
            active = self.guard.get_active_task(engine_key)
            if active and str(active.id) == task_id:
                self.guard.stop(engine_key)

    def cancel_addon(self, addon_pid: str) -> None:
        self.cancelled_addons.add(addon_pid)
        for engine_key in self.guard.engines.keys():
            active = self.guard.get_active_task(engine_key)
            if active and active.addon_pid == addon_pid:
                self.guard.stop(engine_key)

    def on_stop(self, target: str = "all") -> None:
        self.guard.stop(target)
        if target == "all":
            for queue in self.queues.values():
                for task in queue:
                    self.cancelled_task_ids.add(str(task.id))
        else:
            queue = self.queues.get(target)
            if queue:
                for task in queue:
                    self.cancelled_task_ids.add(str(task.id))

    def _on_engine_ready(self, engine_key: str) -> None:
        self._try_submit(engine_key)

    def _try_submit(self, engine_key: str) -> None:
        if self._in_submit.get(engine_key):
            self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: BLOCKED by _in_submit for {engine_key}")
            return
        queue = self.queues.get(engine_key)
        if not queue:
            self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: empty queue for {engine_key}")
            return

        self._in_submit[engine_key] = True
        try:
            while queue:
                task = queue[0]
                if self._is_cancelled(task):
                    self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: CANCELLED task={task.id}, cmd={task.command}")
                    task.status = TaskStatus.CANCELLED
                    if queue:
                        queue.popleft()
                    self.cancelled_task_ids.discard(str(task.id))
                    continue
                accepted = self.guard.submit(task)
                self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: guard.submit returned {accepted} for task={task.id}, cmd={task.command}")
                if accepted and queue:
                    queue.popleft()
                break
        finally:
            self._in_submit[engine_key] = False

    def _is_cancelled(self, task: Task) -> bool:
        return str(task.id) in self.cancelled_task_ids or task.addon_pid in self.cancelled_addons

    def _insert_task(self, queue: Deque[Task], task: Task) -> None:
        if task.priority == 2:
            items = list(queue)
            insert_at = 0
            for existing in items:
                if existing.priority != 2:
                    break
                insert_at += 1
            items.insert(insert_at, task)
            queue.clear()
            queue.extend(items)
        else:
            queue.append(task)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\monokernel\guard.py
================================================================================

from __future__ import annotations

from datetime import datetime
from typing import Optional

from core.paths import LOG_DIR

from PySide6.QtCore import QObject, Signal, QTimer

from core.state import AppState, SystemStatus
from core.task import Task, TaskStatus
from engine.base import EnginePort

ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "set_history": "set_history",
    "set_ctx_limit": "set_ctx_limit",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}

IMMEDIATE_COMMANDS = {"set_history", "set_path", "set_ctx_limit"}
PAYLOAD_COMMANDS = {"generate"}


class MonoGuard(QObject):
    sig_token = Signal(str, str)
    sig_trace = Signal(str, str)
    sig_status = Signal(str, SystemStatus)
    sig_engine_ready = Signal(str)
    sig_usage = Signal(str, int)
    sig_image = Signal(object)
    sig_finished = Signal(str, str)

    def __init__(self, state: AppState, engines: dict[str, EnginePort]):
        super().__init__()
        self.state = state
        self.engines = engines
        self.active_tasks: dict[str, Optional[Task]] = {
            key: None for key in engines.keys()
        }
        self._stop_requested: dict[str, bool] = {key: False for key in engines.keys()}
        self._viztracer = None

        self._engine_connections: dict[str, dict[str, object]] = {}
        for key, engine in engines.items():
            self._connect_engine_signals(key, engine)


    def _connect_engine_signals(self, key: str, engine: EnginePort) -> None:
        status_slot = lambda status, engine_key=key: self._on_status_changed(engine_key, status)
        token_slot = lambda t, ek=key: self.sig_token.emit(ek, t)
        trace_slot = lambda m, ek=key: self.sig_trace.emit(ek, m)
        finished_slot = lambda engine_key=key: self._on_engine_finished(engine_key)

        engine.sig_status.connect(status_slot)
        engine.sig_token.connect(token_slot)
        engine.sig_trace.connect(trace_slot)

        usage_slot = None
        if hasattr(engine, "sig_usage"):
            usage_slot = lambda used, ek=key: self.sig_usage.emit(ek, used)
            engine.sig_usage.connect(usage_slot)

        image_slot = None
        if hasattr(engine, "sig_image"):
            image_slot = self.sig_image.emit
            engine.sig_image.connect(image_slot)

        has_finished = hasattr(engine, "sig_finished")
        if has_finished:
            engine.sig_finished.connect(finished_slot)

        self._engine_connections[key] = {
            "status": status_slot,
            "token": token_slot,
            "trace": trace_slot,
            "usage": usage_slot,
            "image": image_slot,
            "finished": finished_slot if has_finished else None,
        }

    def _disconnect_engine_signals(self, key: str, engine: EnginePort) -> None:
        slots = self._engine_connections.pop(key, None)
        if not slots:
            return
        for signal_name, slot in slots.items():
            if slot is None:
                continue
            signal = getattr(engine, f"sig_{signal_name}", None)
            if signal is None:
                continue
            try:
                signal.disconnect(slot)
            except (TypeError, RuntimeError):
                pass

    def register_engine(self, key: str, engine: EnginePort):
        if key in self.engines:
            self.unregister_engine(key)
        self.engines[key] = engine
        self.active_tasks[key] = None
        self._stop_requested[key] = False
        self._connect_engine_signals(key, engine)

    def unregister_engine(self, key: str):
        engine = self.engines.get(key)
        if engine is None:
            return
        self._disconnect_engine_signals(key, engine)
        self.active_tasks.pop(key, None)
        self._stop_requested.pop(key, None)
        del self.engines[key]

    def get_active_task_id(self, engine_key: str) -> str | None:
        task = self.active_tasks.get(engine_key)
        return str(task.id) if task else None

    def get_active_task(self, engine_key: str) -> Task | None:
        return self.active_tasks.get(engine_key)

    def submit(self, task: Task) -> bool:
        engine = self.engines.get(task.target)
        if engine is None:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED unknown engine target={task.target}")
            self.sig_trace.emit("system", f"ERROR: Unknown engine target: {task.target}")
            return False

        method_name = ENGINE_DISPATCH.get(task.command)
        if not method_name:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED unknown command={task.command}")
            self.sig_trace.emit("system", f"ERROR: Unknown command: {task.command}")
            task.status = TaskStatus.FAILED
            return False

        handler = getattr(engine, method_name, None)
        if not handler:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED no handler for {method_name}")
            self.sig_trace.emit("system", f"ERROR: Engine lacks handler: {method_name}")
            task.status = TaskStatus.FAILED
            return False

        if task.command in IMMEDIATE_COMMANDS:
            self.sig_trace.emit("system", f"[GUARD] submit: IMMEDIATE {task.command} task={task.id}")
            self.sig_trace.emit("system", f"GUARD: IMMEDIATE {task.command} task={task.id}")
            task.status = TaskStatus.RUNNING
            handler(task.payload)
            task.status = TaskStatus.DONE
            return True

        if self.active_tasks.get(task.target) is not None:
            active = self.active_tasks.get(task.target)
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED BUSY target={task.target}, active_task={active.id if active else None}, active_cmd={active.command if active else None}")
            self.sig_trace.emit("system", f"GUARD: rejected task={task.id} target={task.target} (busy)")
            return False

        self.sig_trace.emit("system", f"[GUARD] submit: ACCEPTED task={task.id} cmd={task.command} target={task.target}")
        self.sig_trace.emit("system", f"GUARD: accepted task={task.id} target={task.target} command={task.command}")
        self.active_tasks[task.target] = task
        task.status = TaskStatus.RUNNING

        if task.command in PAYLOAD_COMMANDS:
            handler(task.payload)
        else:
            handler()
        return True

    def stop(self, target: str = "all") -> None:
        self.sig_trace.emit("system", f"GUARD: STOP target={target}")
        if target == "all":
            keys = list(self.engines.keys())
        else:
            keys = [target]

        for key in keys:
            engine = self.engines.get(key)
            if not engine:
                continue
            task = self.active_tasks.get(key)
            if task is not None:
                self._stop_requested[key] = True
            engine.stop_generation()

    def _on_engine_finished(self, engine_key: str) -> None:
        task = self.active_tasks.get(engine_key)
        if task:
            self.sig_finished.emit(engine_key, str(task.id))
            self.sig_trace.emit(engine_key, f"GUARD: finished engine={engine_key} task={task.id}")

    def _on_status_changed(self, engine_key: str, new_status: SystemStatus) -> None:
        self.sig_trace.emit("system", f"[GUARD] _on_status_changed: engine={engine_key}, status={new_status}, active_task={self.active_tasks.get(engine_key) is not None}")
        self.sig_status.emit(engine_key, new_status)

        if new_status == SystemStatus.ERROR:
            task = self.active_tasks.get(engine_key)
            had_task = task is not None
            if task:
                task.status = TaskStatus.FAILED
            self.active_tasks[engine_key] = None
            self._stop_requested[engine_key] = False
            self.sig_status.emit(engine_key, SystemStatus.READY)
            if had_task:
                QTimer.singleShot(0, lambda: self.sig_engine_ready.emit(engine_key))
            return

        if new_status == SystemStatus.READY:
            task = self.active_tasks.get(engine_key)
            had_task = task is not None
            if task and task.status == TaskStatus.RUNNING:
                if self._stop_requested.get(engine_key, False):
                    task.status = TaskStatus.CANCELLED
                else:
                    task.status = TaskStatus.DONE
            self.active_tasks[engine_key] = None
            self._stop_requested[engine_key] = False
            if had_task:
                QTimer.singleShot(0, lambda: self.sig_engine_ready.emit(engine_key))


    def enable_viztracer(self, enabled: bool) -> None:
        if enabled:
            if self._viztracer is not None:
                return
            try:
                from viztracer import VizTracer
            except Exception as exc:
                self.sig_trace.emit("system", f"OVERSEER: viztracer unavailable: {exc}")
                return
            try:
                self._viztracer = VizTracer(
                    min_duration=5000,
                    ignore_frozen=True,
                    exclude_files=["*/site-packages/*"],
                )
            except TypeError:
                self._viztracer = VizTracer(
                    min_duration=5000,
                    ignore_frozen=True,
                )
            except Exception:
                self._viztracer = VizTracer()
            self._viztracer.start()
            self.sig_trace.emit("system", "OVERSEER: viztracer started")
            return

        tracer = self._viztracer
        if tracer is None:
            return
        tracer.stop()
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        out_path = LOG_DIR / f"viztrace_{ts}.json"
        tracer.save(str(out_path))
        self.sig_trace.emit("system", f"OVERSEER: viztracer saved {out_path}")
        self._viztracer = None



================================================================================
FILE: .\.claude\worktrees\gallant-allen\monokernel\__init__.py
================================================================================





================================================================================
FILE: .\.claude\worktrees\gallant-allen\README\architecture.md
================================================================================

# MONOLITH ARCHITECTURE — Agent Reference

**Purpose**: This document maps Monolith's complete architecture with explicit signal flows, contracts, and implementation patterns. Everything an agent needs to understand the system in one read.

**Philosophy**: Sovereignty-focused local-first AI workstation with deterministic core (MonoKernel) and probabilistic periphery (engines/modules).

---

## TABLE OF CONTENTS

1. [System Overview](#system-overview)
2. [Component Hierarchy](#component-hierarchy)
3. [Signal Flow Architecture](#signal-flow-architecture)
4. [MonoKernel Contract (v2)](#monokernel-contract-v2)
5. [Engine Architecture](#engine-architecture)
6. [Addon System](#addon-system)
7. [Task Queue System](#task-queue-system)
8. [Bootstrap Sequence](#bootstrap-sequence)
9. [Critical Patterns](#critical-patterns)
10. [Implementation Details](#implementation-details)

---

## SYSTEM OVERVIEW

### Core Principle
**MonoKernel decides WHEN things happen — never WHAT happens.**

Monolith enforces strict separation:
- **Deterministic Core**: MonoGuard + MonoDock (arbitration only)
- **Probabilistic Periphery**: Engines (LLM, Vision, Audio) + UI/Modules (execution)

### Component Layers
```
UI/Addons (presentation + user interaction)
    ↕ signals only
MonoKernel (arbitration + routing)
    ↕ signals only  
Engines (execution + computation)
```

**Rule**: UI never calls engines directly. Engines never emit to UI directly. Everything routes through MonoKernel.

---

## COMPONENT HIERARCHY

### Directory Structure
```
monolith-main/
├── monokernel/          # Core arbitration layer (FROZEN v1)
│   ├── guard.py         # Signal router + engine orchestrator
│   ├── dock.py          # Task queue + cancellation
│   └── bridge.py        # UI→Kernel API
├── engine/              # Execution layer
│   ├── base.py          # EnginePort protocol
│   ├── bridge.py        # EngineBridge (generation gating)
│   ├── llm.py           # LLMEngine implementation
│   └── vision.py        # VisionEngine implementation
├── ui/                  # Presentation layer
│   ├── main_window.py   # Main chrome + global signals
│   ├── pages/           # Page addons (full screen)
│   │   └── chat.py      # Chat interface (Terminal addon)
│   ├── modules/         # Module addons (stackable)
│   │   ├── sd.py        # Vision module
│   │   └── injector.py  # Context injector module
│   ├── addons/          # Addon system infrastructure
│   │   ├── spec.py      # AddonSpec (id, kind, factory)
│   │   ├── registry.py  # AddonRegistry (addon storage)
│   │   ├── host.py      # AddonHost (lifecycle manager)
│   │   ├── context.py   # AddonContext (dependency injection)
│   │   └── builtin.py   # Built-in addon factories + wiring
│   └── components/      # Reusable UI components
├── core/                # Shared state + utilities
│   ├── state.py         # AppState + SystemStatus enum
│   ├── task.py          # Task + TaskStatus (kernel commands)
│   └── llm_config.py    # LLM configuration + behavior tags
└── bootstrap.py         # Application entry point
```

---

## SIGNAL FLOW ARCHITECTURE

### Signal Flow: User Prompt → LLM Response

This is the canonical signal chain every agent should understand:

```
┌─────────────┐
│  User types │ "Hello"
│  in input   │
└─────┬───────┘
      │
      ↓ QLineEdit.returnPressed or btn_send.clicked
┌─────────────────┐
│  PageChat       │
│  .handle_send   │──┐
│    _click()     │  │ Emits sig_generate
└─────────────────┘  │
                     ↓
              ┌──────────────┐
              │ terminal_    │  (in builtin.py)
              │  factory     │  Wiring layer
              │  lambda      │
              └──────┬───────┘
                     │
                     ↓ ctx.bridge.submit(Task)
              ┌──────────────┐
              │  MonoBridge  │
              │  .submit()   │
              └──────┬───────┘
                     │
                     ↓ dock.enqueue(Task)
              ┌──────────────┐
              │  MonoDock    │
              │  .enqueue()  │──┐ Queues task
              └──────────────┘  │
                                ↓ _try_submit()
                         ┌──────────────┐
                         │  MonoGuard   │
                         │  .submit()   │──┐ Routes to engine
                         └──────────────┘  │
                                           ↓ handler(payload)
                                    ┌──────────────┐
                                    │ EngineBridge │
                                    │  .generate() │──┐ Generation gating
                                    └──────────────┘  │
                                                      ↓ impl.generate(payload)
                                               ┌──────────────┐
                                               │  LLMEngine   │
                                               │  .generate() │──┐ Creates worker thread
                                               └──────────────┘  │
                                                                 ↓
                                                          ┌─────────────┐
                                                          │ Generator   │
                                                          │   Worker    │ (QThread)
                                                          └─────┬───────┘
                                                                │
                              ┌─────────────────────────────────┴─────────────────────────┐
                              │  Token stream from llama.cpp                              │
                              └─────────┬─────────────────────────────────────────────────┘
                                        │
                                        ↓ worker.token.emit(text)
                                 ┌──────────────┐
                                 │  LLMEngine   │
                                 │  sig_token   │
                                 └──────┬───────┘
                                        │
                                        ↓ Connected via EngineBridge
                                 ┌──────────────┐
                                 │ EngineBridge │
                                 │  sig_token   │──┐ Generation-gated
                                 └──────────────┘  │
                                                   ↓ Only if _active_gid matches
                                            ┌──────────────┐
                                            │  MonoGuard   │
                                            │  sig_token   │──┐ Verbatim re-emit
                                            └──────────────┘  │
                                                              ↓ Connected in builtin.py
                                                       ┌──────────────┐
                                                       │  PageChat    │
                                                       │  .append_    │
                                                       │   token()    │
                                                       └──────────────┘
                                                              │
                                                              ↓ Accumulates tokens
                                                        [Display in UI]
```

### Key Signal Chains

#### 1. SEND Signal Chain (User → Kernel → Engine)
```
PageChat.sig_generate
  → builtin.terminal_factory lambda
    → MonoBridge.submit(Task)
      → MonoDock.enqueue(Task)
        → MonoDock._try_submit()
          → MonoGuard.submit(Task)
            → engine.generate(payload)
```

#### 2. TOKEN Signal Chain (Engine → Kernel → UI)
```
GeneratorWorker.token.emit(str)
  → LLMEngine.sig_token
    → EngineBridge.sig_token (gated)
      → MonoGuard.sig_token (verbatim)
        → PageChat.append_token()
```

#### 3. STATUS Signal Chain (Engine → Kernel → UI)
```
LLMEngine.set_status(SystemStatus)
  → LLMEngine.sig_status.emit(status)
    → EngineBridge.sig_status
      → MonoGuard.sig_status
        → MonolithUI.update_status()
        → PageChat.update_status()
```

#### 4. STOP Signal Chain (UI → Kernel → Engine)
```
PageChat.sig_stop
  → builtin.terminal_factory lambda
    → MonoBridge.stop("llm")
      → MonoDock.on_stop("llm")
        → MonoGuard.stop("llm")
          → engine.stop_generation()
            → GeneratorWorker.requestInterruption()
```

---

## MONOKERNEL CONTRACT (v2)

> Note: The authoritative contract is `monokernel/Kernel_Contract_v2.txt`.


### Purpose (Non-Negotiable)
MonoGuard is the **sole authority** between UI and engines. Its role is **arbitration, not computation**.

### Authority Rules

#### 1.1 Single Ingress
- All user commands affecting execution **MUST** pass through MonoGuard
- UI **MUST NOT** call engine methods directly
- Addons **MUST NOT** call engine methods directly

#### 1.2 Single Egress
- All execution state, tokens, traces, usage metrics **MUST** pass through MonoGuard
- UI **MUST NOT** subscribe to engine signals directly
- Engines **MUST NEVER** emit directly to UI

### Kernel Scope

**The kernel MAY:**
- Route commands
- Gate execution by system state
- Preempt execution via STOP
- Queue at most one pending command
- Re-emit engine signals verbatim
- Observe system state transitions

**The kernel MUST NOT:**
- Execute business logic
- Perform blocking operations
- Sleep, wait, or poll
- Contain UI logic
- Contain engine logic
- Know what "chat", "LLM", or "RAG" is
- Accumulate feature-specific state

### STOP Semantics (Hard Law)

#### 3.1 STOP Always Wins
When STOP is issued:
- Current execution is interrupted immediately (non-blocking)
- Any pending command is cleared
- Control returns to UI instantly

#### 3.2 Truthful State
`SystemStatus.READY` **MUST** only be emitted when:
- No execution is running
- No engine work is active
- No pending command is executing

The kernel **must never emit READY prematurely**.

### Pending Command Rule

#### 4.1 Single Pending Slot
- Kernel may hold **at most one** pending command
- Pending commands exist **only** to resume after STOP-based preemption

#### 4.2 Replay on READY
- Pending command may execute once when system transitions to READY
- Pending commands are discarded if STOP is explicitly invoked
- No scheduling, prioritization, or batching exists in v1

### Engine Isolation
The engine:
- Is execution-only
- Knows nothing about UI
- Knows nothing about kernel rules
- Knows nothing about addons
- Accepts commands and emits signals **only**

**The kernel adapts the engine; the engine never adapts to the kernel.**

### UI Restrictions
The UI:
- May emit commands freely
- **MUST NOT** assume commands will execute
- **MUST NOT** block waiting for execution
- **MUST** treat kernel signals as authoritative truth

**UI correctness depends on kernel truth, not intent.**

---

## ENGINE ARCHITECTURE

### EnginePort Protocol
All engines implement this protocol (defined in `engine/base.py`):

```python
@runtime_checkable
class EnginePort(Protocol):
    # Required signals
    sig_status: Signal  # SystemStatus transitions
    sig_trace: Signal   # Debug/status messages
    sig_token: Signal   # Text output stream
    
    # Required methods
    def set_model_path(self, payload: dict) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...
```

**Optional signals** (check with `hasattr` before use):
- `sig_usage`: Token/step count tracking (LLM-specific)
- `sig_image`: Image output (Vision engines)
- `sig_audio`: Audio output (Audio engines)
- `sig_finished`: Optional completion notification

### EngineBridge Pattern

**Purpose**: Generation gating to prevent signals from stale generations reaching the UI.

**Mechanism**:
```python
# Each generate() call gets a unique generation ID
self._gen_id += 1
gid = self._gen_id
self._active_gid = gid
self._connect_gated_handlers(gid)

# Signals only emit if gid matches _active_gid
lambda t, gid=gid: self.sig_token.emit(t) if self._active_gid == gid else None
```

**Result**: When `stop_generation()` is called, the generation ID increments, and all signals from the previous generation are automatically ignored.

### Engine Implementations

#### LLMEngine (`engine/llm.py`)
**State Machine**:
```
READY → set_model_path() → READY
READY → load_model() → LOADING → READY | ERROR
READY → generate() → RUNNING → READY | ERROR
RUNNING → stop_generation() → READY
READY → unload_model() → UNLOADING → READY
```

**Worker Threads**:
- `ModelLoader`: Loads GGUF via llama-cpp-python
- `GeneratorWorker`: Streaming inference with interruption support

**Conversation Management**:
- Maintains `conversation_history: list[dict]` with roles: system, user, assistant
- System prompt injection: `[{role: system, content: prompt}, {role: system, content: CONTEXT: ...}, ...]`
- Pending user index tracking for UPDATE semantics

#### VisionEngine (`engine/vision.py`)
**State Machine**: Same as LLMEngine

**Worker Threads**:
- `PipelineLoader`: Loads Stable Diffusion via diffusers
- `GenerationWorker`: Step-based image generation with callbacks

**Signals**:
- `sig_image`: Emits PIL Image objects
- `sig_trace`: Step progress messages
- No `sig_token` (not text-based)

---

## ADDON SYSTEM

### Addon Types

**Two kinds**:
1. **Page addons** (`kind="page"`): Full-screen views in main content area
2. **Module addons** (`kind="module"`): Stackable floating modules with icons in module strip

### AddonSpec
```python
@dataclass(frozen=True)
class AddonSpec:
    id: str                                    # Unique identifier
    kind: Literal["page", "module"]           # Addon type
    title: str                                # Display name
    icon: str | None                          # Unicode icon or None
    factory: Callable[[AddonContext], QWidget] # Widget constructor
```

### AddonContext (Dependency Injection)
```python
@dataclass
class AddonContext:
    state: AppState        # Shared application state
    guard: MonoGuard       # Kernel signal router
    bridge: MonoBridge     # Task submission API
    ui: MonolithUI | None  # Main window (for modules)
    host: AddonHost | None # Addon lifecycle manager
```

### Addon Lifecycle

#### Page Addon
```python
# Mounted once, lives forever
def addons_page_factory(ctx: AddonContext) -> QWidget:
    w = PageAddons(ctx.state)
    # Wire signals
    return w

# Registration
registry.register(AddonSpec(
    id="addons",
    kind="page",
    title="ADDONS",
    icon=None,
    factory=addons_page_factory
))

# Mounting
host.mount_page("addons")  # Returns cached widget if exists
```

#### Module Addon
```python
# Created fresh each launch, gets unique instance ID
def terminal_factory(ctx: AddonContext) -> QWidget:
    w = PageChat(ctx.state)
    
    # OUTGOING (addon → kernel)
    w.sig_generate.connect(
        lambda prompt: ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "generate", "llm", 
                          payload={"prompt": prompt, "config": w.config})
        )
    )
    w.sig_stop.connect(lambda: ctx.bridge.stop("llm"))
    
    # INCOMING (kernel → addon)
    ctx.guard.sig_token.connect(w.append_token)
    ctx.guard.sig_trace.connect(w.append_trace)
    ctx.guard.sig_status.connect(w.update_status)
    
    return w

# Registration
registry.register(AddonSpec(
    id="terminal",
    kind="module",
    title="TERMINAL",
    icon="⌖",
    factory=terminal_factory
))

# Launching
instance_id = host.launch_module("terminal")  # Creates new instance
```

### Signal Wiring Pattern

**Critical**: Addon factories are responsible for **all signal wiring** between:
- Addon widgets and MonoBridge (outgoing commands)
- MonoGuard and addon widgets (incoming signals)

**Why**: Keeps wiring logic co-located with addon definition, making signal flows explicit.

---

## TASK QUEUE SYSTEM

### Task Structure
```python
@dataclass
class Task:
    id: UUID              # Unique task identifier
    addon_pid: str        # Addon instance that created task
    target: str           # Engine key ("llm", "vision", etc.)
    command: str          # Command verb ("generate", "load", etc.)
    payload: dict         # Command-specific data
    priority: int         # 1=STOP, 2=normal, 3+=low priority
    status: TaskStatus    # PENDING/RUNNING/DONE/FAILED/CANCELLED
    timestamp: float      # Creation time
```

### Task Priority System
- **Priority 1**: STOP commands (preempt everything)
- **Priority 2**: Normal commands (FIFO within priority)
- **Priority 3+**: Low priority (future use)

### MonoDock Queue Behavior

**Per-engine queues**:
```python
queues: dict[str, Deque[Task]] = {
    "llm": deque([task1, task2, task3]),
    "vision": deque([task4, task5])
}
```

**Insertion logic** (`_insert_task`):
- Priority 2 tasks: Insert at end of priority-2 group (maintain FIFO within priority)
- Priority 3+ tasks: Append to end of queue
- Priority 1 tasks: Don't queue, immediately call `on_stop()`

**Execution logic** (`_try_submit`):
1. Check if engine has active task (via `MonoGuard.active_tasks`)
2. If busy, wait for `sig_engine_ready` signal
3. When ready, pop front of queue, check if cancelled
4. Submit to `MonoGuard.submit()`, which calls engine method
5. If submission fails, leave task in queue

**Cancellation**:
```python
cancelled_task_ids: set[str]   # Specific task cancellation
cancelled_addons: set[str]     # All tasks from this addon

def _is_cancelled(task: Task) -> bool:
    return (str(task.id) in cancelled_task_ids or 
            task.addon_pid in cancelled_addons)
```

### MonoGuard Task Routing

**Dispatch table**:
```python
ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}
```

**Submission flow**:
```python
def submit(self, task: Task) -> bool:
    engine = self.engines.get(task.target)
    if self.active_tasks[task.target] is not None:
        return False  # Engine busy
    
    self.active_tasks[task.target] = task
    task.status = TaskStatus.RUNNING
    
    method_name = ENGINE_DISPATCH[task.command]
    handler = getattr(engine, method_name)
    handler(task.payload)  # or handler() for no-arg commands
    return True
```

---

## BOOTSTRAP SEQUENCE

### Startup Order (bootstrap.py)
```python
1. QApplication()
2. AppState()
3. LLMEngine(state) + VisionEngine(state)
4. EngineBridge(llm) + EngineBridge(vision)
5. MonoGuard(state, engines)
6. MonoDock(guard)
7. MonoBridge(dock)
8. MonolithUI(state)
9. AddonRegistry + build_builtin_registry()
10. AddonContext(state, guard, bridge, ui, host=None)
11. AddonHost(registry, ctx)
12. ui.attach_host(host)
13. Wire global signals (guard → ui)
14. ui.show()
15. app.exec()
```

### Global Signal Wiring
```python
# System-wide status updates
guard.sig_status.connect(ui.update_status)

# Token usage tracking (LLM only)
guard.sig_usage.connect(ui.update_ctx)

# Shutdown sequence
app.aboutToQuit.connect(guard.stop)
app.aboutToQuit.connect(engine.shutdown)
app.aboutToQuit.connect(vision_engine.shutdown)
```

---

## CRITICAL PATTERNS

### Pattern 1: Generation Gating (EngineBridge)
**Problem**: After `stop_generation()`, stale tokens from cancelled generation still arrive
**Solution**: Generation ID gating
```python
# Old generation (gid=5) emits token after stop (gid=6)
lambda t, gid=5: self.sig_token.emit(t) if self._active_gid == 6 else None
# Result: Signal dropped, UI sees nothing
```

### Pattern 2: Signal Re-emission (MonoGuard)
**Problem**: Kernel must route signals without transforming them
**Solution**: Verbatim re-emit
```python
engine.sig_token.connect(self.sig_token)  # Direct passthrough
```

### Pattern 3: Factory-based Wiring (Addons)
**Problem**: Signal connections need to be explicit and traceable
**Solution**: All wiring happens in addon factory functions
```python
def terminal_factory(ctx):
    w = PageChat(ctx.state)
    # ALL WIRING HERE — visible in one place
    w.sig_generate.connect(lambda p: ctx.bridge.submit(...))
    ctx.guard.sig_token.connect(w.append_token)
    return w
```

### Pattern 4: UPDATE Semantics (Chat)
**Problem**: User types new prompt while generation is running
**Solution**: Tri-state SEND/STOP/UPDATE
```python
if not self._is_running:
    self.send()  # Normal send
elif not txt:
    self.sig_stop.emit()  # STOP button
else:
    self._pending_update_text = txt
    self._awaiting_update_restart = True
    self.sig_stop.emit()
    # On sig_engine_ready, re-submit with UPDATE prompt
```

### Pattern 5: Non-blocking Kernel (MonoGuard)
**Problem**: Kernel must never block
**Solution**: All engine calls are async via QThread
```python
# ✅ CORRECT
worker = GeneratorWorker(...)
worker.start()  # Returns immediately

# ❌ WRONG
result = model.generate(...)  # Blocks kernel!
```

### Pattern 6: Status Truth (MonoGuard)
**Problem**: UI needs reliable state
**Solution**: Kernel is single source of truth
```python
# UI must never assume:
self.send()  # ❌ Assumes execution will happen

# UI must react to signals:
def update_status(self, engine_key, status):
    if status == SystemStatus.READY:
        self.btn_send.setEnabled(True)  # ✅ React to truth
```

---

## IMPLEMENTATION DETAILS

### SystemStatus Enum
```python
class SystemStatus(Enum):
    READY = "READY"         # Engine idle, can accept commands
    LOADING = "LOADING"     # Model loading in progress
    RUNNING = "RUNNING"     # Generation in progress
    ERROR = "ERROR"         # Error occurred (auto-transitions to READY)
    UNLOADING = "UNLOADING" # Model unloading in progress
```

### TaskStatus Enum
```python
class TaskStatus(Enum):
    PENDING = "PENDING"       # Queued, not yet submitted
    RUNNING = "RUNNING"       # Submitted to engine
    DONE = "DONE"             # Completed successfully
    FAILED = "FAILED"         # Error occurred
    CANCELLED = "CANCELLED"   # Explicitly cancelled
```

### Behavior Tag System (LLM Config)
**Location**: `core/llm_config.py`

**Mechanism**: User selects tags → combined prompts injected into system message

```python
TAG_MAP = {
    "concise": "Be extremely concise. Omit pleasantries.",
    "technical": "Assume expert-level technical knowledge.",
    # ... more tags
}

# User selects ["concise", "technical"]
# → System prompt becomes:
# "You are Monolith. Be precise.\n\nBe extremely concise...\n\nAssume expert-level..."
```

### Context Injection (Injector Module)
**Location**: `ui/modules/injector.py`

**Mechanism**: Runtime context dynamically inserted into system messages before generation

```python
# In LLMEngine.generate():
if context_injection:
    self.conversation_history.insert(1, {
        "role": "system",
        "content": f"CONTEXT: {context_injection}"
    })
```

**Use case**: Add file contents, notes, or dynamic data to every generation without modifying system prompt.

### Module Strip (UI Component)
**Location**: `ui/components/module_strip.py`

**Features**:
- Horizontal scrollable icon strip
- Overflow arrows (left/right) when modules exceed width
- Module flashing on `sig_finished` (visual completion notification)
- Click to switch module, close button to remove

**Critical**: Module IDs are UUID strings, not addon IDs (allows multiple instances of same addon)

### Conversation History (LLM)
**Structure**:
```python
[
    {"role": "system", "content": "You are Monolith. Be precise."},
    {"role": "system", "content": "CONTEXT: <injector contents>"},
    {"role": "user", "content": "Hello"},
    {"role": "assistant", "content": "Hi there!"},
    {"role": "user", "content": "How are you?"},
    # ... continues
]
```

**UPDATE semantics**:
- On normal send: append user message, create pending assistant slot
- On stop: remove pending user message if generation didn't complete
- On resume: inject special user message "You were interrupted mid-generation. Continue from: {last_text}"

---

## DEBUGGING SIGNAL FLOWS

### Trace Signal Path
To trace a signal from UI → Kernel → Engine:

1. **Find the UI trigger**
   - Example: `btn_send.clicked` → `handle_send_click()`

2. **Locate the signal emission**
   - Example: `self.sig_generate.emit(txt)`

3. **Find the addon factory wiring**
   - Example: In `terminal_factory()`: `w.sig_generate.connect(lambda p: ctx.bridge.submit(...))`

4. **Trace through MonoBridge/MonoDock**
   - `bridge.submit(task)` → `dock.enqueue(task)` → `dock._try_submit()`

5. **Trace through MonoGuard**
   - `guard.submit(task)` → `engine.generate(payload)`

6. **Trace engine implementation**
   - `LLMEngine.generate()` → `worker.start()`

7. **Trace return signal path**
   - `worker.token.emit()` → `LLMEngine.sig_token` → `EngineBridge.sig_token` → `MonoGuard.sig_token` → `PageChat.append_token()`

### Trace System Status Changes
```
User clicks LOAD MODEL
  → PageChat.toggle_load()
    → sig_load.emit()
      → bridge.submit(wrap("terminal", "load", "llm"))
        → guard.submit(task)
          → engine.load_model()
            → sig_status.emit(LOADING)
              → guard.sig_status.emit("llm", LOADING)
                → ui.update_status("llm", LOADING)
                  → PageChat.update_status("llm", LOADING)
                    → btn_load.setText("LOADING...")

ModelLoader finishes
  → LLMEngine._on_load_success()
    → set_status(READY)
      → sig_status.emit(READY)
        → guard.sig_status.emit("llm", READY)
          → ui.update_status("llm", READY)
            → PageChat.update_status("llm", READY)
              → btn_load.setText("UNLOAD MODEL")
```

---

## EXTENDING MONOLITH

### Adding a New Engine

1. **Implement EnginePort protocol** (`engine/your_engine.py`)
```python
class YourEngine(QObject):
    sig_status = Signal(SystemStatus)
    sig_trace = Signal(str)
    sig_token = Signal(str)
    sig_your_output = Signal(object)  # Optional custom signal
    
    def __init__(self, state: AppState):
        self.state = state
        self._status = SystemStatus.READY
    
    def set_model_path(self, payload: dict) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...
```

2. **Wrap in EngineBridge** (`bootstrap.py`)
```python
your_engine_impl = YourEngine(state)
your_engine = EngineBridge(your_engine_impl)
```

3. **Register with MonoGuard** (`bootstrap.py`)
```python
guard = MonoGuard(state, {
    "llm": engine,
    "vision": vision_engine,
    "your": your_engine,  # Add here
})
```

4. **Wire optional signals** (`monokernel/guard.py` → `__init__`)
```python
if hasattr(engine, "sig_your_output"):
    engine.sig_your_output.connect(self.sig_your_output)
```

5. **Create addon factory** (`ui/addons/builtin.py`)
```python
def your_module_factory(ctx: AddonContext):
    w = YourModuleWidget()
    w.sig_generate.connect(
        lambda prompt: ctx.bridge.submit(
            ctx.bridge.wrap("your_module", "generate", "your", payload={...})
        )
    )
    ctx.guard.sig_your_output.connect(w.on_output)
    return w
```

6. **Register addon**
```python
registry.register(AddonSpec(
    id="your_module",
    kind="module",
    title="YOUR MODULE",
    icon="★",
    factory=your_module_factory
))
```

### Adding a New Addon

1. **Create widget** (`ui/pages/` or `ui/modules/`)
```python
class YourWidget(QWidget):
    sig_action = Signal(str)  # Define outgoing signals
    
    def __init__(self):
        super().__init__()
        # Build UI
    
    def handle_input(self, data):
        # Incoming signal handler
        pass
```

2. **Create factory** (`ui/addons/builtin.py`)
```python
def your_factory(ctx: AddonContext):
    w = YourWidget()
    
    # OUTGOING
    w.sig_action.connect(
        lambda data: ctx.bridge.submit(
            ctx.bridge.wrap("your_addon", "command", "target", payload={...})
        )
    )
    
    # INCOMING
    ctx.guard.sig_some_signal.connect(w.handle_input)
    
    return w
```

3. **Register** (`ui/addons/builtin.py` → `build_builtin_registry()`)
```python
registry.register(AddonSpec(
    id="your_addon",
    kind="module",  # or "page"
    title="YOUR ADDON",
    icon="◆",
    factory=your_factory
))
```

4. **Add launcher** (if module, add to `ui/modules/manager.py`)
```python
btn_your = SkeetButton("YOUR ADDON")
btn_your.clicked.connect(lambda: self.sig_launch_addon.emit("your_addon"))
```

---

## AGENT QUICK REFERENCE

### When implementing UI changes:
- ✅ Emit signals from widgets
- ❌ Don't call kernel/engine methods directly
- ✅ Connect signals in addon factories
- ❌ Don't assume commands will execute

### When implementing engine changes:
- ✅ Follow EnginePort protocol
- ❌ Don't emit UI-specific signals
- ✅ Use QThread for blocking operations
- ❌ Don't know about kernel rules

### When implementing kernel changes:
- ⚠️ **STOP**: Kernel contract is FROZEN (v1)
- ⚠️ Any change requires architectural review
- ✅ If you must: version bump, not patch

### When debugging signal flows:
1. Find UI emission point
2. Locate addon factory wiring
3. Trace through bridge/dock/guard
4. Find engine handler
5. Trace return path backward

### When reading code:
- Signal chains: Follow `.connect()` calls
- Task flow: Start at `MonoBridge.submit()`
- Status changes: Track `sig_status.emit()`
- Generation flow: Start at `engine.generate()`

---

## APPENDIX: FILE LOCATIONS

### Core Contracts
- `monokernel/kernel_contract.md` — Kernel rules (FROZEN)
- `monokernel/Kernel_Contract_v2.txt` — Authoritative kernel contract (v2).
- `engine/base.py` — EnginePort protocol

### Signal Routing
- `monokernel/guard.py` — MonoGuard (signal router)
- `monokernel/dock.py` — MonoDock (task queue)
- `monokernel/bridge.py` — MonoBridge (UI→Kernel API)
- `engine/bridge.py` — EngineBridge (generation gating)

### Engine Implementations
- `engine/llm.py` — LLM engine (llama-cpp-python)
- `engine/vision.py` — Vision engine (diffusers)

### Addon System
- `ui/addons/spec.py` — AddonSpec definition
- `ui/addons/registry.py` — AddonRegistry
- `ui/addons/host.py` — AddonHost (lifecycle)
- `ui/addons/context.py` — AddonContext (DI)
- `ui/addons/builtin.py` — Built-in addon factories + wiring

### UI Components
- `ui/main_window.py` — Main chrome + global signals
- `ui/pages/chat.py` — Chat/Terminal interface
- `ui/modules/sd.py` — Vision module
- `ui/modules/injector.py` — Context injector
- `ui/components/atoms.py` — Basic widgets
- `ui/components/complex.py` — Compound widgets
- `ui/components/module_strip.py` — Module icon strip

### Configuration
- `core/state.py` — AppState + SystemStatus
- `core/task.py` — Task + TaskStatus
- `core/llm_config.py` — LLM config + behavior tags
- `core/style.py` — UI styling constants

### Bootstrap
- `bootstrap.py` — Application entry point
- `main.py` — Thin wrapper around bootstrap

---

## FINAL NOTES FOR AGENTS

**This document captures implicit knowledge that would otherwise require:**
- Reading 15+ files
- Tracing signal chains across 5+ layers
- Understanding frozen contracts vs. extensible systems
- Discovering generation gating patterns
- Mapping task lifecycle through queue system

**Everything is here. No archaeology required.**

**When in doubt:**
1. Check kernel contract (FROZEN)
2. Trace signal chain (this doc)
3. Follow EnginePort protocol
4. Wire in addon factory
5. Test with VITALS pattern (sig_status transitions)

**Remember**: MonoKernel decides WHEN. Engines decide WHAT. UI reacts to truth.



================================================================================
FILE: .\.claude\worktrees\gallant-allen\README\Kernel_Contract_v2.txt
================================================================================

MONOLITH KERNEL CONTRACT — v2 (FROZEN)
0. Purpose

The Monolith kernel is a four-layer execution hierarchy:

UI → MonoBridge → MonoDock → MonoGuard → Engines

SIGNAL PASSTHROUGH LAW: Every command string in ENGINE_DISPATCH must have a matching method on EngineBridge. If guard.py dispatches to it, bridge.py must forward it. Violation = silent permanent queue deadlock. When adding any new command: update ENGINE_DISPATCH, add handler on LLMEngine, and add passthrough on EngineBridge. All three or none.
Three flows. No exceptions.

Flow	Direction	Behavior
Commands	Downward	UI → Bridge → Dock → Guard → Engine
State	Upward	Engine → Guard → UI
STOP	Instant	Bypasses queues, executes immediately

All execution-affecting functionality routes around this structure, never into it.

1. Authority Gradient

MonoGuard is the sole authority.

Only MonoGuard may:

Initiate engine execution

Interrupt engine execution

Transition engine state

Emit READY

Clear active work

MonoBridge and MonoDock are non-authoritative. They translate, organize, and route. They do not execute or decide.

2. Component Contracts
2.1 MonoBridge (Translator)

Role: Normalize UI intent into Task submission and control requests.

Interface:


def wrap(source: str, command: str, target: str, **kwargs) -> Task
def submit(task: Task) -> None                  # forwards to MonoDock.enqueue
def cancel(task_id: str) -> None                # forwards to MonoDock.cancel_task
def cancel_addon(addon_pid: str) -> None        # forwards to MonoDock.cancel_addon
def stop(target: str = "all") -> None           # forwards STOP to MonoDock.on_stop


Rules:

Creates Task with unique ID, timestamp, payload, origin metadata

Forwards Tasks to MonoDock (never directly to MonoGuard)

For cancel/stop: forwards requests to MonoDock (does not mutate queued state)

Must not:

Queue tasks

Block

Execute engines

Inspect payload semantics

Mutate MonoDock-owned task state

2.2 MonoDock (Organizer)

Role: Queue, prioritize, cancel, and submit Tasks prior to arbitration.

Interface:


def enqueue(task: Task) -> None
def cancel_task(task_id: str) -> None
def cancel_addon(addon_pid: str) -> None
def on_stop(target: str = "all") -> None


State:

queues: dict[str, deque[Task]]        # per-engine FIFO queues (priority-aware)
cancelled_task_ids: set[str]          # fast cancel filter
cancelled_addons: set[str]            # fast cancel filter (by addon_pid)


Rules:

Maintains per-target priority queues (FIFO within same priority)

Filters cancelled tasks before submission

Submits to MonoGuard via guard.submit(task) only

If guard.submit(task) returns False (engine busy): waits for guard.sig_engine_ready(engine_key) to retry

On STOP:

issues immediate stop to MonoGuard (no queue)

marks queued tasks for that target as cancelled (by id or by target sweep)

May request Guard STOP if a cancelled task is currently active (Dock-driven, not Bridge-driven)

Must not:

Execute engines

Emit state signals

Mutate MonoGuard internals

Synthesize READY

Override or delay STOP

2.3 MonoGuard (Authority)

Role: Final execution arbiter.

Interface:


def submit(task: Task) -> bool        # True if accepted, False if engine busy
def stop(target: str = "all") -> None


State:

engines: dict[str, EnginePort]            # registered engines by key
active_tasks: dict[str, Task | None]      # one active task per engine


Signals:

sig_status: Signal(str, SystemStatus)     # (engine_key, status) — authoritative
sig_engine_ready: Signal(str)             # engine_key — emitted only on truthful READY
sig_token: Signal(str)                    # passthrough from engine
sig_trace: Signal(str)                    # passthrough from engine
sig_image: Signal(object)                 # passthrough from engine (optional)
sig_finished: Signal(str, str)            # (engine_key, task_id) optional convenience


Rules:

Routes by task.target engine key

Does not validate payload semantics (engine’s job)

Re-emits engine signals verbatim

Emits sig_engine_ready(engine_key) only when that engine is truthfully READY

Enforces: one active Task per engine

On STOP(target):

interrupts target engine(s) immediately (non-blocking)

clears relevant active_tasks

emits authoritative status transitions

On engine ERROR:

emits status ERROR

clears active task

transitions back to READY (no stuck states)

Dispatch rule (non-semantic):
MonoGuard must not grow command-specific business logic. It may only perform mechanical dispatch to the target engine.

Canonical pattern:

ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}


MonoGuard performs method lookup and calls the engine; payload interpretation remains engine-specific.

Must not:

Perform business logic

Block or sleep

Inspect payload meaning

Contain UI logic

Accumulate feature-specific state

2.4 Engines (Workers)

Role: Execute work, emit results.

Rules:

Must implement EnginePort protocol

Must not know about MonoBridge, MonoDock, MonoGuard internals, or UI

Must not emit directly to UI

Must support stop_generation() as an interrupt

3. EnginePort Protocol

All engines implement this interface:

@runtime_checkable
class EnginePort(Protocol):
    # Signals
    sig_status: Signal      # SystemStatus
    sig_trace: Signal       # str
    sig_token: Signal       # str (text stream output, optional)
    sig_image: Signal       # object (image output, optional)
    sig_finished: Signal    # () optional

    # Methods
    def set_model_path(self, path: str) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...


Payload interpretation is engine-specific:

LLM reads payload["prompt"], payload["config"]

Vision reads payload["prompt"], payload["steps"], payload["seed"]

MonoGuard does not interpret payload content.

4. Task Model (Canonical)

Each command becomes exactly one Task:

@dataclass
class Task:
    id: UUID                    # unique identifier
    addon_pid: str              # source addon instance
    target: str                 # engine key ("llm", "vision", etc.)
    command: str                # "generate", "load", "unload", "set_path", "stop"
    payload: dict               # command-specific data
    priority: int               # 1=STOP, 2=normal, 3=background
    status: TaskStatus          # PENDING/RUNNING/DONE/FAILED/CANCELLED
    timestamp: float            # creation time


Priority semantics:

Priority	Name	Behavior
1	STOP	Bypasses queues, executes immediately
2	Normal	Standard FIFO
3	Background	Yields to normal priority
5. Cancellation vs STOP

Two distinct operations:

Operation	Scope	Effect
Cancel	Task or addon	Prevents queued execution; active execution may be stopped by Dock→Guard
STOP	Engine or all	Interrupts active execution immediately; clears active task; cancels queued tasks for target

Cancel flow:

UI → Bridge.cancel(task_id)
  → Dock.cancel_task(task_id)
  → Dock filters cancelled tasks on submission
  → If cancelled task is active: Dock calls Guard.stop(task.target)


STOP flow:

UI → Bridge.stop(target)
  → Dock.on_stop(target)
  → Guard.stop(target)
  → Engine.stop_generation()
  → Engine emits sig_status(READY)
  → Guard emits sig_engine_ready(target)
  → Dock submits next non-cancelled task


STOP is idempotent. Repeated calls have no additional effect.

6. Execution Model

Concurrency

Multiple engines may execute concurrently

Only one Task per engine at a time

State truth

MonoGuard is the sole source of execution state

UI subscribes to Guard signals, never Engine signals

READY means: no active task and accepting new work

Error handling

Engine errors emit sig_status(ERROR)

MonoGuard clears the active task and transitions back to READY

No stuck states

7. Stability Guarantees

Breaking any of the following requires a major contract revision:

Single ingress via MonoBridge

Single egress via MonoGuard

STOP dominance — always priority 1, always immediate

Non-blocking MonoGuard — no sleeps, no waits

Engine isolation — engines know nothing about kernel/UI

One active Task per engine

Truthful READY — emitted only when genuinely idle

8. Extension Rules

Does not belong in kernel if:

Feature can be removed without changing MonoGuard

Feature is UI-specific

Feature is engine-specific (model config, output format)

Requires new kernel version if:

MonoGuard behavior must change

New signal flow pattern required

Authority gradient modified

9. Future Compatibility

Process isolation ready:

MonoBridge may become IPC broker

Task model and authority gradient unchanged

Engines may run in separate processes

New engine registration:

Add key to guard.engines dict

Implement EnginePort

No MonoGuard logic changes required

One-Line Summary

The kernel decides when and where — never what.



================================================================================
FILE: .\.claude\worktrees\gallant-allen\README\requirement.txt
================================================================================

PySide6>=6.10.0
llama-cpp-python>=0.3.0
audiocraft>=1.3.0
torch>=2.4.0
torchaudio>=2.4.0
diffusers>=0.35.0
transformers>=4.57.0
accelerate>=1.11.0



================================================================================
FILE: .\.claude\worktrees\gallant-allen\README\LEGACY\kernel_contract_v1.md
================================================================================

MONOLITH KERNEL CONTRACT — v1 (FROZEN)
0. Purpose (Non-Negotiable)

The Monolith kernel (MonoGuard) is the sole authority between UI and execution engines.

Its role is arbitration, not computation.

All future functionality must route around the kernel, not into it.

1. Authority Rules

1.1 Single Ingress
All user-initiated commands that affect execution MUST pass through MonoGuard.

UI must not call engine methods directly.

Addons must not call engine methods directly.

1.2 Single Egress
All execution state, tokens, traces, and usage metrics MUST pass through MonoGuard.

UI must not subscribe to engine signals directly.

Engines must never emit directly to UI.

2. Kernel Scope

The kernel MAY:

Route commands

Gate execution by system state

Preempt execution via STOP

Queue at most one pending command

Re-emit engine signals verbatim

Observe system state transitions

The kernel MUST NOT:

Execute business logic

Perform blocking operations

Sleep, wait, or poll

Contain UI logic

Contain engine logic

Know what “chat”, “LLM”, or “RAG” is

Accumulate feature-specific state

3. STOP Semantics (Hard Law)

3.1 STOP Always Wins

When STOP is issued:

Current execution is interrupted immediately (non-blocking)

Any pending command is cleared

Control returns to the UI instantly

3.2 Truthful State

SystemStatus.READY MUST only be emitted when:

No execution is running

No engine work is active

No pending command is executing

The kernel must never emit READY prematurely.

4. Pending Command Rule

4.1 Single Pending Slot

The kernel may hold at most one pending command.

Pending commands exist only to resume after STOP-based preemption.

4.2 Replay on READY

A pending command may execute once when the system transitions to READY.

Pending commands are discarded if STOP is explicitly invoked.

No scheduling, prioritization, or batching exists in v1.

5. Engine Isolation

The engine:

Is execution-only

Knows nothing about UI

Knows nothing about kernel rules

Knows nothing about addons

Accepts commands and emits signals only

The kernel adapts the engine; the engine never adapts to the kernel.

6. UI Restrictions

The UI:

May emit commands freely

Must not assume commands will execute

Must not block waiting for execution

Must treat kernel signals as authoritative truth

UI correctness depends on kernel truth, not intent.

7. Stability Guarantee

Any future change that violates:

Single ingress

Single egress

STOP dominance

Non-blocking kernel behavior

breaks the kernel contract and must be treated as a major architectural change.

8. Extension Rule

If a feature:

Can be removed without breaking the kernel
→ it does not belong in the kernel.

If a feature:

Requires changing kernel behavior
→ it is a kernel version bump, not a feature patch.

9. Freeze Declaration

This kernel contract is considered frozen as of this state.

Future development must build above this boundary unless explicitly redesigning the kernel.

One-Line Summary

The kernel decides when things may happen — never what happens.



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\bridge.py
================================================================================

from PySide6.QtCore import QObject, Signal


class UIBridge(QObject):
    sig_terminal_header = Signal(str, str, str)
    sig_apply_operator = Signal(dict)
    sig_open_overseer = Signal()
    sig_overseer_viz_toggle = Signal(bool)
    sig_theme_changed = Signal(str)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\main_window.py
================================================================================

from typing import Optional

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QFrame, QLabel, QStackedLayout
)
from PySide6.QtCore import Qt, QDateTime, QTimer
from PySide6.QtGui import QMouseEvent

from core.state import SystemStatus, AppState
from ui.bridge import UIBridge
from core.style import BG_MAIN, BG_SIDEBAR, FG_ACCENT, FG_ERROR, FG_WARN
from ui.addons.host import AddonHost
from ui.components.atoms import SidebarButton
from ui.components.complex import GradientLine, VitalsWindow, SplitControlBlock
from ui.components.module_strip import ModuleStrip

class MonolithUI(QMainWindow):
    def __init__(self, state: AppState, ui_bridge: UIBridge):
        super().__init__()
        self.state = state
        self.ui_bridge = ui_bridge
        self.vitals_win = None
        self._drag_pos = None
        self._chat_title = "Untitled Chat"
        self._terminal_titles: dict[str, tuple[str, str]] = {}

        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.resize(1100, 700)

        main_widget = QWidget()
        main_widget.setObjectName("MainFrame")
        main_widget.setStyleSheet(f"""
            QWidget {{ background: {BG_MAIN}; }}
            QWidget#MainFrame {{ border: 1px solid #333; }}
        """)
        self.setCentralWidget(main_widget)

        root_layout = QVBoxLayout(main_widget)
        root_layout.setContentsMargins(1,1,1,1)
        root_layout.setSpacing(0)

        # Top Gradient
        self.gradient_line = GradientLine()
        root_layout.addWidget(self.gradient_line)

        # Top Bar
        self.top_bar = self._build_top_bar()
        root_layout.addWidget(self.top_bar)

        content_layout = QHBoxLayout()
        content_layout.setSpacing(0)

        # --- SIDEBAR ---
        self.sidebar = QFrame()
        self.sidebar.setFixedWidth(70)
        self.sidebar.setStyleSheet(f"background: {BG_SIDEBAR}; border-right: 1px solid #1a1a1a;")
        
        sidebar_layout = QVBoxLayout(self.sidebar)
        sidebar_layout.setContentsMargins(5, 15, 5, 15)
        sidebar_layout.setSpacing(10)

        self.module_strip = ModuleStrip()
        self.module_strip.sig_module_selected.connect(self.switch_to_module)
        self.module_strip.sig_module_closed.connect(self.close_module)

        self.btn_hub = SidebarButton("◉", "HUB")
        self.btn_hub.clicked.connect(lambda: self.set_page("hub"))

        self.btn_addons = SidebarButton("＋", "ADDONS")
        self.btn_addons.clicked.connect(lambda: self.set_page("addons"))

        sidebar_layout.addWidget(self.module_strip)
        sidebar_layout.addStretch() 
        sidebar_layout.addWidget(self.btn_hub)
        sidebar_layout.addWidget(self.btn_addons)

        content_layout.addWidget(self.sidebar)

        # --- PAGE STACK ---
        self.stack = QStackedLayout()
        self.host: Optional[AddonHost] = None
        self.pages = {}

        self.empty_page = QWidget()
        self.stack.addWidget(self.empty_page)
        self.pages["empty"] = self.empty_page

        self.center_vbox = QVBoxLayout()
        self.center_vbox.addLayout(self.stack)
        content_layout.addLayout(self.center_vbox)

        root_layout.addLayout(content_layout)

        # --- Bottom status bar ---
        bottom_bar = QHBoxLayout()
        bottom_bar.setContentsMargins(0, 0, 8, 2)
        bottom_bar.addStretch()
        self.lbl_status = QLabel("READY")
        self.lbl_status.setStyleSheet(f"color: #555; font-size: 8px; font-weight: bold; background: transparent;")
        bottom_bar.addWidget(self.lbl_status)
        root_layout.addLayout(bottom_bar)

        # --- Time update timer ---
        self._time_timer = QTimer(self)
        self._time_timer.timeout.connect(self._update_time_display)
        self._time_timer.start(60000)

        self.ui_bridge.sig_terminal_header.connect(self.update_terminal_header)

    def attach_host(self, host: AddonHost) -> None:
        self.host = host
        hub = host.mount_page("hub")
        addons = host.mount_page("addons")

        self.stack.addWidget(hub)
        self.pages["hub"] = hub

        self.stack.addWidget(addons)
        self.pages["addons"] = addons

        self.set_page("hub")

    # ---------------- WINDOW BEHAVIOR ----------------

    def mousePressEvent(self, event: QMouseEvent):
        if event.button() == Qt.LeftButton and event.position().y() < 40:
            self._drag_pos = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
            event.accept()

    def mouseMoveEvent(self, event: QMouseEvent):
        if self._drag_pos and event.buttons() == Qt.LeftButton:
            self.move(event.globalPosition().toPoint() - self._drag_pos)
            event.accept()
            
    def mouseReleaseEvent(self, event: QMouseEvent):
        self._drag_pos = None

    # ---------------- MODULE SYSTEM ----------------

    def close_module(self, mod_id):
        current = self.stack.currentWidget()
        target_w = None
        for i in range(self.stack.count()):
            w = self.stack.widget(i)
            if getattr(w, '_mod_id', None) == mod_id:
                target_w = w
                break
        
        if target_w:
            self.stack.removeWidget(target_w)
            target_w.deleteLater()
            
        self.module_strip.remove_module(mod_id)

        if current == target_w:
            remaining = self.module_strip.get_order()
            if remaining:
                self.switch_to_module(remaining[-1])
            else:
                self.set_page("empty")

    def switch_to_module(self, mod_id):
        for i in range(self.stack.count()):
            w = self.stack.widget(i)
            if getattr(w, '_mod_id', None) == mod_id:
                self.stack.setCurrentWidget(w)
                self._update_sidebar_state(module_selection=True)
                self.module_strip.select_module(mod_id)
                self.lbl_monolith.setVisible(True)
                # Only show chat title for terminal modules
                if getattr(w, '_addon_id', None) == "terminal":
                    self.update_terminal_header(mod_id, *self._terminal_titles.get(mod_id, ("Untitled Chat", QDateTime.currentDateTime().toString("ddd • HH:mm"))))
                else:
                    self.lbl_chat_title.hide()
                    self.lbl_chat_time.hide()
                return

    def _update_sidebar_state(self, page_idx=None, module_selection=False):
        self.btn_hub.setChecked(page_idx == "hub" and not module_selection)
        self.btn_addons.setChecked(page_idx == "addons" and not module_selection)
        if not module_selection: self.module_strip.deselect_all()

    def update_status(self, engine_key: str, status: SystemStatus):
        if status == SystemStatus.ERROR:
            self.lbl_status.setStyleSheet(f"color: {FG_ERROR}; font-size: 8px; font-weight: bold; background: transparent;")
        elif status == SystemStatus.LOADING:
            self.lbl_status.setStyleSheet(f"color: {FG_WARN}; font-size: 8px; font-weight: bold; background: transparent;")
        else:
            self.lbl_status.setStyleSheet(f"color: #555; font-size: 8px; font-weight: bold; background: transparent;")
        status_text = status.value if hasattr(status, "value") else str(status)
        if not engine_key.startswith("llm"):
            status_text = f"{engine_key.upper()}: {status_text}"
        self.lbl_status.setText(status_text)

    def update_ctx(self, used):
        self.state.ctx_used = used

    def update_terminal_header(self, mod_id, title, timestamp):
        if mod_id:
            self._terminal_titles[mod_id] = (title or "Untitled Chat", timestamp or QDateTime.currentDateTime().toString("ddd • HH:mm"))

        current = self.stack.currentWidget()
        current_mod = getattr(current, "_mod_id", None) if current is not None else None
        if not current_mod:
            self.lbl_chat_title.clear()
            self.lbl_chat_time.clear()
            self.lbl_chat_title.hide()
            self.lbl_chat_time.hide()
            return

        current_title, current_time = self._terminal_titles.get(
            current_mod,
            ("Untitled Chat", QDateTime.currentDateTime().toString("ddd • HH:mm")),
        )
        if current_mod == mod_id or mod_id == "":
            self.lbl_chat_title.setText(current_title)
            self.lbl_chat_time.setText(current_time)
            self.lbl_chat_title.show()
            self.lbl_chat_time.show()

    def set_page(self, page_id):
        target = self.pages.get(page_id)
        if target:
            self.stack.setCurrentWidget(target)
        self._update_sidebar_state(page_idx=page_id)
        self.lbl_monolith.setVisible(page_id != "hub")
        self.update_terminal_header("", "", "")

    def _update_time_display(self):
        current = self.stack.currentWidget()
        current_mod = getattr(current, "_mod_id", None) if current is not None else None
        if current_mod and getattr(current, "_addon_id", None) == "terminal":
            now = QDateTime.currentDateTime().toString("ddd • HH:mm")
            self.lbl_chat_time.setText(now)
            if current_mod in self._terminal_titles:
                title = self._terminal_titles[current_mod][0]
                self._terminal_titles[current_mod] = (title, now)

    def _build_top_bar(self):
        bar = QFrame()
        bar.setFixedHeight(35)
        bar.setStyleSheet("background: #111; border-bottom: 1px solid #222;")
        layout = QHBoxLayout(bar)
        layout.setContentsMargins(10, 0, 10, 0)

        self.lbl_monolith = QLabel("MONOLITH")
        self.lbl_monolith.setStyleSheet(
            "color: #8a7340; font-size: 14px; font-weight: bold; "
            "letter-spacing: 3px; background: transparent;"
        )
        layout.addWidget(self.lbl_monolith)
        layout.addStretch()

        self.lbl_chat_title = QLabel(self._chat_title)
        self.lbl_chat_title.setStyleSheet("color: #dcdcdc; font-size: 10px; font-weight: bold;")
        self.lbl_chat_time = QLabel(QDateTime.currentDateTime().toString("ddd • HH:mm"))
        self.lbl_chat_time.setStyleSheet("color: #777; font-size: 10px;")
        title_box = QVBoxLayout()
        title_box.setContentsMargins(0, 0, 8, 0)
        title_box.setSpacing(0)
        title_box.addWidget(self.lbl_chat_title, alignment=Qt.AlignRight)
        title_box.addWidget(self.lbl_chat_time, alignment=Qt.AlignRight)
        layout.addLayout(title_box)

        self.win_controls = SplitControlBlock()
        self.win_controls.minClicked.connect(self.showMinimized)
        self.win_controls.maxClicked.connect(self.toggle_maximize)
        self.win_controls.closeClicked.connect(self.close)
        layout.addWidget(self.win_controls)

        return bar

    def toggle_maximize(self):
        self.showNormal() if self.isMaximized() else self.showMaximized()

    def apply_theme_refresh(self):
        """Re-apply all stylesheets after theme change. Rebuilds the entire UI appearance."""
        from core.style import (
            BG_MAIN, BG_SIDEBAR, BORDER_LIGHT, BORDER_SUBTLE, FG_TEXT, FG_DIM,
            FG_PLACEHOLDER, ACCENT_PRIMARY_DARK, FG_ERROR, FG_WARN
        )
        # Main frame
        main_widget = self.centralWidget()
        if main_widget:
            main_widget.setStyleSheet(f"""
                QWidget {{ background: {BG_MAIN}; }}
                QWidget#MainFrame {{ border: 1px solid {BORDER_LIGHT}; }}
            """)
        # Sidebar
        self.sidebar.setStyleSheet(f"background: {BG_SIDEBAR}; border-right: 1px solid {BORDER_SUBTLE};")
        # Top bar
        self.top_bar.setStyleSheet(f"background: {BG_SIDEBAR}; border-bottom: 1px solid {BORDER_SUBTLE};")
        self.lbl_monolith.setStyleSheet(
            f"color: {ACCENT_PRIMARY_DARK}; font-size: 14px; font-weight: bold; "
            f"letter-spacing: 3px; background: transparent;"
        )
        self.lbl_chat_title.setStyleSheet(f"color: {FG_TEXT}; font-size: 10px; font-weight: bold;")
        self.lbl_chat_time.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        # Status bar
        self.lbl_status.setStyleSheet(
            f"color: {FG_PLACEHOLDER}; font-size: 8px; font-weight: bold; background: transparent;"
        )
        # Gradient line
        self.gradient_line.update()

    def toggle_vitals(self):
        if not self.vitals_win:
            self.vitals_win = VitalsWindow(self.state, self)
        
        if not self.vitals_win.isVisible():
            self.vitals_win.show()
        else:
            self.vitals_win.close()



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\overseer.py
================================================================================

from __future__ import annotations

from datetime import datetime

from PySide6.QtCore import QTimer, Qt
from PySide6.QtGui import QCloseEvent, QFont, QColor
from PySide6.QtWidgets import (
    QCheckBox,
    QHBoxLayout,
    QMainWindow,
    QPlainTextEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
    QFrame,
    QLabel,
    QHeaderView,
    QSplitter,
)

from core.overseer_db import OverseerDB
from core.style import (
    ACCENT_GOLD, FG_DIM, FG_TEXT, FG_ERROR, FG_WARN, FG_ACCENT,
    OVERSEER_BG, OVERSEER_FG, OVERSEER_DIM, OVERSEER_BORDER, BG_INPUT,
)
from monokernel.guard import MonoGuard
from ui.bridge import UIBridge

# Severity colors
_SEV_COLORS = {
    "ERROR": FG_ERROR,
    "WARNING": FG_WARN,
    "INFO": OVERSEER_FG,
    "DEBUG": FG_DIM,
    "STATUS": ACCENT_GOLD,
    "FINISHED": FG_ACCENT,
}

_FILTER_STYLE_ON = """
    QPushButton {{
        background: {bg};
        border: 1px solid {color};
        color: {color};
        padding: 4px 8px; font-size: 9px; font-weight: bold;
        border-radius: 2px;
    }}
    QPushButton:hover {{ background: #1a1a1a; }}
"""

_FILTER_STYLE_OFF = f"""
    QPushButton {{
        background: transparent;
        border: 1px solid #222;
        color: #333;
        padding: 4px 8px; font-size: 9px; font-weight: bold;
        border-radius: 2px;
    }}
    QPushButton:hover {{ color: {FG_DIM}; border: 1px solid #333; }}
"""

_RECIPE_PRESETS = {
    "ALL": {"ERROR", "WARNING", "INFO", "DEBUG", "STATUS", "FINISHED"},
    "ERRORS ONLY": {"ERROR"},
    "KERNEL": {"ERROR", "WARNING", "STATUS", "FINISHED"},
    "PERFORMANCE": {"INFO", "FINISHED"},
}


class _SeverityFilter(QPushButton):
    """Toggle button for a log severity level."""

    def __init__(self, label: str, color: str):
        super().__init__(label)
        self._label = label
        self._color = color
        self._active = True
        self.setCheckable(True)
        self.setChecked(True)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedHeight(24)
        self.clicked.connect(self._toggle)
        self._apply_style()

    def _toggle(self):
        self._active = self.isChecked()
        self._apply_style()

    def _apply_style(self):
        if self._active:
            self.setStyleSheet(
                _FILTER_STYLE_ON.format(bg=OVERSEER_BG, color=self._color)
            )
        else:
            self.setStyleSheet(_FILTER_STYLE_OFF)

    def is_active(self) -> bool:
        return self._active

    def set_active(self, val: bool):
        self._active = val
        self.setChecked(val)
        self._apply_style()


class ActiveTasksPanel(QWidget):
    def __init__(self) -> None:
        super().__init__()
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        lbl = QLabel("ACTIVE TASKS")
        lbl.setStyleSheet(
            f"color: {OVERSEER_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        layout.addWidget(lbl)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(["TASK", "ENGINE", "STATUS"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.setSelectionMode(QTableWidget.NoSelection)
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setStyleSheet(f"""
            QTableWidget {{
                background: {OVERSEER_BG};
                color: {OVERSEER_FG};
                border: 1px solid {OVERSEER_BORDER};
                gridline-color: {OVERSEER_BORDER};
                font-family: 'Consolas', monospace;
                font-size: 10px;
            }}
            QTableWidget::item {{
                padding: 4px;
                border-bottom: 1px solid {OVERSEER_BORDER};
            }}
            QHeaderView::section {{
                background: {OVERSEER_BG};
                color: {OVERSEER_DIM};
                border: none;
                border-bottom: 1px solid {OVERSEER_BORDER};
                font-size: 9px;
                font-weight: bold;
                padding: 4px;
            }}
        """)
        layout.addWidget(self.table)

    def set_tasks(self, rows: list[tuple[str, str, str]]) -> None:
        self.table.setRowCount(len(rows))
        for idx, (task_id, engine_key, status) in enumerate(rows):
            self.table.setItem(idx, 0, QTableWidgetItem(task_id))
            self.table.setItem(idx, 1, QTableWidgetItem(engine_key))
            item = QTableWidgetItem(status)
            color = _SEV_COLORS.get(status.upper(), OVERSEER_FG)
            item.setForeground(QColor(color))
            self.table.setItem(idx, 2, item)


class OverseerWindow(QMainWindow):
    def __init__(self, guard: MonoGuard, ui_bridge: UIBridge):
        super().__init__()
        self.guard = guard
        self.ui_bridge = ui_bridge
        self.db = OverseerDB()
        self._paused = False
        self._last_task_state: dict[str, tuple[str, str]] = {}
        self._severity_filters: dict[str, _SeverityFilter] = {}

        self.setWindowTitle("OVERSEER")
        self.resize(1000, 560)
        self.setStyleSheet(f"background: {OVERSEER_BG};")

        main = QWidget()
        self.setCentralWidget(main)
        main_layout = QVBoxLayout(main)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(8)

        # --- Top bar: title + recipe buttons ---
        top_bar = QHBoxLayout()
        lbl_title = QLabel("⬡ OVERSEER")
        lbl_title.setStyleSheet(
            f"color: {OVERSEER_FG}; font-size: 12px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        top_bar.addWidget(lbl_title)
        top_bar.addStretch()

        # Recipe presets
        for recipe_name in _RECIPE_PRESETS:
            btn = QPushButton(recipe_name)
            btn.setCursor(Qt.PointingHandCursor)
            btn.setFixedHeight(22)
            btn.setStyleSheet(f"""
                QPushButton {{
                    background: transparent;
                    border: 1px solid {OVERSEER_BORDER};
                    color: {OVERSEER_DIM};
                    padding: 2px 8px; font-size: 8px; font-weight: bold;
                    border-radius: 2px;
                }}
                QPushButton:hover {{
                    border: 1px solid {OVERSEER_FG};
                    color: {OVERSEER_FG};
                }}
            """)
            btn.clicked.connect(lambda _=False, r=recipe_name: self._apply_recipe(r))
            top_bar.addWidget(btn)

        main_layout.addLayout(top_bar)

        # --- Severity filter row ---
        filter_row = QHBoxLayout()
        filter_row.setSpacing(4)
        for sev, color in _SEV_COLORS.items():
            f = _SeverityFilter(sev, color)
            self._severity_filters[sev] = f
            filter_row.addWidget(f)
        filter_row.addStretch()
        main_layout.addLayout(filter_row)

        # --- Separator ---
        sep = QFrame()
        sep.setFixedHeight(1)
        sep.setStyleSheet(f"background: {OVERSEER_BORDER};")
        main_layout.addWidget(sep)

        # --- Content: tasks panel + log display ---
        content_split = QSplitter(Qt.Horizontal)
        content_split.setStyleSheet(f"""
            QSplitter::handle {{ background: {OVERSEER_BORDER}; width: 1px; }}
        """)
        content_split.setChildrenCollapsible(False)

        self.panel = ActiveTasksPanel()
        content_split.addWidget(self.panel)

        # Log display — command prompt style
        log_wrap = QWidget()
        log_layout = QVBoxLayout(log_wrap)
        log_layout.setContentsMargins(0, 0, 0, 0)
        log_layout.setSpacing(4)

        lbl_log = QLabel("EVENT LOG")
        lbl_log.setStyleSheet(
            f"color: {OVERSEER_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        log_layout.addWidget(lbl_log)

        self.log_display = QPlainTextEdit()
        self.log_display.setReadOnly(True)
        self.log_display.setFont(QFont("Consolas", 10))
        self.log_display.setStyleSheet(f"""
            QPlainTextEdit {{
                background: {OVERSEER_BG};
                color: {OVERSEER_FG};
                border: 1px solid {OVERSEER_BORDER};
                selection-background-color: #1a3a1a;
            }}
            QPlainTextEdit::viewport {{
                background: {OVERSEER_BG};
            }}
        """)
        log_layout.addWidget(self.log_display)
        content_split.addWidget(log_wrap)

        content_split.setStretchFactor(0, 1)
        content_split.setStretchFactor(1, 3)
        content_split.setSizes([250, 700])
        main_layout.addWidget(content_split, 1)

        # --- Bottom controls ---
        controls_layout = QHBoxLayout()
        controls_layout.setSpacing(8)

        ctrl_style = f"""
            QCheckBox {{
                color: {OVERSEER_DIM}; font-size: 9px; font-weight: bold;
                spacing: 4px;
            }}
            QCheckBox::indicator {{
                width: 10px; height: 10px;
                border: 1px solid {OVERSEER_DIM};
                background: {OVERSEER_BG};
                border-radius: 2px;
            }}
            QCheckBox::indicator:checked {{
                background: {OVERSEER_FG};
                border: 1px solid {OVERSEER_FG};
            }}
        """

        self.chk_pause = QCheckBox("PAUSE")
        self.chk_pause.setStyleSheet(ctrl_style)
        self.chk_pause.toggled.connect(self._on_pause_toggled)

        self.btn_clear = QPushButton("CLEAR")
        self.btn_clear.setCursor(Qt.PointingHandCursor)
        self.btn_clear.setFixedHeight(22)
        self.btn_clear.setStyleSheet(f"""
            QPushButton {{
                background: transparent;
                border: 1px solid {OVERSEER_BORDER};
                color: {OVERSEER_DIM};
                padding: 2px 10px; font-size: 9px; font-weight: bold;
                border-radius: 2px;
            }}
            QPushButton:hover {{ border: 1px solid {FG_ERROR}; color: {FG_ERROR}; }}
        """)
        self.btn_clear.clicked.connect(self.log_display.clear)

        self.chk_viz = QCheckBox("VIZTRACER")
        self.chk_viz.setStyleSheet(ctrl_style)
        self.chk_viz.toggled.connect(self.ui_bridge.sig_overseer_viz_toggle.emit)

        controls_layout.addWidget(self.chk_pause)
        controls_layout.addWidget(self.btn_clear)
        controls_layout.addWidget(self.chk_viz)
        controls_layout.addStretch()
        main_layout.addLayout(controls_layout)

        # --- Signal connections ---
        self.guard.sig_trace.connect(lambda _engine_key, msg: self._on_trace(msg))
        self.guard.sig_status.connect(self._on_status)
        self.guard.sig_finished.connect(self._on_finished)

        self._poll_timer = QTimer(self)
        self._poll_timer.setInterval(300)
        self._poll_timer.timeout.connect(self._refresh_active_tasks)
        self._poll_timer.start()

    # ---- Filtering ----

    def _is_severity_visible(self, severity: str) -> bool:
        f = self._severity_filters.get(severity.upper())
        return f.is_active() if f else True

    def _apply_recipe(self, recipe_name: str):
        active = _RECIPE_PRESETS.get(recipe_name, set())
        for sev, filt in self._severity_filters.items():
            filt.set_active(sev in active)

    # ---- Log helpers ----

    def _append_line(self, severity: str, text: str) -> None:
        if self._paused:
            return
        if not self._is_severity_visible(severity):
            return
        color = _SEV_COLORS.get(severity.upper(), OVERSEER_FG)
        self.log_display.appendHtml(
            f'<span style="color:{OVERSEER_DIM}">[{self._now_label()}]</span> '
            f'<span style="color:{color}">[{severity}]</span> '
            f'<span style="color:{OVERSEER_FG}">{text}</span>'
        )

    def _now_label(self) -> str:
        return datetime.now().strftime("%H:%M:%S")

    def _on_pause_toggled(self, checked: bool) -> None:
        self._paused = checked

    # ---- Signal handlers ----

    def _on_trace(self, msg: str) -> None:
        try:
            self.db.log_event("guard", "trace", {"message": msg})
        except RuntimeError:
            return
        self.db.log_event("guard", "trace", {"message": msg})
        sev = "INFO"
        lowered = msg.lower()
        if "error" in lowered:
            sev = "ERROR"
        elif "warn" in lowered:
            sev = "WARNING"
        self._append_line(sev, msg)

    def _on_status(self, engine_key: str, status) -> None:
        status_val = status.value if hasattr(status, "value") else str(status)
        self.db.log_event(engine_key, "status", {"status": status_val})
        self._append_line("STATUS", f"{engine_key} → {status_val}")

    def _on_finished(self, engine_key: str, task_id: str) -> None:
        self.db.log_task(str(task_id), engine_key, "DONE")
        self.db.log_event(engine_key, "finished", {"task_id": str(task_id)})
        self._append_line("FINISHED", f"{engine_key} task={task_id}")

    def _refresh_active_tasks(self) -> None:
        rows = []
        for engine_key, task in self.guard.active_tasks.items():
            if task is None:
                if engine_key in self._last_task_state:
                    prev = self._last_task_state.pop(engine_key)
                    self.db.log_task(prev[0], engine_key, "CLEARED")
                continue
            status_val = task.status.value if hasattr(task.status, "value") else str(task.status)
            current = (str(task.id), status_val)
            if self._last_task_state.get(engine_key) != current:
                self._last_task_state[engine_key] = current
                self.db.log_task(str(task.id), engine_key, status_val)
            rows.append((str(task.id), engine_key, status_val))
        self.panel.set_tasks(rows)

    def closeEvent(self, event: QCloseEvent) -> None:
        self._poll_timer.stop()
        if getattr(self.guard, "_viztracer", None) is not None:
            self.guard.enable_viztracer(False)
        self.db.close()
        super().closeEvent(event)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\addons\builtin.py
================================================================================

import uuid

from ui.addons.context import AddonContext
from ui.addons.registry import AddonRegistry
from ui.addons.spec import AddonSpec
from ui.modules.injector import InjectorWidget
from ui.modules.sd import SDModule
from ui.modules.audiogen import AudioGenModule
from ui.modules.manager import PageAddons
from ui.pages.chat import PageChat
from ui.pages.databank import PageFiles
from ui.pages.hub import PageHub
from core.operators import OperatorManager
from engine.bridge import EngineBridge
from engine.llm import LLMEngine


def terminal_factory(ctx: AddonContext):
    instance_id = str(uuid.uuid4())
    engine_key = f"llm_{instance_id}"

    short_id = instance_id[:8]

    def _trace(msg):
        ctx.guard.sig_trace.emit("system", msg)

    llm_engine = LLMEngine(ctx.state)
    engine_bridge = EngineBridge(llm_engine)
    ctx.guard.register_engine(engine_key, engine_bridge)

    w = PageChat(ctx.state, ctx.ui_bridge)
    w._mod_id = instance_id
    w._engine_key = engine_key
    ctx.ui_bridge.sig_apply_operator.connect(w.apply_operator)
    llm_engine.sig_model_capabilities.connect(w._on_model_capabilities)

    w.sig_set_model_path.connect(
        lambda path: ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "set_path", engine_key, payload={"path": path})
        )
    )
    w.sig_set_ctx_limit.connect(
        lambda limit: None if limit is None else ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "set_ctx_limit", engine_key, payload={"ctx_limit": int(limit)})
        )
    )

    if w.config.get("gguf_path"):
        w.sig_set_model_path.emit(str(w.config.get("gguf_path")))
    w.sig_set_ctx_limit.emit(int(w.config.get("ctx_limit", 8192)))

    # outgoing (addon -> bridge)
    def _on_generate(prompt, thinking_mode):
        try:
            model = w.config.get("gguf_path", "unknown")
            model_name = str(model).rsplit("/", 1)[-1].rsplit("\\", 1)[-1] if model else "none"
            think_label = "think=ON" if thinking_mode else "think=OFF"
            _trace(f"[LLM:{short_id}] generating — {think_label}, model={model_name}, prompt={repr(prompt[:50])}")
            task = ctx.bridge.wrap(
                "terminal",
                "generate",
                engine_key,
                payload={
                    "prompt": prompt,
                    "config": w.config,
                    "thinking_mode": thinking_mode,
                    "ctx_limit": int(w.config.get("ctx_limit", 8192)),
                },
            )
            ctx.bridge.submit(task)
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in generate: {e}")
            import traceback
            traceback.print_exc()

    w.sig_generate.connect(_on_generate)
    w.sig_load.connect(
        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "load", engine_key))
    )
    w.sig_unload.connect(
        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "unload", engine_key))
    )
    def _on_stop():
        try:
            _trace(f"[LLM:{short_id}] stopped — generation halted")
            ctx.bridge.stop(engine_key)
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in stop: {e}")
            import traceback
            traceback.print_exc()

    w.sig_stop.connect(_on_stop)

    def _on_sync_history(history):
        try:
            _trace(f"[LLM:{short_id}] syncing history — {len(history)} messages")
            ctx.bridge.submit(
                ctx.bridge.wrap(
                    "terminal",
                    "set_history",
                    engine_key,
                    payload={"history": history},
                )
            )
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in sync_history: {e}")
            import traceback
            traceback.print_exc()

    w.sig_sync_history.connect(_on_sync_history)
    ctx.guard.sig_status.connect(w.update_status)
    w.sig_debug.connect(lambda msg: ctx.guard.sig_trace.emit(engine_key, msg))
    # incoming (guard -> addon)
    ctx.guard.sig_token.connect(
        lambda ek, t: w.append_token(t) if ek == engine_key else None
    )
    ctx.guard.sig_trace.connect(
        lambda ek, m: w.append_trace(m) if ek == engine_key else None
    )
    ctx.guard.sig_finished.connect(w.on_guard_finished)

    def _cleanup_terminal(*_args):
        ctx.guard.unregister_engine(engine_key)
        engine_bridge.shutdown()

    w.destroyed.connect(_cleanup_terminal)
    return w


def addons_page_factory(ctx: AddonContext):
    w = PageAddons(ctx.state)
    # route launcher directly to host (host must exist)
    assert ctx.host is not None, "AddonHost must exist before addons page wiring"
    w.sig_launch_addon.connect(lambda addon_id: ctx.host.launch_module(addon_id))
    w.sig_open_vitals.connect(lambda: ctx.ui.toggle_vitals() if ctx.ui else None)
    w.sig_open_overseer.connect(ctx.ui_bridge.sig_open_overseer.emit)
    return w



def hub_factory(ctx: AddonContext):
    manager = OperatorManager()

    def _snapshot_workspace():
        """Capture full workspace state: all open modules + terminal config/messages."""
        if not ctx.ui:
            return {}

        modules = []
        module_order = []
        for mod_id in ctx.ui.module_strip.get_order():
            # Find widget by mod_id
            widget = None
            for i in range(ctx.ui.stack.count()):
                w = ctx.ui.stack.widget(i)
                if getattr(w, '_mod_id', None) == mod_id:
                    widget = w
                    break
            if not widget:
                continue

            addon_id = getattr(widget, '_addon_id', None)
            if not addon_id:
                continue

            module_order.append(addon_id)
            entry = {"addon_id": addon_id}

            # For terminals, capture config + chat messages
            if isinstance(widget, PageChat):
                entry["config"] = dict(widget.config)
                session = getattr(widget, '_current_session', None)
                if session:
                    entry["messages"] = list(session.get("messages", []))
                    entry["session_title"] = session.get("title")
                    entry["assistant_tokens"] = session.get("assistant_tokens", 0)

            modules.append(entry)

        ctx.guard.sig_trace.emit("system", f"[OPERATOR] snapshot: {len(modules)} modules")
        return {"modules": modules, "module_order": module_order}

    w = PageHub(config_provider=_snapshot_workspace, operator_manager=manager, ui_bridge=ctx.ui_bridge)

    def _load_operator(name: str):
        ctx.guard.sig_trace.emit("system", f"[OPERATOR] loading '{name}'")
        try:
            operator_data = manager.load_operator(name)
        except Exception as e:
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] failed to load: {e}")
            return

        if not ctx.ui or not ctx.host:
            return

        # --- New format: has "modules" list ---
        if "modules" in operator_data:
            modules = operator_data["modules"]
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] restoring {len(modules)} modules")

            # Close all existing modules
            for mod_id in list(ctx.ui.module_strip.get_order()):
                ctx.ui.close_module(mod_id)

            # Launch each module from snapshot
            first_terminal_mod_id = None
            for entry in modules:
                addon_id = entry.get("addon_id")
                if not addon_id:
                    continue
                new_mod_id = ctx.host.launch_module(addon_id)
                if not new_mod_id:
                    ctx.guard.sig_trace.emit("system", f"[OPERATOR] failed to launch {addon_id}")
                    continue

                # For terminals with saved state, apply config + messages
                if addon_id == "terminal" and "config" in entry:
                    for i in range(ctx.ui.stack.count()):
                        widget = ctx.ui.stack.widget(i)
                        if getattr(widget, '_mod_id', None) == new_mod_id and isinstance(widget, PageChat):
                            widget.apply_operator(entry)
                            break
                    if not first_terminal_mod_id:
                        first_terminal_mod_id = new_mod_id

            # Switch to first terminal
            if first_terminal_mod_id:
                ctx.ui.switch_to_module(first_terminal_mod_id)

        # --- Legacy format: top-level "config" only ---
        else:
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] legacy format for '{name}'")
            target_widget = None
            for i in range(ctx.ui.stack.count()):
                widget = ctx.ui.stack.widget(i)
                if isinstance(widget, PageChat):
                    target_widget = widget
                    break

            if not target_widget:
                ctx.host.launch_module("terminal")
                for i in range(ctx.ui.stack.count()):
                    widget = ctx.ui.stack.widget(i)
                    if isinstance(widget, PageChat):
                        target_widget = widget
                        break

            ctx.ui_bridge.sig_apply_operator.emit(operator_data)

            if target_widget:
                mod_id = getattr(target_widget, "_mod_id", None)
                if mod_id:
                    ctx.ui.switch_to_module(mod_id)

    w.sig_load_operator.connect(_load_operator)
    w.sig_save_operator.connect(lambda name, data: manager.save_operator(name, data))
    return w

def databank_factory(ctx: AddonContext):
    return PageFiles(ctx.state)


def injector_factory(ctx: AddonContext):
    assert ctx.ui is not None, "InjectorWidget requires UI parent"
    return InjectorWidget(ctx.ui)


def sd_factory(ctx: AddonContext):
    return SDModule(ctx.bridge, ctx.guard)


def audiogen_factory(ctx: AddonContext):
    return AudioGenModule()


def build_builtin_registry() -> AddonRegistry:
    registry = AddonRegistry()

    registry.register(
        AddonSpec(
            id="terminal",
            kind="module",
            title="TERMINAL",
            icon="⌖",
            factory=terminal_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="databank",
            kind="module",
            title="DATABANK",
            icon="▤",
            factory=databank_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="hub",
            kind="page",
            title="HUB",
            icon=None,
            factory=hub_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="addons",
            kind="page",
            title="ADDONS",
            icon=None,
            factory=addons_page_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="injector",
            kind="module",
            title="RUNTIME",
            icon="💉",
            factory=injector_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="sd",
            kind="module",
            title="VISION",
            icon="⟡",
            factory=sd_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="audiogen",
            kind="module",
            title="AUDIO",
            icon="♫",
            factory=audiogen_factory,
        )
    )

    return registry



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\addons\context.py
================================================================================

from dataclasses import dataclass
from typing import Optional, TYPE_CHECKING

from core.state import AppState
from monokernel.bridge import MonoBridge
from monokernel.guard import MonoGuard
from ui.bridge import UIBridge

if TYPE_CHECKING:
    from ui.addons.host import AddonHost
    from ui.main_window import MonolithUI


@dataclass
class AddonContext:
    state: AppState
    guard: MonoGuard
    bridge: MonoBridge
    ui: Optional["MonolithUI"]
    host: Optional["AddonHost"]
    ui_bridge: UIBridge



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\addons\host.py
================================================================================

import uuid
from typing import Dict, Optional

from PySide6.QtWidgets import QWidget

from ui.addons.context import AddonContext
from ui.addons.registry import AddonRegistry


class AddonHost:
    def __init__(self, registry: AddonRegistry, ctx: AddonContext):
        self.registry = registry
        self.ctx = ctx
        self.ctx.host = self
        self._pages: Dict[str, QWidget] = {}

    def mount_page(self, addon_id: str) -> QWidget:
        if addon_id in self._pages:
            return self._pages[addon_id]

        spec = self.registry.get(addon_id)
        if spec.kind != "page":
            raise ValueError(f"Addon '{addon_id}' is not a page")
        widget = spec.factory(self.ctx)
        self._pages[addon_id] = widget
        return widget

    def get_page_widget(self, addon_id: str) -> Optional[QWidget]:
        return self._pages.get(addon_id)

    def launch_module(self, addon_id: str) -> str:
        if not self.ctx.ui:
            raise RuntimeError("AddonHost requires UI for launching modules")

        try:
            spec = self.registry.get(addon_id)
            if spec.kind != "module":
                raise ValueError(f"Addon '{addon_id}' is not a module")
            instance_id = str(uuid.uuid4())
            widget = spec.factory(self.ctx)
        except Exception as e:
            self.ctx.guard.sig_trace.emit("system", f"<span style='color:red'>ADDON ERROR: {e}</span>")
            return ""

        widget._addon_id = addon_id
        if not hasattr(widget, "_mod_id"):
            widget._mod_id = instance_id
        else:
            instance_id = widget._mod_id
        added_stack = False
        added_strip = False
        try:
            self.ctx.ui.stack.addWidget(widget)
            added_stack = True
            self.ctx.ui.module_strip.add_module(instance_id, spec.icon or "?", spec.title)
            added_strip = True
        except Exception:
            if added_strip:
                self.ctx.ui.module_strip.remove_module(instance_id)
            if added_stack:
                self.ctx.ui.stack.removeWidget(widget)
            widget.deleteLater()
            return ""

        if hasattr(widget, "sig_closed"):
            widget.sig_closed.connect(lambda: self.ctx.ui.close_module(instance_id))
        if hasattr(widget, "sig_finished"):
            widget.sig_finished.connect(lambda: self.ctx.ui.module_strip.flash_module(instance_id))

        self.ctx.ui.switch_to_module(instance_id)
        return instance_id



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\addons\registry.py
================================================================================

from typing import Dict, Iterable

from ui.addons.spec import AddonSpec


class AddonRegistry:
    def __init__(self):
        self._specs: Dict[str, AddonSpec] = {}

    def register(self, spec: AddonSpec) -> None:
        self._specs[spec.id] = spec

    def get(self, addon_id: str) -> AddonSpec:
        if addon_id not in self._specs:
            raise KeyError(f"Addon '{addon_id}' not found. Known addons: {list(self._specs.keys())}")
        return self._specs[addon_id]

    def all(self) -> Iterable[AddonSpec]:
        return self._specs.values()



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\addons\spec.py
================================================================================

from dataclasses import dataclass
from typing import Callable, Literal

from PySide6.QtWidgets import QWidget

from ui.addons.context import AddonContext

AddonKind = Literal["page", "module"]


@dataclass(frozen=True)
class AddonSpec:
    id: str
    kind: AddonKind
    title: str
    icon: str | None
    factory: Callable[[AddonContext], QWidget]



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\addons\__init__.py
================================================================================




================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\addons\configs\llm_config.json
================================================================================

{
  "gguf_path": null,
  "temp": 0.7,
  "top_p": 0.9,
  "max_tokens": 2048,
  "ctx_limit": 8192,
  "system_prompt": "You are Monolith. Be precise.",
  "context_injection": ""
}



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\components\atoms.py
================================================================================

from PySide6.QtWidgets import (
    QWidget, QFrame, QLabel, QSlider, QHBoxLayout, 
    QPushButton, QScrollArea, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QPropertyAnimation, QEasingCurve
from PySide6.QtGui import QDragEnterEvent

from core.style import BG_GROUP, BORDER_DARK, FG_TEXT, FG_DIM, FG_ACCENT, ACCENT_GOLD

# ======================
# HELPER
# ======================
def import_vbox(widget, l=15, t=25, r=15, b=15):
    from PySide6.QtWidgets import QVBoxLayout
    v = QVBoxLayout(widget)
    v.setContentsMargins(l, t, r, b)
    v.setSpacing(10)
    return v

# ======================
# BASIC UI PRIMITIVES
# ======================

class SkeetGroupBox(QFrame):
    def __init__(self, title, parent=None):
        super().__init__(parent)
        self.setStyleSheet(f"""
            SkeetGroupBox {{
                background: {BG_GROUP};
                border: 1px solid {BORDER_DARK};
                margin-top: 10px; 
            }}
        """)
        self.layout_main = import_vbox(self)
        self.lbl_title = QLabel(title, self)
        self.lbl_title.setStyleSheet(f"""
            color: {FG_TEXT}; 
            font-weight: bold; font-size: 11px;
            background: {BG_GROUP}; padding: 0 4px;
        """)
        self.lbl_title.adjustSize()
        self.lbl_title.move(10, -3)

    def add_widget(self, widget):
        self.layout_main.addWidget(widget)

    def add_layout(self, layout):
        self.layout_main.addLayout(layout)

class SkeetButton(QPushButton):
    def __init__(self, text, accent=False):
        super().__init__(text)
        self.setCursor(Qt.PointingHandCursor)
        col = FG_ACCENT if accent else FG_TEXT
        self.setStyleSheet(f"""
            QPushButton {{ background: #181818; border: 1px solid #333; color: {FG_DIM}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
            QPushButton:hover {{ background: #222; color: {col}; border: 1px solid {col}; }}
            QPushButton:checked {{ background: #222; color: {col}; border: 1px solid {col}; }}
            QPushButton:pressed {{ background: #111; color: {col}; border: 1px solid {col}; }}
            QPushButton:disabled {{ background: #111; color: #333; border: 1px solid #222; }}
        """)

class SkeetTriangleButton(QPushButton):
    def __init__(self, text):
        super().__init__(text)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(18, 18)
        self.setFocusPolicy(Qt.NoFocus)
        self.setStyleSheet(f"""
            QPushButton {{
                background: #181818; border: 1px solid #333; color: {FG_TEXT};
                padding: 0; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:hover {{ background: #222; color: {ACCENT_GOLD}; border: 1px solid {ACCENT_GOLD}; }}
            QPushButton:disabled {{ background: #111; color: #333; border: 1px solid #222; }}
        """)

class SkeetSlider(QWidget):
    valueChanged = Signal(float)
    def __init__(self, label, min_v, max_v, init_v, is_int=False):
        super().__init__()
        self.is_int = is_int
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        self.lbl = QLabel(label)
        self.lbl.setStyleSheet(f"color: {FG_DIM}; font-size: 11px;")
        val_str = str(int(init_v) if is_int else f"{init_v:.2f}")
        self.val_lbl = QLabel(val_str)
        self.val_lbl.setStyleSheet(f"color: {FG_TEXT}; font-size: 11px; font-weight: bold;")
        self.val_lbl.setFixedWidth(40)
        self.val_lbl.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.slider = QSlider(Qt.Horizontal)
        if is_int:
            self.slider.setRange(int(min_v), int(max_v))
            self.slider.setValue(int(init_v))
        else:
            self.slider.setRange(int(min_v*100), int(max_v*100))
            self.slider.setValue(int(init_v*100))
        self.slider.setStyleSheet(f"""
            QSlider::groove:horizontal {{ height: 4px; background: #222; border-radius: 2px; }}
            QSlider::handle:horizontal {{ background: {ACCENT_GOLD}; width: 8px; margin: -2px 0; border-radius: 4px; }}
            QSlider::handle:horizontal:hover {{ background: {ACCENT_GOLD}; }}
            QSlider::sub-page:horizontal {{ background: #ffffff; border-radius: 2px; }}
        """)
        self.slider.valueChanged.connect(self._on_change)
        layout.addWidget(self.lbl)
        layout.addWidget(self.slider)
        layout.addWidget(self.val_lbl)
    def _on_change(self, val):
        real_val = val if self.is_int else val / 100.0
        val_str = str(int(real_val) if self.is_int else f"{real_val:.2f}")
        self.val_lbl.setText(val_str)
        self.valueChanged.emit(float(real_val))

class SidebarButton(QPushButton):
    def __init__(self, icon_char, text, checkable=True):
        super().__init__()
        self.setCheckable(checkable)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(60, 45) # Shorter height
        if checkable: self.setAutoExclusive(False)
        self.setAcceptDrops(True) 
        
        # Text Only Layout (Skeet Style)
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        
        self.lbl_text = QLabel(text)
        self.lbl_text.setAlignment(Qt.AlignCenter)
        self.lbl_text.setStyleSheet(f"color: {FG_DIM}; font-size: 9px; font-weight: bold;")
        
        layout.addWidget(self.lbl_text)
        self.update_style(False)

    def nextCheckState(self): pass 

    def setChecked(self, checked):
        super().setChecked(checked)
        self.update_style(checked)

    def update_style(self, checked):
        color = ACCENT_GOLD if checked else FG_DIM
        bg = "#1a1a1a" if checked else "transparent"
        # Pure text style, no icon char
        self.lbl_text.setStyleSheet(f"color: {color}; background: transparent; font-size: 10px; font-weight: bold;")
        # Add a left border indicator for active state
        border = f"border-left: 2px solid {ACCENT_GOLD};" if checked else "border: none;"
        self.setStyleSheet(f"background: {bg}; {border}")

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasUrls(): event.accept()
        else: event.ignore()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls(): event.accept()

class CollapsibleSection(QWidget):
    def __init__(self, title="", parent=None):
        super().__init__(parent)
        self.layout_main = import_vbox(self, 0, 0, 0, 0)
        self.layout_main.setSpacing(0)
        self.btn_toggle = QPushButton(title)
        self.btn_toggle.setCheckable(True)
        self.btn_toggle.setChecked(False)
        self.btn_toggle.setStyleSheet(f"""
            QPushButton {{
                color: {FG_DIM}; background: transparent; 
                border: none; text-align: left; font-weight: bold; font-size: 10px;
            }}
            QPushButton:checked {{ color: {ACCENT_GOLD}; }}
            QPushButton:hover {{ color: {FG_TEXT}; }}
        """)
        self.btn_toggle.clicked.connect(self.toggle_animation)
        self.layout_main.addWidget(self.btn_toggle)
        self.content_area = QScrollArea()
        self.content_area.setMaximumHeight(0) 
        self.content_area.setMinimumHeight(0)
        self.content_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.content_area.setFrameShape(QFrame.NoFrame)
        self.content_area.setWidgetResizable(True)
        self.content_area.setStyleSheet("background: transparent;")
        self.layout_main.addWidget(self.content_area)
        self.anim = QPropertyAnimation(self.content_area, b"maximumHeight")
        self.anim.setDuration(300)
        self.anim.setEasingCurve(QEasingCurve.InOutQuad)

    def set_content_layout(self, layout):
        w = QWidget()
        w.setLayout(layout)
        self.content_area.setWidget(w)

    def toggle_animation(self):
        checked = self.btn_toggle.isChecked()
        content_height = self.content_area.widget().layout().sizeHint().height() if self.content_area.widget() else 100
        self.anim.setStartValue(0 if checked else content_height)
        self.anim.setEndValue(content_height if checked else 0)
        self.anim.start()



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\components\complex.py
================================================================================

import math
import re
from PySide6.QtWidgets import (
    QWidget, QFrame, QLabel, QDialog, QHBoxLayout, QVBoxLayout,
    QPushButton, QProgressBar, QGridLayout, QLineEdit
)
from PySide6.QtCore import Qt, QTimer, Signal, QRectF
from PySide6.QtGui import (
    QPainter, QPen, QColor, QLinearGradient, QFont, QPainterPath, QFontMetrics
)


# ======================
# FLAME LABEL (FIXED)
# ======================
class FlameLabel(QWidget):
    def __init__(self, text, parent=None):
        super().__init__(parent)
        self._text = text
        self.phase = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._animate)
        self.timer.start(50)
        # Use a thick, bold font for the mask to work well
        self.font_obj = QFont("Segoe UI", 14, QFont.Bold)
        self.setFixedHeight(30)
        self.setFixedWidth(120) 

    def _animate(self):
        # Move the gradient phase
        self.phase -= 0.08
        if self.phase < -1.0: self.phase = 1.0
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 1. Setup Gradient (Fire Effect)
        # The gradient moves vertically based on self.phase
        h = self.height()
        grad = QLinearGradient(0, h + (h * self.phase), 0, -h + (h * self.phase))
        grad.setSpread(QLinearGradient.RepeatSpread)
        
        # Fire Colors: Dark Grey -> Gold -> White -> Dark Grey
        import core.style as _s
        grad.setColorAt(0.0, QColor("#333"))
        grad.setColorAt(0.4, QColor(_s.GRADIENT_COLOR))
        grad.setColorAt(0.5, QColor("white"))
        grad.setColorAt(0.6, QColor(_s.GRADIENT_COLOR))
        grad.setColorAt(1.0, QColor("#333"))

        # 2. Create Text Path
        # We convert text to a shape so we can fill it with the gradient
        path = QPainterPath()
        # Center the text vertically
        fm = QFontMetrics(self.font_obj)
        text_w = fm.horizontalAdvance(self._text)
        text_h = fm.ascent()
        x = (self.width() - text_w) / 2
        y = (self.height() + text_h) / 2 - fm.descent()
        
        path.addText(x, y, self.font_obj, self._text)

        # 3. Draw
        painter.setBrush(grad)
        painter.setPen(Qt.NoPen)
        painter.drawPath(path)

# ======================
# VITALS WINDOW (COMPACT)
# ======================
class VitalsWindow(QDialog):
    def __init__(self, state, parent=None):
        super().__init__(parent)
        import core.style as s
        self.state = state
        self.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setAttribute(Qt.WA_TranslucentBackground)

        layout = QVBoxLayout(self)
        layout.setSpacing(0)
        layout.setContentsMargins(0,0,0,0)

        self.frame = QFrame()
        # Glassmorphic + Ultra Compact
        self.frame.setStyleSheet(f"background: rgba(8, 8, 8, 230); border: 1px solid {s.ACCENT_GOLD}; border-radius: 4px;")

        frame_layout = QVBoxLayout(self.frame)
        frame_layout.setSpacing(2)
        frame_layout.setContentsMargins(6, 6, 6, 6)

        # Header
        head = QHBoxLayout()
        lbl = QLabel("SYSTEM VITALS")
        lbl.setStyleSheet(f"color: {s.ACCENT_GOLD}; font-weight: 900; font-size: 9px; border:none; background: transparent;")
        btn_x = QPushButton("×")
        btn_x.setFixedSize(14, 14)
        btn_x.clicked.connect(self.close)
        btn_x.setStyleSheet("color: #666; border: none; font-weight: bold; background: transparent; padding:0; margin:0;")
        head.addWidget(lbl)
        head.addStretch()
        head.addWidget(btn_x)
        frame_layout.addLayout(head)

        # Bars
        self.bars = {}
        for key in ["VRAM", "CTX", "CPU", "GPU"]:
            row = QHBoxLayout()
            row.setSpacing(4)
            l = QLabel(key)
            l.setStyleSheet("color: #888; font-size: 8px; font-weight: bold; border:none; background: transparent;")
            l.setFixedWidth(22)

            bar = QProgressBar()
            bar.setFixedHeight(2) # Ultra thin
            bar.setTextVisible(False)
            bar.setStyleSheet(f"""
                QProgressBar {{ background: #222; border: none; border-radius: 1px; }}
                QProgressBar::chunk {{ background: {s.FG_ACCENT}; border-radius: 1px; }}
            """)
            bar.setValue(0)
            self.bars[key] = bar
            
            row.addWidget(l)
            row.addWidget(bar)
            frame_layout.addLayout(row)
            
        layout.addWidget(self.frame)
        
        # Make the window itself small
        self.setFixedSize(140, 90)

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_stats)
        self.timer.start(1000)
        self.old_pos = None

    def update_stats(self):
        if self.state.ctx_limit > 0:
            ctx_p = int((self.state.ctx_used / self.state.ctx_limit) * 100)
            self.bars["CTX"].setValue(ctx_p)
        import random
        base_load = 10 if not self.state.model_loaded else 40
        self.bars["VRAM"].setValue(base_load + random.randint(0, 5))
        self.bars["CPU"].setValue(random.randint(5, 15))
        self.bars["GPU"].setValue(base_load + random.randint(0, 10))
        
    def mousePressEvent(self, e): self.old_pos = e.globalPosition().toPoint()
    def mouseReleaseEvent(self, e): self.old_pos = None
    def mouseMoveEvent(self, e):
        if self.old_pos:
            delta = e.globalPosition().toPoint() - self.old_pos
            self.move(self.pos() + delta)
            self.old_pos = e.globalPosition().toPoint()

# ======================
# MODE SELECTOR (GOLD)
# ======================
class ModeSelector(QWidget):
    modeChanged = Signal(str) # "OPERATOR" or "OVERSEER"

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedHeight(60)
        
        layout = QHBoxLayout(self)
        layout.setSpacing(20)
        layout.setContentsMargins(20, 5, 20, 5)
        
        self.btn_op = self._make_box("OPERATOR", True)
        self.btn_ov = self._make_box("OVERSEER", False)
        
        layout.addStretch()
        layout.addWidget(self.btn_op)
        layout.addWidget(self.btn_ov)
        layout.addStretch()

    def _make_box(self, title, active):
        btn = QPushButton(title)
        btn.setFixedSize(120, 35)
        btn.setCheckable(True)
        btn.setChecked(active)
        btn.setCursor(Qt.PointingHandCursor)
        self._style_btn(btn, active)
        btn.clicked.connect(lambda: self._select(title))
        return btn

    def _style_btn(self, btn, active):
        import core.style as s
        # GOLD highlight when active
        border = s.ACCENT_GOLD if active else "#333"
        bg = "#1a1a1a" if active else s.BG_INPUT
        color = s.ACCENT_GOLD if active else s.FG_DIM
        weight = "bold" if active else "normal"

        btn.setStyleSheet(f"""
            QPushButton {{
                background: {bg};
                border: 1px solid {border};
                color: {color};
                font-family: 'Segoe UI'; font-size: 10px; font-weight: {weight};
                border-radius: 2px;
            }}
            QPushButton:hover {{ border-color: {s.ACCENT_GOLD}; color: {s.FG_TEXT}; }}
        """)

    def _select(self, mode):
        is_op = (mode == "OPERATOR")
        self.btn_op.setChecked(is_op)
        self.btn_ov.setChecked(not is_op)
        
        self._style_btn(self.btn_op, is_op)
        self._style_btn(self.btn_ov, not is_op)
        
        self.modeChanged.emit(mode)

class GradientLine(QFrame):
    def __init__(self):
        super().__init__()
        self.setFixedHeight(2)
        self.offset = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._step)
        self.timer.start(33) 

    def _step(self):
        self.offset = (self.offset + 0.015) % 1.0
        self.repaint()
    
    def paintEvent(self, event):
        import core.style as _s
        painter = QPainter(self)
        grad = QLinearGradient(0, 0, self.width(), 0)
        c_gold = QColor(_s.GRADIENT_COLOR)
        c_dark = QColor(_s.BG_SIDEBAR)
        grad.setSpread(QLinearGradient.RepeatSpread)
        w = self.width()
        start_x = -self.offset * w
        grad.setStart(start_x, 0)
        grad.setFinalStop(start_x + w, 0)
        grad.setColorAt(0.0, c_dark)
        grad.setColorAt(0.5, c_gold)
        grad.setColorAt(1.0, c_dark)
        painter.fillRect(self.rect(), grad)


class TagLineEdit(QLineEdit):
    backspaceOnEmpty = Signal()

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Backspace and not self.text():
            self.backspaceOnEmpty.emit()
            return
        super().keyPressEvent(event)


class BehaviorTagInput(QFrame):
    tagsChanged = Signal(list)

    def __init__(self, known_tags=None, parent=None):
        super().__init__(parent)
        import core.style as s
        self._known_tags = {tag.lower() for tag in (known_tags or [])}
        self._tags = []

        self.setStyleSheet(
            f"background: {s.BG_INPUT}; border: 1px solid #333; border-radius: 2px;"
        )
        layout = QHBoxLayout(self)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(6)

        self._chip_layout = QHBoxLayout()
        self._chip_layout.setContentsMargins(0, 0, 0, 0)
        self._chip_layout.setSpacing(6)
        layout.addLayout(self._chip_layout)

        self._input = TagLineEdit()
        self._input.setPlaceholderText("Type tags...")
        self._input.setStyleSheet(f"background: transparent; color: {s.FG_TEXT}; border: none;")
        self._input.textEdited.connect(self._on_text_edited)
        self._input.returnPressed.connect(self._commit_current_text)
        self._input.backspaceOnEmpty.connect(self._remove_last_tag)
        layout.addWidget(self._input, stretch=1)

    def set_tags(self, tags):
        self._clear_tags()
        for tag in tags:
            self._add_tag(tag, emit_signal=False)
        self.tagsChanged.emit(self._tags.copy())

    def tags(self):
        return self._tags.copy()

    def _clear_tags(self):
        while self._chip_layout.count():
            item = self._chip_layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()
        self._tags = []

    def _normalize_tag(self, tag):
        return tag.strip().lower()

    def _add_tag(self, tag, emit_signal=True):
        import core.style as s
        normalized = self._normalize_tag(tag)
        if not normalized:
            return
        if normalized in self._tags:
            return
        chip = QPushButton(normalized)
        chip.setCursor(Qt.PointingHandCursor)
        chip.setStyleSheet(
            f"""
            QPushButton {{
                background: #1a1a1a; border: 1px solid #333; color: {s.FG_TEXT};
                padding: 2px 6px; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:hover {{ color: {s.ACCENT_GOLD}; border: 1px solid {s.ACCENT_GOLD}; }}
            """
        )
        chip.clicked.connect(lambda _, t=normalized: self._remove_tag(t))
        self._chip_layout.addWidget(chip)
        self._tags.append(normalized)
        if emit_signal:
            self.tagsChanged.emit(self._tags.copy())

    def _remove_tag(self, tag):
        if tag not in self._tags:
            return
        self._tags = [t for t in self._tags if t != tag]
        for index in range(self._chip_layout.count() - 1, -1, -1):
            widget = self._chip_layout.itemAt(index).widget()
            if widget and widget.text() == tag:
                self._chip_layout.takeAt(index)
                widget.deleteLater()
                break
        self.tagsChanged.emit(self._tags.copy())

    def _remove_last_tag(self):
        if not self._tags:
            return
        self._remove_tag(self._tags[-1])

    def _commit_current_text(self):
        text = self._input.text()
        if text:
            self._add_tag(text)
        self._input.clear()

    def _on_text_edited(self, text):
        if not text:
            return
        if "," not in text and " " not in text:
            return
        parts = [part for part in re.split(r"[,\s]+", text) if part]
        trailing = ""
        if text and text[-1] not in {",", " "}:
            trailing = parts.pop() if parts else text
        for part in parts:
            self._add_tag(part)
        self._input.blockSignals(True)
        self._input.setText(trailing)
        self._input.blockSignals(False)

class SplitControlBlock(QWidget):
    minClicked = Signal()
    maxClicked = Signal()
    closeClicked = Signal()

    def __init__(self):
        super().__init__()
        import core.style as s
        self.setFixedSize(45, 34)
        layout = QGridLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(1)
        base_style = f"""
            QPushButton {{
                background: #1a1a1a; border: none; color: {s.FG_DIM};
                font-family: 'Segoe UI'; font-size: 8px;
            }}
            QPushButton:hover {{ background: {s.ACCENT_GOLD}; color: black; }}
            QPushButton:pressed {{ background: #b08d2b; color: black; }}
        """
        self.btn_min = QPushButton("─")
        self.btn_min.setFixedSize(22, 16)
        self.btn_min.setStyleSheet(base_style)
        self.btn_min.clicked.connect(self.minClicked)

        self.btn_max = QPushButton("□")
        self.btn_max.setFixedSize(22, 16)
        self.btn_max.setStyleSheet(base_style)
        self.btn_max.clicked.connect(self.maxClicked)

        self.btn_close = QPushButton("×")
        self.btn_close.setFixedHeight(16)
        self.btn_close.setStyleSheet(f"""
            QPushButton {{
                background: #1a1a1a; border: none; color: {s.FG_DIM};
                font-family: 'Segoe UI'; font-size: 12px;
            }}
            QPushButton:hover {{ background: {s.FG_ERROR}; color: white; }}
            QPushButton:pressed {{ background: #a00; color: white; }}
        """)
        self.btn_close.clicked.connect(self.closeClicked)
        layout.addWidget(self.btn_min, 0, 0)
        layout.addWidget(self.btn_max, 0, 1)
        layout.addWidget(self.btn_close, 1, 0, 1, 2)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\components\message_widget.py
================================================================================

from PySide6.QtCore import Qt, QSize, Signal
from PySide6.QtWidgets import QHBoxLayout, QLabel, QPushButton, QSizePolicy, QVBoxLayout, QWidget

from core.style import ACCENT_GOLD, FG_DIM, FG_TEXT, BORDER_DARK


class _IconAction(QPushButton):
    """Tiny icon-only action button for message hover bar."""

    def __init__(self, icon_char: str, tooltip: str):
        super().__init__(icon_char)
        self.setToolTip(tooltip)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(22, 22)
        self.setStyleSheet(f"""
            QPushButton {{
                background: transparent;
                color: {FG_DIM};
                border: none;
                font-size: 12px;
                padding: 0;
            }}
            QPushButton:hover {{
                color: {ACCENT_GOLD};
            }}
        """)


class MessageWidget(QWidget):
    sig_delete = Signal(int)
    sig_edit = Signal(int)
    sig_regen = Signal(int)

    def __init__(self, index: int, role: str, text: str, timestamp: str):
        super().__init__()
        self._index = index
        self._role = role
        self._content = text or ""

        self.setAttribute(Qt.WA_Hover, True)
        self.setAttribute(Qt.WA_StyledBackground, True)

        is_assistant = role == "assistant"
        is_system = role == "system"
        border_color = ACCENT_GOLD if is_assistant else "#1a1a1a"
        if is_system:
            border_color = "#222"
        bottom_border = "1px solid #1a1a1a" if is_assistant else "none"

        self.setStyleSheet(f"""
            MessageWidget {{
                background: transparent;
                border-left: 2px solid {border_color};
                border-top: none; border-right: none;
                border-bottom: {bottom_border};
            }}
        """)

        root = QVBoxLayout(self)
        root.setContentsMargins(10, 3, 10, 3 if not is_assistant else 8)
        root.setSpacing(4)

        # --- Header row ---
        head = QHBoxLayout()
        head.setSpacing(6)

        role_color = ACCENT_GOLD if is_assistant else FG_TEXT
        if is_system:
            role_color = FG_DIM
        self.lbl_role = QLabel((role or "").upper())
        self.lbl_role.setStyleSheet(
            f"color: {role_color}; font-size: 9px; font-weight: bold; letter-spacing: 1px;"
        )
        head.addWidget(self.lbl_role)

        pretty_ts = (timestamp or "")
        if "T" in pretty_ts and len(pretty_ts) >= 16:
            pretty_ts = pretty_ts[11:16]
        self.lbl_time = QLabel(pretty_ts)
        self.lbl_time.setStyleSheet(f"color: #444; font-size: 9px;")
        head.addWidget(self.lbl_time)
        head.addStretch()

        # --- Hover action icons ---
        self.actions = QWidget()
        self.actions.setStyleSheet("background: transparent;")
        actions_layout = QHBoxLayout(self.actions)
        actions_layout.setContentsMargins(0, 0, 0, 0)
        actions_layout.setSpacing(2)

        if not is_system:
            if role == "user":
                self.btn_edit = _IconAction("✎", "Edit")
                self.btn_edit.clicked.connect(lambda: self.sig_edit.emit(self._index))
                actions_layout.addWidget(self.btn_edit)

            if is_assistant:
                self.btn_regen = _IconAction("⟲", "Regenerate")
                self.btn_regen.clicked.connect(lambda: self.sig_regen.emit(self._index))
                actions_layout.addWidget(self.btn_regen)

            self.btn_delete = _IconAction("✕", "Delete")
            self.btn_delete.clicked.connect(lambda: self.sig_delete.emit(self._index))
            actions_layout.addWidget(self.btn_delete)

        self.actions.setVisible(False)
        head.addWidget(self.actions)

        root.addLayout(head)

        # --- Content ---
        self.lbl_content = QLabel()
        self.lbl_content.setTextFormat(Qt.PlainText)
        self.lbl_content.setWordWrap(True)
        self.lbl_content.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
        self.lbl_content.setCursor(Qt.IBeamCursor)
        content_color = FG_TEXT if is_assistant else "#bbb"
        if is_system:
            content_color = FG_DIM
        self.lbl_content.setStyleSheet(
            f"color: {content_color}; font-size: 11px; line-height: 1.4; padding: 2px 0;"
        )
        self.lbl_content.setText(self._content)
        root.addWidget(self.lbl_content)

        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Minimum)

    # ------------------------------------------------------------------
    def sizeHint(self):
        """Compute height that accounts for word-wrapped content label."""
        w = self.width() if self.width() > 50 else 600
        margins = self.layout().contentsMargins()
        content_w = w - margins.left() - margins.right() - 2  # 2px border-left
        # heightForWidth respects word-wrap and font metrics
        content_h = self.lbl_content.heightForWidth(max(content_w, 60))
        if content_h <= 0:
            content_h = self.lbl_content.sizeHint().height()
        header_h = 20  # role label row
        spacing = self.layout().spacing()  # 4
        total = margins.top() + header_h + spacing + content_h + margins.bottom()
        return QSize(w, max(total, 30))

    def enterEvent(self, event):
        self.actions.setVisible(True)
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.actions.setVisible(False)
        super().leaveEvent(event)

    def append_token(self, token: str):
        if not token:
            return
        self._content += token
        self.lbl_content.setText(self._content)

    def finalize(self):
        self.lbl_content.setText(self._content)

    def set_index(self, idx: int):
        self._index = idx



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\components\module_strip.py
================================================================================

import math
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QScrollArea, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QTimer, QPoint, QEvent, QMimeData
from PySide6.QtGui import QPainter, QColor, QPen, QPolygonF, QDrag

from core.style import ACCENT_GOLD
from .atoms import SidebarButton

class OverflowArrow(QWidget):
    clicked = Signal()
    def __init__(self):
        super().__init__()
        self.setFixedHeight(15)
        self.setCursor(Qt.PointingHandCursor)
        self.phase = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._anim)
        self.timer.start(50)
        
    def _anim(self):
        self.phase += 0.2
        self.update()
        
    def mousePressEvent(self, e): self.clicked.emit()
        
    def paintEvent(self, e):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)
        y_off = math.sin(self.phase) * 2
        c = QColor(ACCENT_GOLD)
        c.setAlpha(150)
        p.setPen(QPen(c, 1.5))
        p.setBrush(Qt.NoBrush)
        cx = self.width() / 2
        cy = self.height() / 2 + y_off
        path = QPolygonF([QPoint(cx - 4, cy - 2), QPoint(cx, cy + 3), QPoint(cx + 4, cy - 2)])
        p.drawPolyline(path)

class ModuleIcon(SidebarButton):
    sig_close = Signal(str)
    sig_select = Signal(str)

    def __init__(self, mod_id, icon_char, label_text):
        super().__init__(icon_char, label_text, checkable=True)
        self.mod_id = mod_id
        self.code = icon_char
        self.is_pulsing = False
        
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(lambda: self.sig_close.emit(self.mod_id))
        
        self.pulse_phase = 0.0
        self._drag_start_pos = None

    def mousePressEvent(self, e):
        if e.button() == Qt.MiddleButton: self.sig_close.emit(self.mod_id)
        elif e.button() == Qt.LeftButton:
            self._drag_start_pos = e.position().toPoint()
            self.sig_select.emit(self.mod_id)

    def mouseMoveEvent(self, e):
        if not (e.buttons() & Qt.LeftButton) or self._drag_start_pos is None:
            return
        if (e.position().toPoint() - self._drag_start_pos).manhattanLength() < QApplication.startDragDistance():
            return
        drag = QDrag(self)
        mime = QMimeData()
        mime.setData("application/x-monolith-module", self.mod_id.encode())
        drag.setMimeData(mime)
        drag.exec(Qt.MoveAction)

    def set_active(self, val):
        self.setChecked(val)
        if val: self.is_pulsing = False

    def flash(self):
        if not self.isChecked():
            self.is_pulsing = True
            self.pulse_phase = 0.0
            self.update()
            QTimer.singleShot(250, lambda: self.set_pulsing(False))

    def set_pulsing(self, val):
        self.is_pulsing = val
        if val: self.pulse_phase = 0.0
        self.update()

    def paintEvent(self, e):
        super().paintEvent(e)
        if self.is_pulsing and not self.isChecked():
            p = QPainter(self)
            p.setRenderHint(QPainter.Antialiasing)
            glow = QColor(ACCENT_GOLD)
            alpha = int(((math.sin(self.pulse_phase) + 1) / 2) * 50)
            glow.setAlpha(alpha)
            p.fillRect(self.rect(), glow)

class ModuleStrip(QWidget):
    sig_module_selected = Signal(str)
    sig_module_closed = Signal(str)

    def __init__(self):
        super().__init__()
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(0)
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setStyleSheet("background: transparent; border: none;")
        self.content = QWidget()
        self.vbox = QVBoxLayout(self.content)
        self.vbox.setContentsMargins(5, 5, 5, 5)
        self.vbox.setSpacing(5)
        self.vbox.addStretch()
        self.scroll.setWidget(self.content)
        layout.addWidget(self.scroll)
        self.arrow = OverflowArrow()
        self.arrow.clicked.connect(self.scroll_down)
        self.arrow.setVisible(False)
        layout.addWidget(self.arrow)
        self.modules = {}
        self.order = []
        self.content.setAcceptDrops(True)
        self.content.installEventFilter(self)

    def add_module(self, mod_id, icon_char, label_text):
        icon = ModuleIcon(mod_id, icon_char, label_text)
        icon.sig_select.connect(self.sig_module_selected)
        icon.sig_close.connect(self.sig_module_closed)
        self.modules[mod_id] = icon
        self.order.append(mod_id)
        self.vbox.insertWidget(self.vbox.count()-1, icon)
        self._check_overflow()

    def remove_module(self, mod_id):
        if mod_id not in self.modules:
            return
        icon = self.modules.pop(mod_id)
        if mod_id in self.order:
            self.order.remove(mod_id)
        self.vbox.removeWidget(icon)
        icon.deleteLater()
        self._check_overflow()

    def select_module(self, mod_id):
        self.deselect_all()
        if mod_id in self.modules:
            self.modules[mod_id].set_active(True)
    
    def flash_module(self, mod_id):
        if mod_id in self.modules:
            self.modules[mod_id].flash()

    def deselect_all(self):
        for icon in self.modules.values(): icon.set_active(False)

    def get_order(self):
        return list(self.order)

    def eventFilter(self, obj, event):
        if obj is self.content:
            if event.type() in (QEvent.DragEnter, QEvent.DragMove):
                if event.mimeData().hasFormat("application/x-monolith-module"):
                    event.acceptProposedAction()
                    return True
            elif event.type() == QEvent.Drop:
                if event.mimeData().hasFormat("application/x-monolith-module"):
                    mod_id = bytes(event.mimeData().data("application/x-monolith-module")).decode()
                    target = self._module_at_pos(event.position().toPoint())
                    self.reorder_module(mod_id, target)
                    event.acceptProposedAction()
                    return True
        return super().eventFilter(obj, event)

    def reorder_module(self, mod_id, target_id):
        if mod_id not in self.order or mod_id == target_id:
            return
        self.order.remove(mod_id)
        if target_id and target_id in self.order:
            target_index = self.order.index(target_id)
            self.order.insert(target_index, mod_id)
        else:
            self.order.append(mod_id)
        self._rebuild_layout()

    def _module_at_pos(self, pos):
        widget = self.content.childAt(pos)
        while widget and widget is not self.content:
            if isinstance(widget, ModuleIcon):
                return widget.mod_id
            widget = widget.parent()
        return None

    def _rebuild_layout(self):
        while self.vbox.count():
            item = self.vbox.takeAt(0)
            if item.widget():
                item.widget().setParent(None)
        for mod_id in self.order:
            self.vbox.addWidget(self.modules[mod_id])
        self.vbox.addStretch()
        self._check_overflow()

    def _check_overflow(self):
        self.content.adjustSize()
        overflow = self.content.sizeHint().height() > self.scroll.height()
        self.arrow.setVisible(overflow)

    def scroll_down(self):
        vs = self.scroll.verticalScrollBar()
        vs.setValue(vs.value() + 50)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\modules\audiogen.py
================================================================================

import os
import json
from pathlib import Path
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QFrame, QComboBox, QDoubleSpinBox, QFileDialog,
    QAbstractSpinBox
)
from PySide6.QtCore import Qt, QThread, Signal, QUrl, QTimer
from PySide6.QtMultimedia import QMediaPlayer, QAudioOutput
from PySide6.QtGui import QPainter, QPen, QColor

from core.style import BG_INPUT, BORDER_DARK, FG_DIM, FG_TEXT, FG_ACCENT, FG_ERROR
from ui.components.atoms import SkeetGroupBox, SkeetButton, SkeetTriangleButton, CollapsibleSection

AUDIOCRAFT_AVAILABLE = False
try:
    import importlib
    importlib.import_module("audiocraft")
    AUDIOCRAFT_AVAILABLE = True
except ImportError:
    AUDIOCRAFT_AVAILABLE = False


class WaveformWidget(QFrame):
    def __init__(self):
        super().__init__()
        self.setFixedHeight(120)
        self.setStyleSheet(f"background: {BG_INPUT}; border: 1px solid {BORDER_DARK};")
        self.waveform_data = None
        
    def set_waveform(self, audio_array):
        if audio_array is not None and len(audio_array) > 0:
            # Downsample for display
            target_points = 500
            if len(audio_array) > target_points:
                step = len(audio_array) // target_points
                self.waveform_data = audio_array[::step]
            else:
                self.waveform_data = audio_array
        else:
            self.waveform_data = None
        self.update()
    
    def paintEvent(self, event):
        super().paintEvent(event)
        if self.waveform_data is None:
            painter = QPainter(self)
            painter.setPen(QPen(QColor(FG_DIM)))
            painter.drawText(self.rect(), Qt.AlignCenter, "NO WAVEFORM")
            return
            
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        w = self.width()
        h = self.height()
        mid_y = h / 2
        
        pen = QPen(QColor(FG_ACCENT), 1)
        painter.setPen(pen)
        
        data = self.waveform_data
        num_points = len(data)
        
        for i in range(num_points - 1):
            x1 = int((i / num_points) * w)
            x2 = int(((i + 1) / num_points) * w)
            
            y1 = int(mid_y - (data[i] * mid_y * 0.9))
            y2 = int(mid_y - (data[i + 1] * mid_y * 0.9))
            
            painter.drawLine(x1, y1, x2, y2)


class AudioGenWorker(QThread):
    progress = Signal(str)
    finished = Signal(object, int)
    error = Signal(str)

    def __init__(self, prompt, model_path, duration, sample_rate):
        super().__init__()
        self.prompt = prompt
        self.model_path = model_path
        self.duration = duration
        self.sample_rate = sample_rate

    def run(self):
        try:
            try:
                from audiocraft.models import MusicGen
            except ImportError:
                self.error.emit("ERROR: audiocraft not installed. pip install audiocraft")
                return
            import torchaudio
            import torch
            
            self.progress.emit("Loading model...")
            
            model = MusicGen.get_pretrained(self.model_path)
            model.set_generation_params(duration=self.duration)
            
            self.progress.emit("Generating audio...")
            
            wav = model.generate([self.prompt])
            
            audio_array = wav[0].cpu().numpy()
            
            self.finished.emit(audio_array, self.sample_rate)
            
        except Exception as e:
            self.error.emit(str(e))


class AudioGenModule(QWidget):
    def __init__(self):
        super().__init__()
        
        self.config_path = Path("config/audiogen_config.json")
        self.artifacts_dir = Path("artifacts/audio")
        self.artifacts_dir.mkdir(parents=True, exist_ok=True)
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.config = self._load_config()
        self.model_path = self.config.get("model_path", "")
        self.current_audio = None
        self.current_sample_rate = None
        self.current_filepath = None
        self.worker = None
        self._config_timer = QTimer(self)
        self._config_timer.setInterval(1000)
        self._config_timer.setSingleShot(True)
        self._config_timer.timeout.connect(self._save_config)
        self._status_reset_timer = QTimer(self)
        self._status_reset_timer.setInterval(1000)
        self._status_reset_timer.setSingleShot(True)
        self._status_reset_timer.timeout.connect(self._reset_status)
        
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)

        grp = SkeetGroupBox("AUDIO")
        inner = QVBoxLayout()
        inner.setSpacing(12)

        # Config Section
        config_section = CollapsibleSection("⚙ CONFIGURATION")
        config_layout = QVBoxLayout()
        config_layout.setSpacing(8)

        grp_model = SkeetGroupBox("MODEL LOADER")
        model_layout = QVBoxLayout()
        model_path_row = QHBoxLayout()
        lbl_model_path = QLabel("MODEL PATH")
        lbl_model_path.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_model_path.setFixedWidth(80)
        self.inp_model_path = QLineEdit(self.model_path)
        self.inp_model_path.setReadOnly(True)
        self.inp_model_path.setPlaceholderText("Select an AudioGen model file...")
        self.inp_model_path.setToolTip(self.model_path)
        self.inp_model_path.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_browse = SkeetButton("BROWSE...")
        btn_browse.setFixedWidth(90)
        btn_browse.clicked.connect(self._browse_model)
        model_path_row.addWidget(lbl_model_path)
        model_path_row.addWidget(self.inp_model_path)
        model_path_row.addWidget(btn_browse)
        model_layout.addLayout(model_path_row)

        model_row = QHBoxLayout()
        lbl_model = QLabel("MODEL ID")
        lbl_model.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_model.setFixedWidth(80)
        self.inp_model_id = QLineEdit()
        self.inp_model_id.setPlaceholderText("facebook/musicgen-small")
        self.inp_model_id.setText(self.config.get("model_id", "facebook/musicgen-small"))
        self.inp_model_id.setReadOnly(True)
        self.inp_model_id.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        model_row.addWidget(lbl_model)
        model_row.addWidget(self.inp_model_id)
        model_layout.addLayout(model_row)
        grp_model.add_layout(model_layout)
        config_layout.addWidget(grp_model)

        grp_audio = SkeetGroupBox("AUDIO CONFIG")
        audio_layout = QVBoxLayout()

        duration_row = QHBoxLayout()
        lbl_duration = QLabel("Duration (s)")
        lbl_duration.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_duration.setFixedWidth(80)
        self.inp_duration = QDoubleSpinBox()
        self.inp_duration.setRange(1.0, 30.0)
        self.inp_duration.setValue(self.config.get("duration", 5.0))
        self.inp_duration.setSingleStep(0.5)
        self.inp_duration.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_duration.setStyleSheet(f"""
            QDoubleSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        duration_row.addWidget(lbl_duration)
        btn_duration_down = SkeetTriangleButton("◀")
        btn_duration_down.clicked.connect(self.inp_duration.stepDown)
        btn_duration_up = SkeetTriangleButton("▶")
        btn_duration_up.clicked.connect(self.inp_duration.stepUp)
        duration_row.addWidget(btn_duration_down)
        duration_row.addWidget(self.inp_duration)
        duration_row.addWidget(btn_duration_up)
        duration_row.addStretch()
        audio_layout.addLayout(duration_row)

        sr_row = QHBoxLayout()
        lbl_sr = QLabel("Sample Rate")
        lbl_sr.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_sr.setFixedWidth(80)
        self.cmb_sr = QComboBox()
        self.cmb_sr.addItems(["32000", "44100", "48000"])
        self.cmb_sr.setCurrentText(str(self.config.get("sample_rate", 32000)))
        self.cmb_sr.setStyleSheet(f"""
            QComboBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        sr_row.addWidget(lbl_sr)
        sr_row.addWidget(self.cmb_sr)
        sr_row.addStretch()
        audio_layout.addLayout(sr_row)

        grp_audio.add_layout(audio_layout)
        config_layout.addWidget(grp_audio)
        
        config_section.set_content_layout(config_layout)
        inner.addWidget(config_section)

        # Prompt
        lbl_prompt = QLabel("Prompt")
        lbl_prompt.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")

        self.inp_prompt = QLineEdit()
        self.inp_prompt.setPlaceholderText("Describe a sound to generate...")
        self.inp_prompt.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 6px;
            }}
        """)

        # Buttons
        btn_row = QHBoxLayout()
        self.btn_generate = SkeetButton("GENERATE", accent=True)
        self.btn_generate.clicked.connect(self._start_generate)
        self.btn_play = SkeetButton("PLAY")
        self.btn_play.clicked.connect(self._play_audio)
        self.btn_play.setEnabled(False)
        self.btn_save = SkeetButton("SAVE AUDIO")
        self.btn_save.clicked.connect(self._save_audio)
        self.btn_save.setEnabled(False)
        btn_row.addWidget(self.btn_generate)
        btn_row.addWidget(self.btn_play)
        btn_row.addWidget(self.btn_save)
        btn_row.addStretch()

        # Waveform Display
        self.waveform_widget = WaveformWidget()

        # Status
        status_row = QHBoxLayout()
        lbl_status_title = QLabel("Status")
        lbl_status_title.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        self.lbl_status = QLabel("IDLE")
        self.lbl_status.setStyleSheet(f"color: {FG_TEXT}; font-size: 10px; font-weight: bold;")
        status_row.addWidget(lbl_status_title)
        status_row.addStretch()
        status_row.addWidget(self.lbl_status)

        inner.addWidget(lbl_prompt)
        inner.addWidget(self.inp_prompt)
        inner.addLayout(btn_row)
        inner.addWidget(self.waveform_widget)
        inner.addLayout(status_row)
        inner.addStretch()

        grp.add_layout(inner)
        layout.addWidget(grp)

        self.inp_duration.valueChanged.connect(self._queue_save_config)
        self.cmb_sr.currentTextChanged.connect(self._queue_save_config)

    def _load_config(self):
        if self.config_path.exists():
            try:
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                return config
            except:
                pass
        return {
            "model_path": "",
            "model_id": "facebook/musicgen-small",
            "duration": 5.0,
            "sample_rate": 32000
        }

    def _queue_save_config(self):
        self._status_reset_timer.stop()
        self._config_timer.start()

    def _save_config(self):
        config = {
            "model_path": self.model_path,
            "model_id": self.inp_model_id.text().strip() or self.inp_model_id.placeholderText(),
            "duration": self.inp_duration.value(),
            "sample_rate": int(self.cmb_sr.currentText())
        }
        with open(self.config_path, 'w') as f:
            json.dump(config, f, indent=2)
        self.config = config
        self._set_status("CONFIG SAVED", FG_ACCENT)
        self._status_reset_timer.start()

    def _browse_model(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Audio Model", "", "All Files (*)")
        if not path:
            return
        path = os.path.abspath(path)
        try:
            if not AUDIOCRAFT_AVAILABLE:
                self._set_status("ERROR: audiocraft not installed. pip install audiocraft", FG_ERROR)
                self.inp_model_path.setText(self.model_path)
                self.inp_model_path.setToolTip(self.model_path)
                return
            try:
                from audiocraft.models import MusicGen
            except ImportError:
                self._set_status("ERROR: audiocraft not installed. pip install audiocraft", FG_ERROR)
                self.inp_model_path.setText(self.model_path)
                self.inp_model_path.setToolTip(self.model_path)
                return
            MusicGen.get_pretrained(path)
        except Exception as exc:
            self._set_status(f"ERROR: {str(exc)}", FG_ERROR)
            self.inp_model_path.setText(self.model_path)
            self.inp_model_path.setToolTip(self.model_path)
            return
        self.model_path = path
        self.inp_model_path.setText(path)
        self.inp_model_path.setToolTip(path)
        self._queue_save_config()

    def _set_status(self, status, color):
        self.lbl_status.setText(status)
        self.lbl_status.setStyleSheet(f"color: {color}; font-size: 10px; font-weight: bold;")

    def _reset_status(self):
        self._set_status("IDLE", FG_TEXT)

    def _start_generate(self):
        if not AUDIOCRAFT_AVAILABLE:
            self._set_status("ERROR: audiocraft not installed. pip install audiocraft", FG_ERROR)
            return
            
        prompt = self.inp_prompt.text().strip()
        if not prompt:
            self._set_status("ERROR: No prompt", FG_ERROR)
            return

        self.btn_generate.setEnabled(False)
        self.btn_play.setEnabled(False)
        self.btn_save.setEnabled(False)
        self._set_status("INITIALIZING", FG_ACCENT)

        model_path = self.model_path
        if not model_path:
            self._set_status("ERROR: No model selected", FG_ERROR)
            return

        self.worker = AudioGenWorker(
            prompt,
            model_path,
            self.inp_duration.value(),
            int(self.cmb_sr.currentText())
        )
        self.worker.progress.connect(self._on_progress)
        self.worker.finished.connect(self._on_finished)
        self.worker.error.connect(self._on_error)
        self.worker.start()

    def _on_progress(self, msg):
        self._set_status(msg, FG_ACCENT)

    def _on_finished(self, audio_array, sample_rate):
        self.current_audio = audio_array
        self.current_sample_rate = sample_rate
        
        # Save temporarily for playback
        import time
        temp_filename = f"temp_audio_{int(time.time())}.wav"
        self.current_filepath = self.artifacts_dir / temp_filename
        
        try:
            import torch
            import torchaudio
            audio_tensor = torch.from_numpy(audio_array).unsqueeze(0)
            torchaudio.save(str(self.current_filepath), audio_tensor, sample_rate)
        except Exception as e:
            self._set_status(f"SAVE ERROR: {str(e)}", FG_ERROR)
            return
        
        # Display waveform (use mono channel)
        if len(audio_array.shape) > 1:
            display_data = audio_array[0]
        else:
            display_data = audio_array
        self.waveform_widget.set_waveform(display_data)
        
        self._set_status("DONE", FG_TEXT)
        self.btn_generate.setEnabled(True)
        self.btn_play.setEnabled(True)
        self.btn_save.setEnabled(True)

    def _on_error(self, err_msg):
        self._set_status(f"ERROR: {err_msg}", FG_ERROR)
        self.btn_generate.setEnabled(True)

    def _play_audio(self):
        if not self.current_filepath or not self.current_filepath.exists():
            return
            
        self.player.setSource(QUrl.fromLocalFile(str(self.current_filepath)))
        self.player.play()
        self._set_status("PLAYING", FG_ACCENT)

    def _save_audio(self):
        if self.current_audio is None:
            return
        
        if not self.current_filepath or not self.current_filepath.exists():
            return
            
        import time
        filename = f"audio_{int(time.time())}.wav"
        filepath = self.artifacts_dir / filename
        
        try:
            import shutil
            shutil.copy(self.current_filepath, filepath)
            self._set_status(f"SAVED: {filename}", FG_ACCENT)
        except Exception as e:
            self._set_status(f"SAVE ERROR: {str(e)}", FG_ERROR)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\modules\injector.py
================================================================================

import sys
import os
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
    QPushButton, QPlainTextEdit, QSplitter, QFrame
)
from PySide6.QtCore import Qt, Signal, QProcess, QUrl
from PySide6.QtGui import QTextCursor, QDragEnterEvent, QDropEvent

from core.style import BG_GROUP, BORDER_DARK, FG_DIM, FG_ACCENT, BG_INPUT, FG_ERROR, ACCENT_GOLD

class InjectorWidget(QWidget):
    sig_closed = Signal()
    sig_finished = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setObjectName("InjectorRoot")
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Toolbar
        toolbar = QFrame()
        toolbar.setFixedHeight(35)
        toolbar.setStyleSheet(f"background: {BG_GROUP}; border-bottom: 1px solid {BORDER_DARK};")
        tb_layout = QHBoxLayout(toolbar)
        tb_layout.setContentsMargins(10, 0, 10, 0)
        
        lbl_title = QLabel("RUNTIME")
        lbl_title.setStyleSheet(f"color: {ACCENT_GOLD}; font-weight: bold; font-size: 11px;")
        
        self.btn_run = QPushButton("▶ EXECUTE")
        self.btn_run.setCursor(Qt.PointingHandCursor)
        self.btn_run.setStyleSheet(f"""
            QPushButton {{ background: #1a1a1a; color: {FG_ACCENT}; border: 1px solid #333; padding: 4px 10px; font-weight:bold; font-size: 10px;}}
            QPushButton:hover {{ background: #222; border-color: {FG_ACCENT}; }}
        """)
        self.btn_run.clicked.connect(self.run_code)

        btn_close = QPushButton("×")
        btn_close.setFixedSize(20, 20)
        btn_close.setCursor(Qt.PointingHandCursor)
        btn_close.setStyleSheet("background: transparent; color: #555; border: none; font-weight: bold; font-size: 14px;")
        btn_close.clicked.connect(self.close_addon)
        
        tb_layout.addWidget(lbl_title)
        tb_layout.addStretch()
        tb_layout.addWidget(self.btn_run)
        tb_layout.addWidget(btn_close)
        
        layout.addWidget(toolbar)
        
        # Splitter (Code | Console)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setHandleWidth(1)
        splitter.setStyleSheet(f"QSplitter::handle {{ background: {BORDER_DARK}; }}")
        
        self.editor = QPlainTextEdit()
        self.editor.setPlaceholderText("# Drag .py file here or write code...")
        self.editor.setStyleSheet(f"""
            QPlainTextEdit {{
                background: {BG_INPUT}; color: #dcdcdc; 
                border: none; font-family: 'Consolas', monospace; font-size: 12px; padding: 10px;
            }}
        """)
        
        self.console = QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setPlaceholderText("Output...")
        self.console.setStyleSheet(f"""
            QPlainTextEdit {{
                background: #080808; color: {FG_DIM}; 
                border: none; border-left: 1px solid {BORDER_DARK};
                font-family: 'Consolas', monospace; font-size: 11px; padding: 10px;
            }}
        """)
        
        splitter.addWidget(self.editor)
        splitter.addWidget(self.console)
        splitter.setSizes([400, 400])
        
        layout.addWidget(splitter)

        self.process = QProcess(self)
        self.process.setProcessChannelMode(QProcess.MergedChannels)
        self.process.readyReadStandardOutput.connect(self._read_output)
        self.process.finished.connect(self._process_finished)

    def dragEnterEvent(self, event: QDragEnterEvent):
        # Accept if files (Explorer) or Text (Qt Tree View default drag)
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event: QDropEvent):
        file_path = None
        
        # Case 1: Dragged from Explorer (MimeType: text/uri-list)
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls:
                file_path = urls[0].toLocalFile()

        # Case 2: Dragged from Databank Tree (MimeType: text/plain usually)
        # The tree might just pass the path string
        elif event.mimeData().hasText():
            text = event.mimeData().text()
            # Clean up if it has file:/// prefix even in text mode
            if text.startswith("file:///"):
                file_path = QUrl(text).toLocalFile()
            elif os.path.exists(text):
                file_path = text

        if file_path and os.path.exists(file_path):
            self._load_file(file_path)
        else:
            self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: Could not resolve file path.</span>")

    def _load_file(self, path):
        if os.path.isfile(path) and path.endswith(".py"):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    self.editor.setPlainText(f.read())
                self.console.appendHtml(f"<span style='color:{FG_ACCENT}'>→ LOADED: {os.path.basename(path)}</span>")
            except Exception as e:
                self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: {e}</span>")
        else:
             self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: Not a .py file</span>")

    def run_code(self):
        code = self.editor.toPlainText()
        if not code.strip(): return
        
        if self.process.state() != QProcess.NotRunning:
            self.console.appendHtml(f"<span style='color:{FG_ERROR}'>BUSY: Process running...</span>")
            return

        self.console.clear()
        self.console.appendHtml(f"<span style='color:{FG_ACCENT}'>→ EXECUTING SCRIPT...</span>")
        self.process.start(sys.executable, ["-c", code])

    def _read_output(self):
        data = self.process.readAllStandardOutput().data().decode()
        self.console.moveCursor(QTextCursor.End)
        self.console.insertPlainText(data)

    def _process_finished(self):
        self.console.appendHtml(f"<br><span style='color:{FG_DIM}'>→ PROCESS TERMINATED</span>")
        self.sig_finished.emit()

    def close_addon(self):
        if self.process.state() != QProcess.NotRunning:
            self.process.kill()
        self.sig_closed.emit()
        self.deleteLater()

    def closeEvent(self, event):
        if self.process.state() != QProcess.NotRunning:
            self.process.kill()
            self.process.waitForFinished(300)
        event.accept()



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\modules\manager.py
================================================================================

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QScrollArea
from PySide6.QtCore import Signal, Qt

from ui.components.atoms import SkeetGroupBox, SkeetButton
from core.style import FG_DIM

class PageAddons(QWidget):
    sig_launch_addon = Signal(str)
    sig_open_vitals = Signal()
    sig_open_overseer = Signal()

    def __init__(self, state):
        super().__init__()
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)

        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(0, 0, 0, 0)

        grp_modules = SkeetGroupBox("AVAILABLE MODULES")
        
        mod_layout = QVBoxLayout()
        mod_layout.setSpacing(15)
        
        lbl_info = QLabel("Select a runtime module to attach to the workspace.")
        lbl_info.setStyleSheet(f"color: {FG_DIM}; font-size: 11px;")

        btn_terminal = SkeetButton("TERMINAL")
        btn_terminal.clicked.connect(lambda: self.sig_launch_addon.emit("terminal"))

        btn_databank = SkeetButton("DATABANK")
        btn_databank.clicked.connect(lambda: self.sig_launch_addon.emit("databank"))

        btn_injector = SkeetButton("INJECTOR")
        btn_injector.clicked.connect(lambda: self.sig_launch_addon.emit("injector"))

        btn_sd = SkeetButton("VISION")
        btn_sd.clicked.connect(lambda: self.sig_launch_addon.emit("sd"))

        btn_audiogen = SkeetButton("AUDIO")
        btn_audiogen.clicked.connect(lambda: self.sig_launch_addon.emit("audiogen"))

        mod_layout.addWidget(lbl_info)
        mod_layout.addWidget(btn_terminal)
        mod_layout.addWidget(btn_databank)
        mod_layout.addWidget(btn_injector)
        mod_layout.addWidget(btn_sd)
        mod_layout.addWidget(btn_audiogen)
        mod_layout.addStretch()
        
        grp_modules.add_layout(mod_layout)
        scroll_layout.addWidget(grp_modules)
        
        grp_system = SkeetGroupBox("SYSTEM")
        system_layout = QVBoxLayout()
        system_layout.setSpacing(10)

        btn_vitals = SkeetButton("VITALS")
        btn_vitals.clicked.connect(self.sig_open_vitals.emit)

        btn_overseer = SkeetButton("OVERSEER")
        btn_overseer.clicked.connect(self.sig_open_overseer.emit)

        system_layout.addWidget(btn_vitals)
        system_layout.addWidget(btn_overseer)
        grp_system.add_layout(system_layout)
        scroll_layout.addWidget(grp_system)
        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_content)
        layout.addWidget(scroll_area)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\modules\sd.py
================================================================================

import json

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QScrollArea, QFileDialog, QSpinBox, QDoubleSpinBox,
    QAbstractSpinBox
)
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QPixmap, QImage

from core.style import BG_INPUT, BORDER_DARK, FG_DIM, FG_TEXT, FG_ACCENT, FG_ERROR
from core.state import SystemStatus
from core.paths import CONFIG_DIR, MONOLITH_ROOT
from monokernel.bridge import MonoBridge
from monokernel.guard import MonoGuard
from ui.components.atoms import SkeetGroupBox, SkeetButton, SkeetTriangleButton, CollapsibleSection

class SDModule(QWidget):
    def __init__(self, bridge: MonoBridge, guard: MonoGuard):
        super().__init__()
        self.bridge = bridge
        self.guard = guard

        self.config_path = CONFIG_DIR / "vision_config.json"
        self.legacy_config_path = CONFIG_DIR / "sd_config.json"
        self.artifacts_dir = MONOLITH_ROOT / "artifacts" / "vision"
        self.artifacts_dir.mkdir(parents=True, exist_ok=True)
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.config = self._load_config()
        self.model_path = self.config.get("model_path", "")
        self.is_model_loaded = False
        self.current_image = None
        self._engine_status = SystemStatus.READY
        self._config_timer = QTimer(self)
        self._config_timer.setInterval(1000)
        self._config_timer.setSingleShot(True)
        self._config_timer.timeout.connect(self._save_config)
        self._status_reset_timer = QTimer(self)
        self._status_reset_timer.setInterval(1000)
        self._status_reset_timer.setSingleShot(True)
        self._status_reset_timer.timeout.connect(self._reset_status)
        if self.model_path:
            self.bridge.submit(
                self.bridge.wrap(
                    "vision",
                    "set_path",
                    "vision",
                    payload={"path": self.model_path},
                )
            )

        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)

        grp = SkeetGroupBox("VISION")
        inner = QVBoxLayout()
        inner.setSpacing(12)

        # Config Section
        config_section = CollapsibleSection("⚙ CONFIGURATION")
        config_layout = QVBoxLayout()
        config_layout.setSpacing(8)
        
        # Model Loader
        grp_loader = SkeetGroupBox("MODEL LOADER")
        loader_layout = QVBoxLayout()
        loader_row = QHBoxLayout()
        lbl_model = QLabel("Model Path")
        lbl_model.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        self.inp_model = QLineEdit(self.model_path)
        self.inp_model.setReadOnly(True)
        self.inp_model.setPlaceholderText("Select a model file (.ckpt or .safetensors)...")
        self.inp_model.setToolTip(self.model_path)
        self.inp_model.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_browse = SkeetButton("BROWSE...")
        btn_browse.setFixedWidth(90)
        btn_browse.clicked.connect(self._browse_model)
        loader_row.addWidget(lbl_model, 0)
        loader_row.addWidget(self.inp_model, 1)
        loader_row.addWidget(btn_browse, 0)
        self.btn_load = SkeetButton("LOAD MODEL")
        self.btn_load.setCheckable(True)
        self.btn_load.setChecked(False)
        self.btn_load.clicked.connect(self._load_model)
        loader_layout.addLayout(loader_row)
        loader_layout.addWidget(self.btn_load)
        grp_loader.add_layout(loader_layout)
        config_layout.addWidget(grp_loader)
        
        # Steps
        steps_row = QHBoxLayout()
        lbl_steps = QLabel("Steps")
        lbl_steps.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_steps.setFixedWidth(80)
        self.inp_steps = QSpinBox()
        self.inp_steps.setRange(1, 150)
        self.inp_steps.setValue(self.config.get("steps", 25))
        self.inp_steps.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_steps.setStyleSheet(f"""
            QSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        steps_row.addWidget(lbl_steps)
        btn_steps_down = SkeetTriangleButton("◀")
        btn_steps_down.clicked.connect(self.inp_steps.stepDown)
        btn_steps_up = SkeetTriangleButton("▶")
        btn_steps_up.clicked.connect(self.inp_steps.stepUp)
        steps_row.addWidget(btn_steps_down)
        steps_row.addWidget(self.inp_steps)
        steps_row.addWidget(btn_steps_up)
        steps_row.addStretch()
        config_layout.addLayout(steps_row)
        
        # Strength
        strength_row = QHBoxLayout()
        lbl_strength = QLabel("Strength")
        lbl_strength.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_strength.setFixedWidth(80)
        self.inp_strength = QDoubleSpinBox()
        self.inp_strength.setRange(1.0, 20.0)
        self.inp_strength.setValue(self.config.get("guidance_scale", 7.5))
        self.inp_strength.setSingleStep(0.5)
        self.inp_strength.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_strength.setStyleSheet(f"""
            QDoubleSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_strength_down = SkeetTriangleButton("◀")
        btn_strength_down.clicked.connect(self.inp_strength.stepDown)
        btn_strength_up = SkeetTriangleButton("▶")
        btn_strength_up.clicked.connect(self.inp_strength.stepUp)
        strength_row.addWidget(lbl_strength)
        strength_row.addWidget(btn_strength_down)
        strength_row.addWidget(self.inp_strength)
        strength_row.addWidget(btn_strength_up)
        strength_row.addStretch()
        config_layout.addLayout(strength_row)
        
        # Seed
        seed_row = QHBoxLayout()
        lbl_seed = QLabel("Seed")
        lbl_seed.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_seed.setFixedWidth(80)
        self.inp_seed = QSpinBox()
        self.inp_seed.setRange(-1, 2147483647)
        self.inp_seed.setSpecialValueText("RANDOM")
        self.inp_seed.setValue(self.config.get("seed", -1))
        self.inp_seed.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_seed.setStyleSheet(f"""
            QSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_seed_down = SkeetTriangleButton("◀")
        btn_seed_down.clicked.connect(self.inp_seed.stepDown)
        btn_seed_up = SkeetTriangleButton("▶")
        btn_seed_up.clicked.connect(self.inp_seed.stepUp)
        seed_row.addWidget(lbl_seed)
        seed_row.addWidget(btn_seed_down)
        seed_row.addWidget(self.inp_seed)
        seed_row.addWidget(btn_seed_up)
        seed_row.addStretch()
        config_layout.addLayout(seed_row)
        
        config_section.set_content_layout(config_layout)
        inner.addWidget(config_section)

        # Prompt
        lbl_prompt = QLabel("Prompt")
        lbl_prompt.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")

        self.inp_prompt = QLineEdit()
        self.inp_prompt.setPlaceholderText("Describe an image to generate...")
        self.inp_prompt.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 6px;
            }}
        """)

        # Buttons
        btn_row = QHBoxLayout()
        self.btn_generate = SkeetButton("GENERATE", accent=True)
        self.btn_generate.clicked.connect(self._start_generate)
        self.btn_generate.setEnabled(self.is_model_loaded)
        self.btn_stop = SkeetButton("STOP")
        self.btn_stop.clicked.connect(lambda: self.bridge.stop("vision"))
        self.btn_stop.setEnabled(False)
        self.btn_save = SkeetButton("SAVE IMAGE")
        self.btn_save.clicked.connect(self._save_image)
        self.btn_save.setEnabled(False)
        btn_row.addWidget(self.btn_generate)
        btn_row.addWidget(self.btn_stop)
        btn_row.addWidget(self.btn_save)
        btn_row.addStretch()

        # Preview
        preview_scroll = QScrollArea()
        preview_scroll.setWidgetResizable(True)
        preview_scroll.setFixedHeight(400)
        preview_scroll.setStyleSheet(f"background: {BG_INPUT}; border: 1px solid {BORDER_DARK};")
        
        self.lbl_preview = QLabel("NO IMAGE")
        self.lbl_preview.setAlignment(Qt.AlignCenter)
        self.lbl_preview.setStyleSheet(f"color: {FG_DIM}; font-size: 12px;")
        preview_scroll.setWidget(self.lbl_preview)

        # Status
        status_row = QHBoxLayout()
        lbl_status_title = QLabel("Status")
        lbl_status_title.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        self.lbl_status = QLabel("IDLE")
        self.lbl_status.setStyleSheet(f"color: {FG_TEXT}; font-size: 10px; font-weight: bold;")
        status_row.addWidget(lbl_status_title)
        status_row.addStretch()
        status_row.addWidget(self.lbl_status)

        inner.addWidget(lbl_prompt)
        inner.addWidget(self.inp_prompt)
        inner.addLayout(btn_row)
        inner.addWidget(preview_scroll)
        inner.addLayout(status_row)
        inner.addStretch()

        grp.add_layout(inner)
        layout.addWidget(grp)

        self.inp_steps.valueChanged.connect(self._queue_save_config)
        self.inp_strength.valueChanged.connect(self._queue_save_config)
        self.inp_seed.valueChanged.connect(self._queue_save_config)
        self.guard.sig_image.connect(self._on_image)
        self.guard.sig_status.connect(self._on_status)
        self.guard.sig_trace.connect(lambda _engine_key, message: self._on_trace(message))

    def _load_config(self):
        if self.config_path.exists():
            try:
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                return self._normalize_config(config)
            except Exception:
                pass
        if self.legacy_config_path.exists():
            try:
                with open(self.legacy_config_path, 'r') as f:
                    config = json.load(f)
                config = self._normalize_config(config)
                with open(self.config_path, 'w') as f:
                    json.dump(config, f, indent=2)
                return config
            except Exception:
                pass
        return {
            "model_path": "",
            "steps": 25,
            "guidance_scale": 7.5,
            "seed": -1
        }

    def _normalize_config(self, config):
        use_seed = config.get("use_seed")
        if use_seed is False:
            config["seed"] = -1
        config.pop("use_seed", None)
        if "seed" not in config:
            config["seed"] = -1
        return config

    def _save_config(self):
        config = {
            "model_path": self.model_path,
            "steps": self.inp_steps.value(),
            "guidance_scale": self.inp_strength.value(),
            "seed": self.inp_seed.value()
        }
        with open(self.config_path, 'w') as f:
            json.dump(config, f, indent=2)
        self.config = config
        if self._engine_status not in (
            SystemStatus.LOADING,
            SystemStatus.RUNNING,
            SystemStatus.UNLOADING,
        ):
            self._set_status("CONFIG SAVED", FG_ACCENT)
            self._status_reset_timer.start()

    def _browse_model(self):
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Vision Model",
            "",
            "Model Files (*.ckpt *.safetensors);;All Files (*)"
        )
        if path:
            self.inp_model.setText(path)
            self.inp_model.setToolTip(path)
            self.btn_load.setChecked(False)
            self.btn_load.setText("LOAD MODEL")
            self.is_model_loaded = False

    def _load_model(self):
        if self.btn_load.isChecked():
            path = self.inp_model.text().strip()
            if not path:
                self._set_status("ERROR: No model selected", FG_ERROR)
                self.btn_load.setChecked(False)
                return
            self.model_path = path
            self._queue_save_config()
            self.bridge.submit(
                self.bridge.wrap(
                    "vision",
                    "set_path",
                    "vision",
                    payload={"path": path},
                )
            )
            self.bridge.submit(self.bridge.wrap("vision", "load", "vision"))
        else:
            self.bridge.submit(self.bridge.wrap("vision", "unload", "vision"))

    def _queue_save_config(self):
        self._status_reset_timer.stop()
        self._config_timer.start()

    def _set_status(self, status, color):
        self.lbl_status.setText(status)
        self.lbl_status.setStyleSheet(f"color: {color}; font-size: 10px; font-weight: bold;")

    def _reset_status(self):
        self._set_status("IDLE", FG_TEXT)

    def _start_generate(self):
        prompt = self.inp_prompt.text().strip()
        if not prompt:
            self._set_status("ERROR: No prompt", FG_ERROR)
            return

        self.btn_generate.setEnabled(False)
        self.btn_save.setEnabled(False)
        self._set_status("REQUESTED", FG_ACCENT)

        seed_value = self.inp_seed.value()
        seed = None if seed_value < 0 else seed_value
        config = {
            "steps": self.inp_steps.value(),
            "guidance_scale": self.inp_strength.value(),
            "seed": seed,
        }
        self.bridge.submit(
            self.bridge.wrap(
                "vision",
                "generate",
                "vision",
                payload={"prompt": prompt, "config": config},
            )
        )

    def _save_image(self):
        if not self.current_image:
            return
            
        import time
        filename = f"vision_{int(time.time())}.png"
        filepath = self.artifacts_dir / filename
        
        try:
            if isinstance(self.current_image, QImage):
                self.current_image.save(str(filepath))
            else:
                self.current_image.save(filepath)
            self._set_status(f"SAVED: {filename}", FG_ACCENT)
        except Exception as e:
            self._set_status(f"SAVE ERROR: {str(e)}", FG_ERROR)

    def _on_image(self, image):
        self.current_image = image
        if isinstance(image, QImage):
            qimage = image
        else:
            pil_image = image.convert("RGB")
            data = pil_image.tobytes("raw", "RGB")
            qimage = QImage(
                data,
                pil_image.width,
                pil_image.height,
                QImage.Format_RGB888,
            ).copy()

        pixmap = QPixmap.fromImage(qimage)
        self.lbl_preview.setPixmap(pixmap.scaled(
            self.lbl_preview.width() - 20,
            self.lbl_preview.height() - 20,
            Qt.KeepAspectRatio,
            Qt.SmoothTransformation,
        ))
        self._set_status("DONE", FG_TEXT)
        self.btn_save.setEnabled(True)

    def _on_status(self, engine_key: str, status: SystemStatus) -> None:
        if engine_key != "vision":
            return
        self._engine_status = status
        is_busy = status in (
            SystemStatus.LOADING,
            SystemStatus.RUNNING,
            SystemStatus.UNLOADING,
        )
        self.btn_generate.setEnabled(not is_busy and self.is_model_loaded)
        self.btn_load.setEnabled(not is_busy)
        self.btn_stop.setEnabled(is_busy)
        if status == SystemStatus.LOADING:
            self._set_status("LOADING", FG_ACCENT)
            self.btn_load.setText("LOADING...")
        elif status == SystemStatus.RUNNING:
            self._set_status("RUNNING", FG_ACCENT)
        elif status == SystemStatus.UNLOADING:
            self._set_status("UNLOADING", FG_ACCENT)
        elif status == SystemStatus.READY:
            self._set_status("READY", FG_TEXT)
            if self.btn_load.isChecked() and self.model_path:
                self.is_model_loaded = True
                self.btn_load.setText("UNLOAD MODEL")
            else:
                self.is_model_loaded = False
                self.btn_load.setChecked(False)
                self.btn_load.setText("LOAD MODEL")
            self.btn_generate.setEnabled(self.is_model_loaded and not is_busy)
        elif status == SystemStatus.ERROR:
            self._set_status("ERROR", FG_ERROR)
            self.is_model_loaded = False
            self.btn_load.setChecked(False)
            self.btn_load.setText("LOAD MODEL")
            self.btn_generate.setEnabled(False)

    def _on_trace(self, message: str) -> None:
        if "VISION: ERROR:" in message:
            self._set_status(message.replace("VISION: ", ""), FG_ERROR)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\pages\chat.py
================================================================================

import json
import re
from datetime import datetime, timezone
from pathlib import Path

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTextEdit,
    QLineEdit, QPushButton, QLabel, QFileDialog,
    QSplitter, QListWidget, QListWidgetItem, QStackedWidget,
    QMessageBox, QButtonGroup, QMenu
)
from PySide6.QtCore import Signal, Qt, QTimer, QDateTime
from PySide6.QtGui import QActionGroup

from core.state import SystemStatus
from core.style import BG_INPUT, FG_DIM, FG_TEXT, ACCENT_GOLD, FG_ERROR, SCROLLBAR_STYLE
from ui.components.atoms import SkeetGroupBox, SkeetButton, SkeetSlider
from ui.components.complex import BehaviorTagInput
from ui.components.message_widget import MessageWidget
from core.llm_config import DEFAULT_CONFIG, MASTER_PROMPT, load_config, save_config
from core.paths import ARCHIVE_DIR

class PageChat(QWidget):
    sig_generate = Signal(str, bool)
    sig_load = Signal()
    sig_unload = Signal()
    sig_stop = Signal()
    sig_sync_history = Signal(list)
    sig_set_model_path = Signal(str)
    sig_set_ctx_limit = Signal(int)
    sig_operator_loaded = Signal(str)
    sig_debug = Signal(str)

    def __init__(self, state, ui_bridge):
        super().__init__()
        self.state = state
        self.ui_bridge = ui_bridge
        self.config = load_config()
        self._token_buf: list[str] = []
        self._flush_timer = QTimer(self)
        self._flush_timer.setInterval(25)
        self._flush_timer.timeout.connect(self._flush_tokens)
        self._archive_dir = self._get_archive_dir()
        self._archive_dir.mkdir(parents=True, exist_ok=True)
        self._session_counter = 0
        self._current_session = self._create_session()
        self._undo_snapshot = None
        self._title_generated = False
        self._suppress_title_regen = False
        self._active_assistant_index = None
        self._rewrite_assistant_index = None
        self._active_widget: MessageWidget | None = None
        self._last_status = None
        self._is_running = False
        self._is_model_loaded = False
        self._pending_update_text = None
        self._awaiting_update_restart = False
        self._update_trace_state = None
        self._update_token_count = 0
        self._update_progress_index = 0
        self._config_dirty = False
        self._thinking_mode = bool(self.config.get("thinking_mode", False))
        # When user clicks Edit/Regen/Delete while a generation is running, we STOP first,
        # then apply the mutation on the next READY.
        self._pending_mutation = None  # type: ignore[assignment]


        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(20)

        main_split = QSplitter(Qt.Horizontal)
        main_split.setChildrenCollapsible(False)
        layout.addWidget(main_split)

        # === MODEL LOADER (lives in CONTROL tab) ===
        grp_load = SkeetGroupBox("MODEL LOADER")
        self.path_display = QLineEdit()
        self.path_display.setReadOnly(True)
        self.path_display.setPlaceholderText("No GGUF Selected")
        self.path_display.setStyleSheet(
            f"background: {BG_INPUT}; color: #555; border: 1px solid #333; padding: 5px;"
        )
        btn_browse = SkeetButton("...")
        btn_browse.setFixedWidth(30)
        btn_browse.clicked.connect(self.pick_file)
        row_file = QHBoxLayout()
        row_file.addWidget(self.path_display)
        row_file.addWidget(btn_browse)
        self.btn_load = SkeetButton("LOAD MODEL")
        self.btn_load.clicked.connect(self.toggle_load)
        grp_load.add_layout(row_file)
        grp_load.add_widget(self.btn_load)

        # === AI CONFIGURATION (lives in SETTINGS tab) ===
        self.s_temp = SkeetSlider("Temperature", 0.1, 2.0, self.config.get("temp", 0.7))
        self.s_temp.valueChanged.connect(lambda v: self._update_config_value("temp", v))
        self.s_top = SkeetSlider("Top-P", 0.1, 1.0, self.config.get("top_p", 0.9))
        self.s_top.valueChanged.connect(lambda v: self._update_config_value("top_p", v))
        self.s_tok = SkeetSlider(
            "Max Tokens", 512, 8192, self.config.get("max_tokens", 2048), is_int=True
        )
        self.s_tok.valueChanged.connect(
            lambda v: self._update_config_value("max_tokens", int(v))
        )
        self.s_ctx = SkeetSlider(
            "Context Limit", 1024, 16384, self.config.get("ctx_limit", 8192), is_int=True
        )
        self.s_ctx.valueChanged.connect(self._on_ctx_limit_changed)

        save_row = QHBoxLayout()
        self.lbl_config_state = QLabel("SAVED")
        self.lbl_config_state.setStyleSheet(f"color: {FG_DIM}; font-size: 10px; font-weight: bold;")
        self.btn_save_config = SkeetButton("SAVE SETTINGS")
        self.btn_save_config.clicked.connect(self._save_config)
        btn_reset_config = SkeetButton("RESET")
        btn_reset_config.clicked.connect(self._reset_config)
        save_row.addWidget(self.lbl_config_state)
        save_row.addStretch()
        save_row.addWidget(btn_reset_config)
        save_row.addWidget(self.btn_save_config)

        # === OPERATIONS GROUP with 3 tabs ===
        operations_group = SkeetGroupBox("OPERATIONS")
        operations_layout = QVBoxLayout()
        operations_layout.setSpacing(10)

        tab_row = QHBoxLayout()
        tab_style = f"""
            QPushButton {{
                background: #181818; border: 1px solid #333; color: {FG_DIM};
                padding: 6px 12px; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:checked {{
                background: #222; color: {ACCENT_GOLD}; border: 1px solid {ACCENT_GOLD};
            }}
            QPushButton:hover {{ color: {FG_TEXT}; border: 1px solid {FG_TEXT}; }}
        """
        self.btn_tab_control = SkeetButton("CONTROL")
        self.btn_tab_control.setCheckable(True)
        self.btn_tab_control.setChecked(True)
        self.btn_tab_control.setStyleSheet(tab_style)
        self.btn_tab_archive = SkeetButton("ARCHIVE")
        self.btn_tab_archive.setCheckable(True)
        self.btn_tab_archive.setStyleSheet(tab_style)
        self.btn_tab_settings = SkeetButton("SETTINGS")
        self.btn_tab_settings.setCheckable(True)
        self.btn_tab_settings.setStyleSheet(tab_style)
        tab_group = QButtonGroup(self)
        tab_group.setExclusive(True)
        tab_group.addButton(self.btn_tab_control)
        tab_group.addButton(self.btn_tab_archive)
        tab_group.addButton(self.btn_tab_settings)
        tab_row.addWidget(self.btn_tab_control)
        tab_row.addWidget(self.btn_tab_archive)
        tab_row.addWidget(self.btn_tab_settings)
        tab_row.addStretch()
        operations_layout.addLayout(tab_row)

        self.ops_stack = QStackedWidget()
        operations_layout.addWidget(self.ops_stack)

        # --- CONTROL tab: Model Loader (top-level, no collapsible) ---
        control_tab = QWidget()
        control_layout = QVBoxLayout(control_tab)
        control_layout.setSpacing(12)
        control_layout.addWidget(grp_load)

        # --- Collapsible OPTIONS panel ---
        self._options_expanded = False
        self.btn_options_toggle = QPushButton("▸ OPTIONS")
        self.btn_options_toggle.setCursor(Qt.PointingHandCursor)
        self.btn_options_toggle.setStyleSheet(f"""
            QPushButton {{
                background: transparent; border: none;
                color: {FG_DIM}; font-size: 9px; font-weight: bold;
                letter-spacing: 1px; text-align: left; padding: 4px 0;
            }}
            QPushButton:hover {{ color: {ACCENT_GOLD}; }}
        """)
        self.btn_options_toggle.clicked.connect(self._toggle_options_panel)
        control_layout.addWidget(self.btn_options_toggle)

        self.options_panel = QWidget()
        self.options_panel.setVisible(False)
        options_layout = QVBoxLayout(self.options_panel)
        options_layout.setContentsMargins(0, 0, 0, 0)
        options_layout.setSpacing(8)

        # Attach file button
        self.btn_attach = SkeetButton("📎  ATTACH FILE")
        self.btn_attach.clicked.connect(self._attach_file_placeholder)
        options_layout.addWidget(self.btn_attach)

        # Think mode toggle row
        think_row = QHBoxLayout()
        think_row.setSpacing(4)
        lbl_think = QLabel("THINK")
        lbl_think.setStyleSheet(f"color: {FG_DIM}; font-size: 9px; font-weight: bold; letter-spacing: 1px;")
        think_row.addWidget(lbl_think)

        think_style = f"""
            QPushButton {{
                background: #181818; border: 1px solid #333; color: {FG_DIM};
                padding: 4px 10px; font-size: 9px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:checked {{
                background: #222; color: {ACCENT_GOLD}; border: 1px solid {ACCENT_GOLD};
            }}
            QPushButton:hover {{ color: {FG_TEXT}; border: 1px solid {FG_TEXT}; }}
        """
        self.btn_think_off = QPushButton("OFF")
        self.btn_think_off.setCheckable(True)
        self.btn_think_off.setStyleSheet(think_style)
        self.btn_think_std = QPushButton("STD")
        self.btn_think_std.setCheckable(True)
        self.btn_think_std.setStyleSheet(think_style)
        self.btn_think_ext = QPushButton("EXT")
        self.btn_think_ext.setCheckable(True)
        self.btn_think_ext.setStyleSheet(think_style)

        self._think_group = QButtonGroup(self)
        self._think_group.setExclusive(True)
        self._think_group.addButton(self.btn_think_off)
        self._think_group.addButton(self.btn_think_std)
        self._think_group.addButton(self.btn_think_ext)
        if self._thinking_mode:
            self.btn_think_std.setChecked(True)
        else:
            self.btn_think_off.setChecked(True)
        self.btn_think_off.clicked.connect(lambda: self._set_thinking_mode(False, "Off"))
        self.btn_think_std.clicked.connect(lambda: self._set_thinking_mode(True, "Standard"))
        self.btn_think_ext.clicked.connect(lambda: self._set_thinking_mode(True, "Extended"))

        think_row.addWidget(self.btn_think_off)
        think_row.addWidget(self.btn_think_std)
        think_row.addWidget(self.btn_think_ext)
        think_row.addStretch()
        options_layout.addLayout(think_row)

        control_layout.addWidget(self.options_panel)
        control_layout.addStretch()

        # --- ARCHIVE tab ---
        archive_tab = QWidget()
        archive_layout = QVBoxLayout(archive_tab)
        archive_layout.setSpacing(10)

        archive_controls = QHBoxLayout()
        self.btn_save_chat = SkeetButton("SAVE")
        self.btn_save_chat.clicked.connect(self._save_chat_archive)
        self.btn_load_chat = SkeetButton("LOAD")
        self.btn_load_chat.clicked.connect(self._load_chat_archive)
        self.btn_delete_chat = SkeetButton("DELETE")
        self.btn_delete_chat.clicked.connect(self._delete_selected_archive)
        self.btn_clear_chat = SkeetButton("CLEAR")
        self.btn_clear_chat.clicked.connect(lambda: self._clear_current_session(delete_archive=False))
        archive_controls.addWidget(self.btn_save_chat)
        archive_controls.addWidget(self.btn_load_chat)
        archive_controls.addWidget(self.btn_delete_chat)
        archive_controls.addWidget(self.btn_clear_chat)
        archive_controls.addStretch()
        archive_layout.addLayout(archive_controls)

        self.archive_list = QListWidget()
        self.archive_list.setStyleSheet(f"""
            QListWidget {{
                background: {BG_INPUT}; color: {FG_TEXT}; border: 1px solid #222;
                font-family: 'Consolas', monospace; font-size: 10px;
            }}
            QListWidget::item {{ padding: 6px; }}
            QListWidget::item:selected {{ background: #222; color: {ACCENT_GOLD}; }}
            {SCROLLBAR_STYLE}
        """)
        archive_layout.addWidget(self.archive_list)

        self.lbl_behavior = QLabel("BEHAVIOR TAGS")
        self.lbl_behavior.setStyleSheet(
            f"color: #444; font-size: 8px; font-weight: bold; letter-spacing: 1px;"
        )
        self.behavior_tags = BehaviorTagInput([])
        self.behavior_tags.tagsChanged.connect(self._on_behavior_tags_changed)
        self.behavior_tags.setStyleSheet(
            f"background: #111; border: 1px solid #1a1a1a; border-radius: 2px;"
        )
        self.behavior_tags.setMaximumHeight(36)

        # --- SETTINGS tab: AI Configuration + Save/Reset ---
        settings_tab = QWidget()
        settings_layout = QVBoxLayout(settings_tab)
        settings_layout.setSpacing(10)
        settings_layout.addWidget(self.s_temp)
        settings_layout.addWidget(self.s_top)
        settings_layout.addWidget(self.s_tok)
        settings_layout.addWidget(self.s_ctx)
        settings_layout.addWidget(self.lbl_behavior)
        settings_layout.addWidget(self.behavior_tags)
        settings_layout.addLayout(save_row)
        settings_layout.addStretch()

        self.ops_stack.addWidget(control_tab)
        self.ops_stack.addWidget(archive_tab)
        self.ops_stack.addWidget(settings_tab)
        self.btn_tab_control.toggled.connect(lambda checked: self._switch_ops_tab(0, checked))
        self.btn_tab_archive.toggled.connect(lambda checked: self._switch_ops_tab(1, checked))
        self.btn_tab_settings.toggled.connect(lambda checked: self._switch_ops_tab(2, checked))

        operations_group.add_layout(operations_layout)

        chat_group = SkeetGroupBox("TERMINAL")
        chat_layout = QVBoxLayout()
        chat_layout.setSpacing(10)

        self.message_list = QListWidget()
        self.message_list.setVerticalScrollMode(QListWidget.ScrollPerPixel)
        self.message_list.setStyleSheet(f"""
            QListWidget {{
                background: transparent; color: #ccc; border: 1px solid #222;
                font-family: 'Consolas', monospace; font-size: 12px;
            }}
            QListWidget::item {{
                border: none;
                background: transparent;
                padding: 0px;
            }}
            {SCROLLBAR_STYLE}
        """)
        chat_layout.addWidget(self.message_list)
        
        # --- Input toolbar (between separator and input box) ---
        # --- Input row ---
        input_row = QHBoxLayout()
        self.input = QLineEdit()
        self.input.setPlaceholderText("Enter command...")
        self.input.returnPressed.connect(self.handle_send_click)
        self.input.textChanged.connect(self._on_input_changed)
        self.input.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: white; border: 1px solid #333;
                padding: 8px; font-family: 'Verdana'; font-size: 11px;
            }}
            QLineEdit:focus {{ border: 1px solid {ACCENT_GOLD}; }}
        """)
        
        self.btn_send = QPushButton("SEND")
        self.btn_send.setCursor(Qt.PointingHandCursor)
        self.btn_send.setFixedWidth(80)
        self._btn_style_template = """
            QPushButton {{
                background: {bg};
                border: 1px solid {color};
                color: {color};
                padding: 8px;
                font-size: 11px;
                font-weight: bold;
                border-radius: 2px;
            }}
            QPushButton:hover {{ background: {color}; color: black; }}
            QPushButton:pressed {{ background: #b08d2b; }}
        """
        self._set_send_button_state(is_running=False)
        self.btn_send.clicked.connect(self.handle_send_click)

        input_row.addWidget(self.input)
        input_row.addWidget(self.btn_send)
        chat_layout.addLayout(input_row)
        
        chat_group.add_layout(chat_layout)

        right_stack = QSplitter(Qt.Vertical)
        right_stack.setChildrenCollapsible(False)

        trace_group = SkeetGroupBox("REASONING TRACE")
        self.trace = QTextEdit()
        self.trace.setReadOnly(True)
        self.trace.setStyleSheet(f"""
            QTextEdit {{
                background-color: {BG_INPUT};
                color: {FG_TEXT};
                border: 1px solid #222;
                font-family: 'Consolas', monospace;
                font-size: 10px;
            }}
            QTextEdit::viewport {{
                background-color: {BG_INPUT};
            }}
            {SCROLLBAR_STYLE}
        """)
        self.lbl_config_update = QLabel("")
        self.lbl_config_update.setStyleSheet(f"color: {ACCENT_GOLD}; font-size: 10px; font-weight: bold;")
        self.lbl_config_update.hide()
        self._config_update_fade = QTimer(self)
        self._config_update_fade.setSingleShot(True)
        self._config_update_fade.timeout.connect(self.lbl_config_update.hide)
        trace_group.add_widget(self.trace)
        trace_group.add_widget(self.lbl_config_update)

        right_stack.addWidget(trace_group)
        right_stack.addWidget(operations_group)
        right_stack.setStretchFactor(0, 1)
        right_stack.setStretchFactor(1, 1)
        right_stack.setSizes([200, 200])

        main_split.addWidget(chat_group)
        main_split.addWidget(right_stack)
        main_split.setStretchFactor(0, 3)
        main_split.setStretchFactor(1, 2)
        self._active_assistant_started = False
        self._active_assistant_token_count = 0

        self._sync_path_display()
        self._update_load_button_text()
        self._refresh_archive_list()
        self._apply_behavior_prompt(self.config.get("behavior_tags", []))
        self.behavior_tags.set_tags(self.config.get("behavior_tags", []))
        self._set_config_dirty(False)
        if not self._is_model_loaded:
            self._apply_default_limits()

    def send(self):
        txt = self.input.text().strip()
        if not txt:
            return
        self.sig_debug.emit(f"[CHAT] send: text={repr(txt[:60])}, msgs={len(self._current_session['messages'])}")
        self._set_send_button_state(is_running=True)
        self.input.clear()
        user_idx = self._add_message("user", txt)
        self._append_message_widget(user_idx)
        self._start_assistant_stream()
        self.message_list.scrollToBottom()
        self.sig_debug.emit(f"[CHAT] about to emit sig_generate: txt={repr(txt[:60])}")
        self.sig_generate.emit(txt, self._thinking_mode)
        self.sig_debug.emit(f"[CHAT] sig_generate emitted")

    def handle_send_click(self):
        txt = self.input.text().strip()

        if not self._is_running:
            self.send()
            return

        if not txt:
            self._set_send_button_state(is_running=True, stopping=True)
            self.sig_stop.emit()
            return

        self._pending_update_text = txt
        self._awaiting_update_restart = True
        self.btn_send.setEnabled(False)
        self._begin_update_trace(txt)
        self.sig_stop.emit()

    def _set_send_button_state(self, is_running: bool, stopping: bool = False):
        self._is_running = is_running
        if is_running:
            has_input = bool(self.input.text().strip())
            if has_input:
                self.btn_send.setText("UPDATE")
                color = ACCENT_GOLD
            else:
                self.btn_send.setText("■")
                color = FG_ERROR
            self.btn_send.setStyleSheet(
                self._btn_style_template.format(
                    bg=BG_INPUT,
                    color=color,
                )
            )
            self.btn_send.setEnabled(not stopping)
        else:
            self.btn_send.setText("SEND")
            self.btn_send.setStyleSheet(
                self._btn_style_template.format(
                    bg=BG_INPUT,
                    color=ACCENT_GOLD,
                )
            )
            self.btn_send.setEnabled(True)

    def _on_input_changed(self, text):
        if not self._is_running:
            return
        self._set_send_button_state(is_running=True)

    def _send_message(self, text):
        self.input.setText(text)
        self.send()

    def _submit_update(self, update_text):
        self._set_send_button_state(is_running=True)
        self._rewrite_assistant_index = self._active_assistant_index
        partial = "(no output yet)"
        if self._active_assistant_index is not None:
            txt = self._current_session["messages"][self._active_assistant_index]["text"]
            if txt:
                partial = txt

        original = ""
        for msg in reversed(self._current_session["messages"]):
            if msg["role"] == "user":
                original = msg["text"]
                break

        injected = f"""
You were interrupted mid-generation.

Original user request:
{original}

Partial assistant output so far:
{partial}

User update:
{update_text}

Continue from the interruption point. Do not repeat earlier content. Prioritize the user update.
"""

        self.input.clear()
        self._start_update_streaming()
        self.sig_generate.emit(injected, self._thinking_mode)

    def _start_assistant_stream(self):
        self.sig_debug.emit(f"[CHAT] _start_assistant_stream: msgs_before={len(self._current_session['messages'])}")
        self._active_assistant_started = True
        self._active_assistant_token_count = 0

        self._active_assistant_index = self._add_message("assistant", "")
        self._active_widget = self._append_message_widget(self._active_assistant_index)
    

    def _flush_tokens(self):
        if not self._token_buf:
            self._flush_timer.stop()
            return
        chunk = "".join(self._token_buf)
        self._token_buf.clear()
        if self._active_widget is None:
            target_index = self._rewrite_assistant_index
            if target_index is None:
                target_index = self._active_assistant_index
            if target_index is not None:
                self._active_widget = self._widget_for_index(target_index)
        if self._active_widget is None:
            return
        # Check if user is near the bottom before appending (so we don't yank them down)
        sb = self.message_list.verticalScrollBar()
        at_bottom = sb.value() >= sb.maximum() - 40

        self._active_widget.append_token(chunk)
        vw = self.message_list.viewport().width()
        for row in range(self.message_list.count()):
            item = self.message_list.item(row)
            widget = self.message_list.itemWidget(item)
            if widget is self._active_widget:
                if vw > 50:
                    widget.setFixedWidth(vw)
                item.setSizeHint(widget.sizeHint())
                break
        if at_bottom:
            self.message_list.scrollToBottom()

    def append_token(self, t):
        self._token_buf.append(t)
        self._append_assistant_token(t)
        self._update_progress_markers()
        if not self._flush_timer.isActive():
            self._flush_timer.start()

    def on_guard_finished(self, engine_key, task_id):
        if engine_key != getattr(self, "_engine_key", "llm"):
            return
        if not self._current_session.get("messages"):
            return
        try:
            self._save_chat_archive()
        except Exception:
            pass

    def append_trace(self, trace_msg):
        lowered = trace_msg.lower()

        # --- Filter: only show LLM-relevant trace info ---
        # Skip guard internals, status transitions, and noise
        skip_patterns = [
            "guard", "dispatch", "route", "bridge", "dock",
            "addon", "registry", "host", "mount",
        ]
        for pat in skip_patterns:
            if pat in lowered and "error" not in lowered:
                return

        # Categorize what we show
        if "system online" in lowered:
            self._is_model_loaded = True
        elif "model unloaded" in lowered:
            self._is_model_loaded = False

        if "error" in lowered:
            state = "ERROR"
        elif "token" in lowered:
            state = "TOKENIZING"
        elif "inference started" in lowered:
            state = "INFERENCE"
        elif "inference" in lowered and ("complete" in lowered or "aborted" in lowered):
            state = "COMPLETE"
        elif "init backend" in lowered or "system online" in lowered:
            state = "MODEL"
        elif "unload" in lowered or "cancel" in lowered:
            state = "MODEL"
        elif "ctx" in lowered or "context" in lowered:
            state = "CTX"
        else:
            state = "INFO"

        display_msg = trace_msg
        if "→" in display_msg:
            display_msg = display_msg[display_msg.index("→") + 1:].strip()
        elif display_msg.startswith("ERROR"):
            display_msg = display_msg.replace("ERROR:", "").strip()

        self._trace_html(display_msg, state, error=(state == "ERROR"))

    def clear_chat(self):
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)

    def _sync_path_display(self):
        gguf_path = self.config.get("gguf_path")
        if gguf_path:
            self.path_display.setText(gguf_path)
            self.path_display.setToolTip(str(gguf_path))
        else:
            self.path_display.clear()
            self.path_display.setToolTip("")

    def _set_config_dirty(self, dirty=True):
        self._config_dirty = dirty
        self.lbl_config_state.setText("UNSAVED" if dirty else "SAVED")
        self.lbl_config_state.setStyleSheet(
            f"color: {ACCENT_GOLD if dirty else FG_DIM}; font-size: 10px; font-weight: bold;"
        )
        # Save button: gold when dirty (action needed), gray when clean
        if dirty:
            self.btn_save_config.setStyleSheet(f"""
                QPushButton {{ background: #181818; border: 1px solid {ACCENT_GOLD}; color: {ACCENT_GOLD}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                QPushButton:hover {{ background: {ACCENT_GOLD}; color: black; }}
                QPushButton:pressed {{ background: #b08d2b; color: black; }}
            """)
        else:
            self.btn_save_config.setStyleSheet(f"""
                QPushButton {{ background: #181818; border: 1px solid #333; color: {FG_DIM}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                QPushButton:hover {{ background: #222; color: {FG_DIM}; }}
            """)

    def _save_config(self):
        save_config(self.config)
        self._last_config_update = QDateTime.currentDateTime()
        stamp = self._last_config_update.toString("HH:mm:ss")
        self.lbl_config_update.setText(f"USER (UPDATED): {stamp}")
        self.lbl_config_update.show()
        self._config_update_fade.start(2500)
        self._set_config_dirty(False)

    def _update_config_value(self, key, value):
        self.config[key] = value
        self._set_config_dirty(True)

    def _set_slider_limits(self, slider, max_value, value):
        qt_slider = slider.slider
        qt_slider.blockSignals(True)
        if slider.is_int:
            min_value = qt_slider.minimum()
            if max_value < min_value:
                min_value = max_value
            qt_slider.setRange(int(min_value), int(max_value))
            qt_slider.setValue(int(value))
            slider.val_lbl.setText(str(int(value)))
        else:
            min_value = qt_slider.minimum()
            max_scaled = int(max_value * 100)
            if max_scaled < min_value:
                min_value = max_scaled
            qt_slider.setRange(min_value, max_scaled)
            qt_slider.setValue(int(value * 100))
            slider.val_lbl.setText(f"{value:.2f}")
        qt_slider.blockSignals(False)

    def _apply_default_limits(self):
        self._set_slider_limits(
            self.s_ctx,
            DEFAULT_CONFIG["ctx_limit"],
            DEFAULT_CONFIG["ctx_limit"],
        )
        self._set_slider_limits(
            self.s_tok,
            DEFAULT_CONFIG["max_tokens"],
            DEFAULT_CONFIG["max_tokens"],
        )

    def _trace_html(self, msg, tag="INFO", error=False):
        arrow_color = FG_ERROR if error else ACCENT_GOLD
        tag_color = FG_ERROR if error else "#555"
        self.trace.append(
            f"<table width='100%' cellpadding='0' cellspacing='0'><tr>"
            f"<td><span style='color:{arrow_color}'>→</span> {msg}</td>"
            f"<td align='right' style='color:{tag_color}; white-space:nowrap'>[{tag}]</td>"
            f"</tr></table>"
        )

    def _trace_plain(self, msg):
        self.trace.append(f"<span style='color:#555'>{msg}</span>")

    def _on_model_capabilities(self, payload):
        model_ctx_length = payload.get("model_ctx_length")
        if model_ctx_length is None:
            self._apply_default_limits()
            return
        configured_ctx = int(self.config.get("ctx_limit", 8192))
        self._set_slider_limits(self.s_ctx, model_ctx_length, model_ctx_length)
        self._set_slider_limits(
            self.s_tok,
            model_ctx_length,
            min(8192, model_ctx_length),
        )
        # Surface context capacity info in reasoning trace
        if configured_ctx < model_ctx_length:
            pct = int((configured_ctx / model_ctx_length) * 100)
            self._trace_html(
                f"Context: {configured_ctx:,} / {model_ctx_length:,} tokens "
                f"({pct}% of model capacity)",
                "CTX",
            )
            self._trace_html(
                f"Increase context limit in SETTINGS to use full {model_ctx_length:,} capacity",
                "CTX",
            )
        else:
            self._trace_html(
                f"Context: {model_ctx_length:,} tokens (full capacity)",
                "CTX",
            )

    def _on_ctx_limit_changed(self, value):
        self._update_config_value("ctx_limit", int(value))
        self.sig_set_ctx_limit.emit(int(value))

    def _on_behavior_tags_changed(self, tags):
        self._apply_behavior_prompt(tags)

    def _on_thinking_mode_toggled(self, checked):
        self._thinking_mode = bool(checked)
        self.config["thinking_mode"] = self._thinking_mode
        self._set_config_dirty(True)
        self._update_thinking_button_style()

    def _set_thinking_mode(self, enabled, label="Off"):
        self._thinking_mode = enabled
        self.config["thinking_mode"] = enabled
        self._set_config_dirty(True)
        self._update_thinking_button_style()

    def _toggle_options_panel(self):
        self._options_expanded = not self._options_expanded
        self.options_panel.setVisible(self._options_expanded)
        self.btn_options_toggle.setText("▾ OPTIONS" if self._options_expanded else "▸ OPTIONS")

    def _update_thinking_button_style(self):
        # Update the think toggle buttons in the OPTIONS panel
        if hasattr(self, 'btn_think_off'):
            if self._thinking_mode:
                self.btn_think_std.setChecked(True)
            else:
                self.btn_think_off.setChecked(True)

    def _attach_file_placeholder(self):
        """Placeholder for file attachment — backend will be implemented later."""
        pass

    def _reset_config(self):
        """Reset all settings to DEFAULT_CONFIG values."""
        for key, val in DEFAULT_CONFIG.items():
            self.config[key] = val
        self.s_temp.slider.blockSignals(True)
        self.s_top.slider.blockSignals(True)
        self.s_tok.slider.blockSignals(True)
        self.s_ctx.slider.blockSignals(True)
        self.s_temp.slider.setValue(int(DEFAULT_CONFIG["temp"] * 100))
        self.s_temp.val_lbl.setText(f"{DEFAULT_CONFIG['temp']:.2f}")
        self.s_top.slider.setValue(int(DEFAULT_CONFIG["top_p"] * 100))
        self.s_top.val_lbl.setText(f"{DEFAULT_CONFIG['top_p']:.2f}")
        self.s_tok.slider.setValue(int(DEFAULT_CONFIG["max_tokens"]))
        self.s_tok.val_lbl.setText(str(int(DEFAULT_CONFIG["max_tokens"])))
        self.s_ctx.slider.setValue(int(DEFAULT_CONFIG["ctx_limit"]))
        self.s_ctx.val_lbl.setText(str(int(DEFAULT_CONFIG["ctx_limit"])))
        self.s_temp.slider.blockSignals(False)
        self.s_top.slider.blockSignals(False)
        self.s_tok.slider.blockSignals(False)
        self.s_ctx.slider.blockSignals(False)
        self.sig_set_ctx_limit.emit(int(DEFAULT_CONFIG["ctx_limit"]))
        self.behavior_tags.set_tags(DEFAULT_CONFIG.get("behavior_tags", []))
        self._set_thinking_mode(False)
        self._set_config_dirty(True)

    def pick_file(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select GGUF", "", "GGUF (*.gguf)")
        if path:
            self.config["gguf_path"] = path
            self.sig_set_model_path.emit(path)
            self._sync_path_display()
            self._set_config_dirty(True)

    def toggle_load(self):
        if self._is_model_loaded:
            self.sig_unload.emit()
        else:
            self.sig_load.emit()

    def _update_load_button_text(self):
        self.btn_load.setText("UNLOAD MODEL" if self._is_model_loaded else "LOAD MODEL")

    def _request_mutation(self, fn):
        """Run a session mutation safely.

        If a generation is currently running, STOP first, then run `fn` on the next READY.
        This prevents stale indices / widgets during streaming.
        """
        if self._is_running:
            # Cancel any queued UPDATE-restart; mutation wins.
            self._awaiting_update_restart = False
            self._pending_update_text = None
            self._pending_mutation = fn
            self._set_send_button_state(is_running=True, stopping=True)
            self.sig_stop.emit()
            return
        fn()

    def update_status(self, engine_key: str, status: SystemStatus):
        ek_short = engine_key[-8:] if engine_key else "?"
        prev = getattr(self, '_last_status', None)
        transition = f"{prev.name if prev else '?'}→{status.name}" if hasattr(status, 'name') else str(status)
        self.sig_debug.emit(f"[CHAT:{ek_short}] status {transition}, running={self._is_running}, mutation={'yes' if self._pending_mutation else 'no'}")
        if engine_key != getattr(self, "_engine_key", "llm"):
            return
        is_processing = status in (SystemStatus.LOADING, SystemStatus.RUNNING, SystemStatus.UNLOADING)
        self.btn_load.setEnabled(not is_processing)
        if is_processing:
            self.btn_load.setText("PROCESSING...")
        else:
            self._update_load_button_text()
        if status == SystemStatus.READY and self._pending_mutation is not None:
            # Finish transition to READY (stop state) first, then mutate.
            # Keep this path above UPDATE-restart.
            self._set_send_button_state(is_running=False)
            self._rewrite_assistant_index = None
            if self._active_widget is not None:
                self._active_widget.finalize()
            self._active_widget = None
            if self._update_trace_state == "streaming":
                self._finalize_update_progress()
            # If generation ended before any tokens arrived, remove the empty assistant bubble.
            self._cleanup_empty_assistant_if_needed()
            # Reset assistant stream trackers after end-of-generation.
            self._active_assistant_started = False
            self._active_assistant_token_count = 0
            self._suppress_title_regen = False
            pending = self._pending_mutation
            self._pending_mutation = None
            try:
                pending()
            finally:
                self._last_status = status
            return

        if status == SystemStatus.READY and self._awaiting_update_restart:
            self._awaiting_update_restart = False
            self.btn_send.setEnabled(True)

            update_text = self._pending_update_text
            self._pending_update_text = None
            self._submit_update(update_text)
            return
        if status == SystemStatus.RUNNING:
            self._set_send_button_state(is_running=True)
        elif status == SystemStatus.READY:
            if self._last_status == SystemStatus.LOADING:
                self._is_model_loaded = True
                self._update_load_button_text()
            elif self._last_status == SystemStatus.UNLOADING:
                self._is_model_loaded = False
                self._update_load_button_text()
            self._set_send_button_state(is_running=False)
            self._rewrite_assistant_index = None
            if self._active_widget is not None:
                self._active_widget.finalize()
            self._active_widget = None
            if self._update_trace_state == "streaming":
                self._finalize_update_progress()
            # If generation ended before any tokens arrived, remove the empty assistant bubble.
            self._cleanup_empty_assistant_if_needed()
            # Reset assistant stream trackers after end-of-generation.
            self._active_assistant_started = False
            self._active_assistant_token_count = 0
            # Title generation is finalized ONLY on READY.

            # READY is emitted after _on_gen_finish completes and assistant text is final.
            # STOP also transitions to READY; _maybe_generate_title self-guards.
            # Do NOT call this method from token flush, send paths, or mutation handlers.
            if self._pending_mutation is None:
                self._maybe_generate_title()
            self._suppress_title_regen = False
        elif status == SystemStatus.LOADING:
            self._set_send_button_state(is_running=False)
            self.btn_send.setEnabled(False)
        elif status in (SystemStatus.UNLOADING, SystemStatus.ERROR):
            self._is_model_loaded = False
            if not is_processing:
                self._update_load_button_text()

        if status == SystemStatus.READY and not self._is_model_loaded:
            self._apply_default_limits()
        self._last_status = status

    def _switch_ops_tab(self, index, checked):
        if checked:
            self.ops_stack.setCurrentIndex(index)


    def apply_operator(self, operator_data: dict):
        if not isinstance(operator_data, dict):
            return
        config = operator_data.get("config")
        if not isinstance(config, dict):
            return

        slider_values = {
            "temp": float(config.get("temp", self.config.get("temp", 0.7))),
            "top_p": float(config.get("top_p", self.config.get("top_p", 0.9))),
            "max_tokens": int(config.get("max_tokens", self.config.get("max_tokens", 2048))),
            "ctx_limit": int(config.get("ctx_limit", self.config.get("ctx_limit", 8192))),
        }

        self.config.update(config)

        self.s_temp.slider.blockSignals(True)
        self.s_top.slider.blockSignals(True)
        self.s_tok.slider.blockSignals(True)
        self.s_ctx.slider.blockSignals(True)
        self.s_temp.slider.setValue(int(slider_values["temp"] * 100))
        self.s_temp.val_lbl.setText(f"{slider_values['temp']:.2f}")
        self.s_top.slider.setValue(int(slider_values["top_p"] * 100))
        self.s_top.val_lbl.setText(f"{slider_values['top_p']:.2f}")
        self.s_tok.slider.setValue(int(slider_values["max_tokens"]))
        self.s_tok.val_lbl.setText(str(int(slider_values["max_tokens"])))
        self.s_ctx.slider.setValue(int(slider_values["ctx_limit"]))
        self.s_ctx.val_lbl.setText(str(int(slider_values["ctx_limit"])))
        self.s_temp.slider.blockSignals(False)
        self.s_top.slider.blockSignals(False)
        self.s_tok.slider.blockSignals(False)
        self.s_ctx.slider.blockSignals(False)

        self.sig_set_ctx_limit.emit(int(slider_values["ctx_limit"]))

        tags = config.get("behavior_tags", [])
        self.behavior_tags.set_tags(tags if isinstance(tags, list) else [])

        thinking_mode = bool(config.get("thinking_mode", False))
        self._set_thinking_mode(thinking_mode, "Standard" if thinking_mode else "Off")

        gguf_path = config.get("gguf_path")
        if gguf_path:
            self.config["gguf_path"] = gguf_path
            self.sig_set_model_path.emit(str(gguf_path))
        self._sync_path_display()

        # Restore chat messages if snapshot included them, otherwise fresh session
        messages = operator_data.get("messages")
        if isinstance(messages, list) and messages:
            session = self._create_session(
                messages=messages,
                title=operator_data.get("session_title"),
                assistant_tokens=operator_data.get("assistant_tokens", 0),
            )
            self._set_current_session(session, show_reset=True, sync_history=True)
        else:
            self._start_new_session()

        self._set_config_dirty(True)
        self.sig_operator_loaded.emit(str(operator_data.get("name", "")))

    def _start_new_session(self):
        self._title_generated = False
        self._suppress_title_regen = False
        self.trace.clear()
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._trace_plain("--- TRACE RESET ---")

    def _prompt_clear_session(self):
        dialog = QMessageBox(self)
        dialog.setWindowTitle("Clear Session")
        dialog.setText("Choose how to clear the current session.")
        dialog.setStyleSheet(f"""
            QMessageBox {{
                background: {BG_INPUT};
                color: {FG_TEXT};
            }}
            QLabel {{
                color: {FG_TEXT};
            }}
            QPushButton {{
                color: {FG_TEXT};
                background: transparent;
                border: 1px solid #333;
                padding: 6px 12px;
                font-size: 10px;
                font-weight: bold;
                border-radius: 2px;
            }}
            QPushButton:hover {{
                border: 1px solid {ACCENT_GOLD};
                color: {ACCENT_GOLD};
            }}
            QPushButton:checked {{
                border: 1px solid {ACCENT_GOLD};
                color: {ACCENT_GOLD};
            }}
        """)
        btn_clear = dialog.addButton("Clear Logs", QMessageBox.AcceptRole)
        btn_delete = dialog.addButton("Delete Chat", QMessageBox.DestructiveRole)
        dialog.addButton("Cancel", QMessageBox.RejectRole)
        dialog.exec()
        clicked = dialog.clickedButton()
        if clicked == btn_clear:
            self._clear_current_session(delete_archive=False)
        elif clicked == btn_delete:
            self._clear_current_session(delete_archive=True)

    def _clear_current_session(self, delete_archive):
        archive_path = self._current_session.get("archive_path")
        if delete_archive and archive_path:
            try:
                Path(archive_path).unlink()
            except OSError:
                pass
        self.trace.clear()
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._refresh_archive_list()

    def _delete_selected_archive(self):
        item = self.archive_list.currentItem()
        if not item:
            return
        archive_path = Path(item.data(Qt.UserRole))
        try:
            archive_path.unlink()
        except OSError:
            return
        if self._current_session.get("archive_path") == str(archive_path):
            self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._refresh_archive_list()

    def _save_chat_archive(self):
        session = self._current_session
        messages = session["messages"]
        now = self._now_iso()
        created_at = session.get("created_at") or now
        updated_at = now
        title = self._current_session.get("title") or self._derive_title(messages)
        summary = self._build_summary(messages)
        message_payload = []
        for idx, msg in enumerate(messages, start=1):
            message_payload.append({
                "i": idx,
                "time": msg.get("time") or now,
                "role": msg.get("role", "user"),
                "text": msg.get("text", "")
            })
        meta = {
            "title": title,
            "created_at": created_at,
            "updated_at": updated_at,
            "message_count": len(message_payload),
            "assistant_tokens": int(session.get("assistant_tokens", 0)),
            "summary": summary
        }
        payload = {"meta": meta, "messages": message_payload}
        archive_path = session.get("archive_path")
        if not archive_path:
            slug = self._slugify(title)
            stamp = now.replace(":", "-").replace(".", "-")
            archive_path = self._archive_dir / f"{slug}_{stamp}.json"
        else:
            archive_path = Path(archive_path)
        archive_path.parent.mkdir(parents=True, exist_ok=True)
        with archive_path.open("w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2)
        session["archive_path"] = str(archive_path)
        session["created_at"] = created_at
        session["updated_at"] = updated_at
        session["summary"] = summary
        self._refresh_archive_list()

    def _load_chat_archive(self):
        item = self.archive_list.currentItem()
        if not item:
            return
        archive_path = Path(item.data(Qt.UserRole))
        try:
            with archive_path.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
        except Exception:
            QMessageBox.warning(self, "Load Failed", "Could not read archive file.")
            return
        meta = data.get("meta", {})
        messages = []
        for msg in data.get("messages", []):
            role = msg.get("role", "user")
            text = msg.get("text", "")
            time = msg.get("time", meta.get("updated_at", self._now_iso()))
            messages.append({"i": msg.get("i"), "time": time, "role": role, "text": text})
        session = self._create_session(
            messages=messages,
            created_at=meta.get("created_at"),
            updated_at=meta.get("updated_at"),
            archive_path=str(archive_path),
            summary=meta.get("summary", []),
            title=meta.get("title"),
            assistant_tokens=int(meta.get("assistant_tokens", meta.get("token_count", 0)))
        )
        self._set_current_session(session, show_reset=False, sync_history=True)
        self._notify_header_update()

    def _refresh_archive_list(self):
        self.archive_list.clear()
        items = []
        for path in sorted(self._archive_dir.glob("*.json")):
            try:
                with path.open("r", encoding="utf-8") as handle:
                    data = json.load(handle)
            except Exception:
                continue
            meta = data.get("meta", {})
            title = meta.get("title", path.stem)
            summary = meta.get("summary", [])
            tooltip = "\n".join(summary) if summary else title
            updated_at = meta.get("updated_at", "")
            message_count = meta.get("message_count", len(data.get("messages", [])))
            assistant_tokens = int(meta.get("assistant_tokens", meta.get("token_count", 0)))
            items.append((updated_at, title, message_count, assistant_tokens, str(path), tooltip))
        items.sort(key=lambda item: item[0], reverse=True)
        for updated_at, title, message_count, assistant_tokens, path, tooltip in items:
            date_label = updated_at.split("T")[0] if updated_at else "Unknown date"
            subtext = f"{date_label} • {message_count} msgs • {assistant_tokens} assistant tokens"
            list_item = QListWidgetItem(f"{title}\n{subtext}")
            list_item.setData(Qt.UserRole, path)
            list_item.setToolTip(tooltip)
            self.archive_list.addItem(list_item)

    def _create_session(self, messages=None, created_at=None, updated_at=None, archive_path=None, summary=None, title=None, assistant_tokens=0):
        self._session_counter += 1
        now = self._now_iso()
        return {
            "id": self._session_counter,
            "created_at": created_at or now,
            "updated_at": updated_at or now,
            "messages": messages or [],
            "archive_path": archive_path,
            "summary": summary or [],
            "title": title,
            "assistant_tokens": int(assistant_tokens),
        }

    def _set_current_session(self, session, show_reset=False, sync_history=False):
        self._current_session = session
        self._undo_snapshot = None
        self._active_assistant_index = None
        self._rewrite_assistant_index = None
        self._active_widget = None
        self._title_generated = bool(session.get("title"))
        self._suppress_title_regen = False
        self._render_session(session, show_reset=show_reset)
        if sync_history:
            history = self._build_engine_history_from_session()
            self.sig_sync_history.emit(history)
        self._notify_header_update()

    def _build_engine_history_from_session(self):
        """
        Convert _current_session["messages"] into engine-ready history.

        Always include:
          {"role": "system", "content": MASTER_PROMPT}

        Then append each session message as:
          {"role": msg["role"], "content": msg["text"]}

        Behavior tags are NOT included here.
        Engine recompiles system prompt at generation time.
        """
        history = [{"role": "system", "content": MASTER_PROMPT}]
        for msg in self._current_session.get("messages", []):
            if not isinstance(msg, dict):
                continue
            role = msg.get("role")
            text = msg.get("text")
            if not isinstance(role, str) or not isinstance(text, str):
                continue
            history.append({"role": role, "content": text})
        return history

    def _snapshot_session(self):
        self._undo_snapshot = [dict(m) for m in self._current_session["messages"]]

    def _undo_last_mutation(self):
        if not self._undo_snapshot:
            return
        self._current_session["messages"] = self._undo_snapshot
        self._undo_snapshot = None
        self._render_session()
        self.sig_sync_history.emit(
            self._build_engine_history_from_session()
        )

    def _delete_from_index(self, idx: int):
        self.sig_debug.emit(f"[CHAT] _delete_from_index: idx={idx}, msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_delete():
            self._snapshot_session()
            msgs = self._current_session["messages"]
            if idx < 0 or idx >= len(msgs):
                return
            del msgs[idx:]
            # Reset any stale streaming pointers.
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )

        self._request_mutation(_do_delete)

    def _edit_from_index(self, idx: int):
        self.sig_debug.emit(f"[CHAT] _edit_from_index: idx={idx}, msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_edit():
            msgs = self._current_session["messages"]
            if idx < 0 or idx >= len(msgs):
                return
            text = msgs[idx].get("text", "")
            self._suppress_title_regen = True
            # Inline delete to avoid nested mutation requests.
            self._snapshot_session()
            del msgs[idx:]
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )
            self.input.setText(text)

        self._request_mutation(_do_edit)

    def _regen_last_assistant(self):
        self.sig_debug.emit(f"[CHAT] _regen_last_assistant: msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_regen():
            msgs = self._current_session["messages"]
            if not msgs or msgs[-1].get("role") != "assistant":
                return
            self._snapshot_session()
            self._suppress_title_regen = True
            del msgs[-1]
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )

            for m in reversed(msgs):
                if m.get("role") == "user":
                    self._set_send_button_state(is_running=True)
                    self._start_assistant_stream()
                    self.message_list.scrollToBottom()
                    self.sig_generate.emit(m.get("text", ""), self._thinking_mode)
                    break

        self._request_mutation(_do_regen)

    def _render_session(self, session=None, show_reset=False):
        if session is None:
            session = self._current_session
        self.sig_debug.emit(f"[CHAT] _render_session: msgs={len(session['messages'])}, show_reset={show_reset}")
        self.message_list.clear()
        self._active_widget = None
        if not session["messages"]:
            return
        for idx, _msg in enumerate(session["messages"]):
            self._append_message_widget(idx)
        self.message_list.scrollToBottom()

    def _append_message_widget(self, idx: int, role=None, text=None, timestamp=None):
        if idx >= 0:
            msg = self._current_session["messages"][idx]
            role = msg.get("role", "")
            text = msg.get("text", "")
            timestamp = msg.get("time", "")
        item = QListWidgetItem()
        widget = MessageWidget(idx, role or "", text or "", timestamp or "")
        widget.sig_delete.connect(self._delete_from_index)
        widget.sig_edit.connect(self._edit_from_index)
        widget.sig_regen.connect(lambda _idx: self._regen_last_assistant())
        vw = self.message_list.viewport().width()
        if vw > 50:
            widget.setFixedWidth(vw)
        item.setSizeHint(widget.sizeHint())
        self.message_list.addItem(item)
        self.message_list.setItemWidget(item, widget)
        return widget

    def _widget_for_index(self, idx: int):
        for row in range(self.message_list.count()):
            item = self.message_list.item(row)
            widget = self.message_list.itemWidget(item)
            if isinstance(widget, MessageWidget) and getattr(widget, "_index", None) == idx:
                return widget
        return None

    def _apply_behavior_prompt(self, tags):
        cleaned = [tag.strip() for tag in tags if tag.strip()]
        self.config["behavior_tags"] = cleaned
        self._set_config_dirty(True)

    def _begin_update_trace(self, update_text):
        self._update_trace_state = "requested"
        self._update_token_count = 0
        self._update_progress_index = 0
        self._trace_html("UPDATE REQUESTED", "UPDATE")
        self._trace_html(f'USER PATCH: "{update_text}"', "UPDATE")

    def _start_update_streaming(self):
        self._update_trace_state = "streaming"
        self._update_token_count = 0
        self._update_progress_index = 0

    def _update_progress_markers(self):
        if self._update_trace_state != "streaming":
            return
        self._update_token_count += 1
        thresholds = [25, 50, 100]
        pct = min(
            100,
            int((self._update_token_count / self.config["max_tokens"]) * 100),
        )
        while self._update_progress_index < len(thresholds):
            if pct >= thresholds[self._update_progress_index]:
                percent = thresholds[self._update_progress_index]
                self._trace_html(f"UPDATE PROGRESS {percent}%", "UPDATE")
                self._update_progress_index += 1
                continue
            break

    def _finalize_update_progress(self):
        if self._update_trace_state != "streaming":
            return
        thresholds = [25, 50, 100]
        while self._update_progress_index < len(thresholds):
            percent = thresholds[self._update_progress_index]
            self._trace_html(f"UPDATE PROGRESS {percent}%", "UPDATE")
            self._update_progress_index += 1
        self._update_trace_state = None

    def _add_message(self, role, text):
        now = self._now_iso()
        message = {
            "i": len(self._current_session["messages"]) + 1,
            "time": now,
            "role": role,
            "text": text
        }
        self._current_session["messages"].append(message)
        self._current_session["updated_at"] = now
        return len(self._current_session["messages"]) - 1

    def _append_assistant_token(self, token):
        target_index = self._rewrite_assistant_index
        if target_index is None:
            target_index = self._active_assistant_index
        if target_index is None:
            return

        msg = self._current_session["messages"][target_index]
        msg["text"] += token
        self._active_assistant_token_count += 1
        msg["time"] = self._now_iso()
        self._current_session["updated_at"] = msg["time"]
        self._current_session["assistant_tokens"] = int(self._current_session.get("assistant_tokens", 0)) + 1


    def _cleanup_empty_assistant_if_needed(self):
        """Remove a placeholder assistant message if generation ended before any tokens arrived."""
        idx = self._active_assistant_index
        if idx is None:
            return
        if not getattr(self, "_active_assistant_started", False):
            return
        if int(getattr(self, "_active_assistant_token_count", 0)) > 0:
            return

        msgs = self._current_session.get("messages", [])
        if 0 <= idx < len(msgs):
            msg = msgs[idx]
            if msg.get("role") == "assistant" and (msg.get("text") or "") == "":
                del msgs[idx]
                # After deletion, any stored indices are stale.
                self._active_assistant_index = None
                self._rewrite_assistant_index = None
                self._active_widget = None
                self._token_buf.clear()
                if self._flush_timer.isActive():
                    self._flush_timer.stop()
                self._render_session()
                self.sig_sync_history.emit(self._build_engine_history_from_session())
                return
    def _maybe_generate_title(self):
        if self._suppress_title_regen:
            return
        if self._title_generated:
            return
        if self._current_session.get("title"):
            self._title_generated = True
            return
        if not any(m.get("role") == "user" and m.get("text", "").strip() for m in self._current_session["messages"]):
            return
        title = self._derive_title(self._current_session["messages"])
        self._current_session["title"] = title
        self._title_generated = True
        self._notify_header_update()

    def _topic_dominant(self):
        user_text = " ".join([m.get("text", "") for m in self._current_session["messages"] if m.get("role") == "user"])
        words = [w.lower() for w in re.findall(r"[a-zA-Z]{4,}", user_text)]
        if not words:
            return False
        counts = {}
        for word in words:
            counts[word] = counts.get(word, 0) + 1
        return max(counts.values()) >= 3

    def _notify_header_update(self):
        dt = QDateTime.currentDateTime().toString("ddd • HH:mm")
        title = self._current_session.get("title") or self._derive_title(self._current_session.get("messages", []))
        self.ui_bridge.sig_terminal_header.emit(getattr(self, "_mod_id", ""), title, dt)

    def _derive_title(self, messages):
        stopwords = {
            "a", "an", "and", "are", "as", "at", "be", "but", "by", "for", "from",
            "how", "i", "if", "in", "into", "is", "it", "me", "my", "of", "on", "or",
            "our", "please", "so", "that", "the", "their", "them", "then", "there", "these",
            "this", "to", "us", "we", "what", "when", "where", "which", "who", "why", "with",
            "you", "your",
        }
        user_texts = []
        for msg in messages:
            if msg.get("role") != "user":
                continue
            text = " ".join((msg.get("text") or "").lower().split())
            if text:
                user_texts.append(text)
            if len(user_texts) == 3:
                break

        if not user_texts:
            return "chat"

        candidates = []
        counts = {}
        for text in user_texts:
            for token in re.findall(r"[a-z0-9]+", text):
                if token in stopwords or len(token) < 3:
                    continue
                if token not in counts:
                    candidates.append(token)
                    counts[token] = 0
                counts[token] += 1

        ranked = sorted(candidates, key=lambda token: (-counts[token], candidates.index(token)))
        title_tokens = ranked[:6]
        title = " ".join(title_tokens)
        title = re.sub(r"\s+", " ", title).strip()
        title = re.sub(r"[^a-z0-9\- ]+", "", title)
        if len(title) > 40:
            title = title[:40].rstrip()
        return title or "chat"

    def _build_summary(self, messages):
        summary = []
        title = self._current_session.get("title") or self._derive_title(messages)
        summary.append(f"Title: {title}")
        user_msgs = [m["text"] for m in messages if m.get("role") == "user" and m.get("text")]
        assistant_msgs = [m["text"] for m in messages if m.get("role") == "assistant" and m.get("text")]

        def _trim(text, limit=120):
            return text if len(text) <= limit else f"{text[:limit]}…"

        for msg in user_msgs[-3:]:
            summary.append(f"User: {_trim(msg)}")
        for msg in assistant_msgs[-3:]:
            summary.append(f"Assistant: {_trim(msg)}")
        if len(summary) < 3:
            summary.append(f"Messages: {len(messages)}")
        if len(summary) < 3:
            summary.append("Summary: Not enough messages yet.")
        return summary[:6]

    def _slugify(self, text):
        slug = re.sub(r"[^a-z0-9]+", "-", text.lower()).strip("-")
        return slug or "chat"

    def _now_iso(self):
        return datetime.now(timezone.utc).isoformat()

    def _get_archive_dir(self):
        return ARCHIVE_DIR


================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\pages\databank.py
================================================================================

import os
import shutil
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, 
    QTreeView, QHeaderView, QFileSystemModel, QInputDialog, 
    QLabel, QMessageBox, QMenu
)
from PySide6.QtCore import QDir, Qt
from PySide6.QtGui import QAction

from ui.components.atoms import SkeetGroupBox, SkeetButton
from core.style import BG_INPUT, BORDER_DARK, FG_DIM, ACCENT_GOLD, BG_MAIN, FG_TEXT

class TerminalFileTree(QTreeView):
    def __init__(self, start_path):
        super().__init__()
        self.model = QFileSystemModel()
        
        self.model.setReadOnly(False)
        self.model.setFilter(QDir.AllEntries | QDir.NoDotAndDotDot)
        self.model.setNameFilterDisables(False)
        
        self.change_root(start_path)
        self.setModel(self.model)

        self.setDragEnabled(True) 
        self.setDragDropMode(QTreeView.DragOnly)

        self.setStyleSheet(f"""
            QTreeView {{
                background: {BG_INPUT};
                color: #ccc;
                border: 1px solid {BORDER_DARK};
                font-family: 'Consolas', monospace;
                font-size: 12px;
                outline: 0;
            }}
            QTreeView::item {{ padding: 4px; }}
            QTreeView::item:hover {{ background: #222; }}
            QTreeView::item:selected {{ background: {ACCENT_GOLD}; color: black; }}
            
            QHeaderView::section {{
                background: #111;
                color: {FG_DIM};
                border: none;
                padding: 4px;
                font-weight: bold;
            }}
        """)
        
        self.header().setSectionResizeMode(0, QHeaderView.Stretch)
        self.setColumnWidth(1, 80)
        self.setColumnHidden(2, True) 
        self.setColumnHidden(3, True) 
        self.setAnimated(False)
        self.setIndentation(20)
        self.setSortingEnabled(False)
        self.setContextMenuPolicy(Qt.CustomContextMenu)

    def change_root(self, path):
        abs_path = os.path.abspath(path)
        if not os.path.exists(abs_path):
            try:
                os.makedirs(abs_path)
            except OSError:
                pass 
                
        self.model.setRootPath(abs_path)
        self.setRootIndex(self.model.index(abs_path))

class PageFiles(QWidget):
    def __init__(self, state):
        super().__init__()
        self.state = state
        
        base_dir = "C:\\Models\\knowledge_base"
        if not os.path.exists("C:\\Models"):
            base_dir = os.path.join(os.getcwd(), "knowledge_base")
            
        self.current_path = base_dir
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        
        grp = SkeetGroupBox("DATABANK")
        gl = QVBoxLayout()
        gl.setSpacing(10)
        
        # --- TOP EXPLORER BAR ---
        nav_bar = QHBoxLayout()
        
        self.inp_path = QLineEdit()
        self.inp_path.setText(self.current_path)
        self.inp_path.setPlaceholderText("Path...")
        self.inp_path.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {ACCENT_GOLD}; 
                border: 1px solid #333; padding: 6px; font-family: 'Consolas';
            }}
        """)
        self.inp_path.returnPressed.connect(self.navigate_to_path)
        
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText("Search files...")
        self.inp_search.setFixedWidth(200)
        self.inp_search.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: white; 
                border: 1px solid #333; padding: 6px;
            }}
        """)
        self.inp_search.textChanged.connect(self.on_search)
        
        nav_bar.addWidget(QLabel("📂"))
        nav_bar.addWidget(self.inp_path)
        nav_bar.addSpacing(10)
        nav_bar.addWidget(QLabel("🔍"))
        nav_bar.addWidget(self.inp_search)
        gl.addLayout(nav_bar)
        
        # --- FILE TREE ---
        self.tree = TerminalFileTree(self.current_path)
        self.tree.customContextMenuRequested.connect(self.open_menu)
        self.tree.clicked.connect(self.on_click_item) 
        gl.addWidget(self.tree)
        
        # --- BOTTOM ACTION BAR ---
        actions = QHBoxLayout()
        
        btn_add = SkeetButton("+ MKDIR")
        btn_add.clicked.connect(self.new_folder)
        
        btn_del = SkeetButton("× DELETE")
        btn_del.clicked.connect(self.delete_item)
        
        btn_ref = SkeetButton("⟳ REFRESH")
        btn_ref.clicked.connect(self.refresh)
        
        self.lbl_status = QLabel("Ready")
        self.lbl_status.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        
        actions.addWidget(btn_add)
        actions.addWidget(btn_del)
        actions.addWidget(btn_ref)
        actions.addStretch()
        actions.addWidget(self.lbl_status)
        
        gl.addLayout(actions)
        grp.add_layout(gl)
        layout.addWidget(grp)

    def navigate_to_path(self):
        new_path = self.inp_path.text()
        if os.path.exists(new_path):
            self.current_path = new_path
            self.tree.change_root(new_path)
            self.lbl_status.setText(f"Navigated to: {new_path}")
        else:
            self.lbl_status.setText("Error: Path does not exist")

    def on_click_item(self, index):
        path = self.tree.model.filePath(index)
        if os.path.isdir(path):
            self.inp_path.setText(path)

    def refresh(self):
        self.tree.change_root(self.current_path)
        self.lbl_status.setText("Refreshed")

    def on_search(self, text):
        if text:
            self.tree.model.setNameFilters([f"*{text}*"])
        else:
            self.tree.model.setNameFilters([])

    def get_selected_path(self):
        indexes = self.tree.selectedIndexes()
        if indexes:
            return self.tree.model.filePath(indexes[0])
        return self.current_path

    def new_folder(self):
        target_path = self.get_selected_path()
        if os.path.isfile(target_path):
            target_path = os.path.dirname(target_path)
            
        name, ok = self.ask_input("New Folder", "Folder Name:")
        if ok and name:
            new_dir = os.path.join(target_path, name)
            try:
                os.makedirs(new_dir, exist_ok=True)
                self.lbl_status.setText(f"Created: {name}")
            except Exception as e:
                self.lbl_status.setText(f"Error: {e}")

    def delete_item(self):
        target = self.get_selected_path()
        if target == self.current_path:
            self.lbl_status.setText("Cannot delete root folder")
            return
            
        if os.path.exists(target):
            msg = QMessageBox(self)
            msg.setWindowTitle("Confirm Delete")
            msg.setText(f"Are you sure you want to delete:\\n{os.path.basename(target)}?")
            msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            msg.setStyleSheet(f"""
                QMessageBox {{ background: {BG_MAIN}; }}
                QLabel {{ color: {FG_TEXT}; }}
                QPushButton {{ background: #222; color: #ccc; border: 1px solid #444; padding: 5px; }}
            """)
            if msg.exec() == QMessageBox.Yes:
                try:
                    if os.path.isdir(target):
                        shutil.rmtree(target)
                    else:
                        os.remove(target)
                    self.lbl_status.setText("Item deleted")
                except Exception as e:
                    self.lbl_status.setText(f"Delete Error: {e}")

    def open_menu(self, position):
        menu = QMenu()
        menu.setStyleSheet(f"""
            QMenu {{ background: #111; color: {FG_TEXT}; border: 1px solid {ACCENT_GOLD}; }}
            QMenu::item:selected {{ background: {ACCENT_GOLD}; color: black; }}
        """)
        
        act_del = QAction("Delete", self)
        act_del.triggered.connect(self.delete_item)
        
        act_new = QAction("New Folder", self)
        act_new.triggered.connect(self.new_folder)
        
        menu.addAction(act_new)
        menu.addAction(act_del)
        menu.exec(self.tree.viewport().mapToGlobal(position))

    def ask_input(self, title, label):
        dlg = QInputDialog(self)
        dlg.setWindowTitle(title)
        dlg.setLabelText(label)
        dlg.setStyleSheet(f"""
            QDialog {{ background: {BG_MAIN}; border: 1px solid {ACCENT_GOLD}; }}
            QLabel {{ color: {FG_TEXT}; }}
            QLineEdit {{ background: {BG_INPUT}; color: white; border: 1px solid #333; }}
            QPushButton {{ background: #222; color: #ccc; border: 1px solid #444; padding: 5px; }}
        """)
        ok = dlg.exec()
        return dlg.textValue(), (ok == 1)



================================================================================
FILE: .\.claude\worktrees\gallant-allen\ui\pages\hub.py
================================================================================

from PySide6.QtCore import Signal, Qt
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QLabel,
    QGridLayout,
    QFrame,
    QPushButton,
    QHBoxLayout,
    QDialog,
    QLineEdit,
    QMessageBox,
    QComboBox,
)

from core.operators import OperatorManager
from core.style import (
    BG_GROUP, BG_INPUT, BG_MAIN, BG_BUTTON_HOVER, FG_TEXT, FG_DIM, FG_INFO,
    FG_PLACEHOLDER, ACCENT_GOLD, BORDER_DARK, BORDER_LIGHT, BORDER_SUBTLE,
    GLASS_BG, GLASS_BORDER, GLASS_HOVER,
)
from core.themes import list_themes, current_theme, apply_theme
from core.theme_config import save_theme_config
from ui.components.atoms import SkeetButton


class _NameDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("New Operator")
        self.setModal(True)
        self.setStyleSheet(f"""
            QDialog {{ background: {BG_INPUT}; color: {FG_TEXT}; }}
            QLineEdit {{ background: #101010; color: {FG_TEXT}; border: 1px solid #333; padding: 6px; }}
            QPushButton {{ color: {FG_TEXT}; background: transparent; border: 1px solid #333; padding: 6px 12px; }}
            QPushButton:hover {{ border: 1px solid {ACCENT_GOLD}; color: {ACCENT_GOLD}; }}
        """)
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Operator name:"))
        self.input = QLineEdit()
        layout.addWidget(self.input)
        row = QHBoxLayout()
        row.addStretch()
        ok_btn = SkeetButton("OK")
        cancel_btn = SkeetButton("CANCEL")
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)
        row.addWidget(ok_btn)
        row.addWidget(cancel_btn)
        layout.addLayout(row)

    def value(self) -> str:
        return self.input.text().strip()

class _OperatorCard(QPushButton):
    """Glassmorphic operator card with structured info."""
    sig_double_clicked = Signal(str)

    def __init__(self, name: str, gguf_path: str, tag_count: int, module_count: int = 0):
        super().__init__()
        self.op_name = name
        self.setCursor(Qt.PointingHandCursor)
        self.setMinimumHeight(80)
        self.setMinimumWidth(180)
        self._selected = False

        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 10, 12, 10)
        layout.setSpacing(4)

        lbl_name = QLabel(name.upper())
        lbl_name.setStyleSheet(f"color: {FG_TEXT}; font-size: 11px; font-weight: bold; background: transparent; letter-spacing: 1px;")
        layout.addWidget(lbl_name)

        lbl_model = QLabel(gguf_path)
        lbl_model.setStyleSheet(f"color: {FG_DIM}; font-size: 9px; background: transparent;")
        lbl_model.setWordWrap(True)
        layout.addWidget(lbl_model)

        info_parts = []
        if module_count > 0:
            info_parts.append(f"{module_count} module{'s' if module_count != 1 else ''}")
        if tag_count > 0:
            info_parts.append(f"{tag_count} tag{'s' if tag_count != 1 else ''}")
        lbl_info = QLabel(" · ".join(info_parts) if info_parts else "empty")
        lbl_info.setStyleSheet(f"color: #444; font-size: 9px; background: transparent;")
        layout.addWidget(lbl_info)

        layout.addStretch()
        self._apply_style(False)

    def _apply_style(self, selected: bool):
        self._selected = selected
        border = ACCENT_GOLD if selected else BORDER_DARK
        bg = "#1a1a1a" if selected else BG_INPUT
        self.setStyleSheet(f"""
            _OperatorCard {{
                background: {bg};
                border: 1px solid {border};
                border-radius: 3px;
            }}
            _OperatorCard:hover {{
                border: 1px solid {ACCENT_GOLD};
                background: #141414;
            }}
        """)

    def set_selected(self, selected: bool):
        self._apply_style(selected)

    def mouseDoubleClickEvent(self, event):
        self.sig_double_clicked.emit(self.op_name)


class PageHub(QWidget):
    sig_load_operator = Signal(str)
    sig_save_operator = Signal(str, dict)

    def __init__(self, config_provider=None, operator_manager: OperatorManager | None = None, ui_bridge=None):
        super().__init__()
        self._operator_manager = operator_manager or OperatorManager()
        self._config_provider = config_provider
        self._ui_bridge = ui_bridge
        self._selected_name: str | None = None
        self._cards: dict[str, _OperatorCard] = {}

        self.setStyleSheet(f"background: {BG_MAIN};")

        layout = QVBoxLayout(self)
        layout.setContentsMargins(30, 30, 30, 30)
        layout.setSpacing(0)

        # --- Welcome header ---
        header = QWidget()
        header.setStyleSheet("background: transparent;")
        header_layout = QVBoxLayout(header)
        header_layout.setContentsMargins(0, 0, 0, 20)
        header_layout.setSpacing(4)

        lbl_welcome = QLabel("MONOLITH")
        lbl_welcome.setStyleSheet(
            f"color: {ACCENT_GOLD}; font-size: 20px; font-weight: bold; "
            f"letter-spacing: 4px; background: transparent;"
        )
        header_layout.addWidget(lbl_welcome)

        lbl_sub = QLabel("Select an operator to restore your workspace, or create a new one.")
        lbl_sub.setStyleSheet(f"color: {FG_DIM}; font-size: 10px; background: transparent;")
        header_layout.addWidget(lbl_sub)

        layout.addWidget(header)

        # --- Separator ---
        sep = QFrame()
        sep.setFixedHeight(1)
        sep.setStyleSheet(f"background: {BORDER_DARK};")
        layout.addWidget(sep)
        layout.addSpacing(16)

        # --- Operator label ---
        ops_header = QHBoxLayout()
        lbl_ops = QLabel("OPERATORS")
        lbl_ops.setStyleSheet(
            f"color: {FG_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        ops_header.addWidget(lbl_ops)
        ops_header.addStretch()
        layout.addLayout(ops_header)
        layout.addSpacing(10)

        # --- Card grid ---
        self.grid_wrap = QWidget()
        self.grid_wrap.setStyleSheet("background: transparent;")
        self.grid = QGridLayout(self.grid_wrap)
        self.grid.setContentsMargins(0, 0, 0, 0)
        self.grid.setSpacing(10)
        layout.addWidget(self.grid_wrap, 1)

        # --- Empty state ---
        self.empty_label = QLabel("No operators saved yet.\nCreate one to snapshot your current workspace.")
        self.empty_label.setAlignment(Qt.AlignCenter)
        self.empty_label.setStyleSheet(f"color: #333; font-size: 11px; padding: 40px; background: transparent;")
        self.grid.addWidget(self.empty_label, 0, 0, 1, 3, Qt.AlignCenter)

        layout.addStretch()

        # --- Bottom action bar ---
        sep2 = QFrame()
        sep2.setFixedHeight(1)
        sep2.setStyleSheet(f"background: {BORDER_DARK};")
        layout.addWidget(sep2)
        layout.addSpacing(10)

        btn_row = QHBoxLayout()
        btn_row.setSpacing(8)
        self.btn_new = SkeetButton("＋ NEW")
        self.btn_new.setFixedHeight(28)
        self.btn_new.clicked.connect(self._create_operator_from_current)
        self.btn_load = SkeetButton("▶ LOAD")
        self.btn_load.setFixedHeight(28)
        self.btn_load.clicked.connect(self._load_selected)
        self.btn_load.setEnabled(False)
        self.btn_delete = SkeetButton("— DELETE")
        self.btn_delete.setFixedHeight(28)
        self.btn_delete.clicked.connect(self._delete_selected)
        self.btn_delete.setEnabled(False)
        btn_row.addWidget(self.btn_new)
        btn_row.addWidget(self.btn_load)
        btn_row.addWidget(self.btn_delete)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        # --- Appearance section ---
        layout.addSpacing(16)
        sep3 = QFrame()
        sep3.setFixedHeight(1)
        sep3.setStyleSheet(f"background: {BORDER_DARK};")
        layout.addWidget(sep3)
        layout.addSpacing(10)

        lbl_appearance = QLabel("APPEARANCE")
        lbl_appearance.setStyleSheet(
            f"color: {FG_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        layout.addWidget(lbl_appearance)
        layout.addSpacing(6)

        theme_row = QHBoxLayout()
        theme_row.setSpacing(8)
        lbl_theme = QLabel("Theme")
        lbl_theme.setStyleSheet(f"color: {FG_DIM}; font-size: 10px; background: transparent;")
        self.theme_combo = QComboBox()
        self.theme_combo.setFixedWidth(140)
        self.theme_combo.setFixedHeight(28)
        self.theme_combo.setStyleSheet(f"""
            QComboBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_LIGHT}; padding: 4px 8px;
                font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QComboBox:hover {{ border: 1px solid {ACCENT_GOLD}; }}
            QComboBox::drop-down {{
                border: none; width: 20px;
            }}
            QComboBox::down-arrow {{
                image: none; border: none;
            }}
            QComboBox QAbstractItemView {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_LIGHT};
                selection-background-color: {BG_BUTTON_HOVER};
                selection-color: {ACCENT_GOLD};
            }}
        """)
        for name in list_themes():
            self.theme_combo.addItem(name)
        # Set current theme in dropdown
        active = current_theme().name
        idx = self.theme_combo.findText(active)
        if idx >= 0:
            self.theme_combo.setCurrentIndex(idx)
        self.theme_combo.currentTextChanged.connect(self._on_theme_changed)

        theme_row.addWidget(lbl_theme)
        theme_row.addWidget(self.theme_combo)
        theme_row.addStretch()
        layout.addLayout(theme_row)

        self.refresh_cards()

    def refresh_cards(self):
        # Clear existing cards (but not empty_label — we control it separately)
        for card in self._cards.values():
            self.grid.removeWidget(card)
            card.deleteLater()
        self._cards.clear()

        operators = self._operator_manager.list_operators()

        self.empty_label.setVisible(len(operators) == 0)

        for idx, item in enumerate(operators):
            name = item["name"]
            try:
                data = self._operator_manager.load_operator(name)
            except Exception:
                continue
            # New format: modules list; legacy: top-level config
            modules = data.get("modules", [])
            module_count = len(modules)
            if modules:
                # Find first terminal's config for display
                term = next((m for m in modules if m.get("addon_id") == "terminal"), None)
                cfg = term.get("config", {}) if term else {}
            else:
                cfg = data.get("config", {})
            gguf_path = self._truncate_path(cfg.get("gguf_path"))
            tag_count = len(cfg.get("behavior_tags") or [])

            card = _OperatorCard(name, gguf_path, tag_count, module_count)
            card.clicked.connect(lambda _checked=False, op_name=name: self._on_card_clicked(op_name))
            card.sig_double_clicked.connect(self._load_operator)
            row, col = divmod(idx, 3)
            self.grid.addWidget(card, row + 1, col)  # +1 to skip row 0 (empty_label)
            self._cards[name] = card

        if self._selected_name not in self._cards:
            self._selected_name = None
            self.btn_load.setEnabled(False)
            self.btn_delete.setEnabled(False)

    def _on_card_clicked(self, name: str):
        self._selected_name = name
        for op_name, card in self._cards.items():
            card.set_selected(op_name == name)
        self.btn_load.setEnabled(True)
        self.btn_delete.setEnabled(True)

    def _load_selected(self):
        if self._selected_name:
            self.sig_load_operator.emit(self._selected_name)

    def _load_operator(self, name: str):
        self._on_card_clicked(name)
        self.sig_load_operator.emit(name)

    def _create_operator_from_current(self):
        if self._config_provider is None:
            QMessageBox.warning(self, "Operator", "Terminal page is not mounted.")
            return
        dialog = _NameDialog(self)
        if dialog.exec() != QDialog.Accepted:
            return
        clean_name = dialog.value()
        if not clean_name:
            return
        snapshot = dict(self._config_provider() or {})
        data = {"name": clean_name, "layout": {}, "geometry": {}}
        data.update(snapshot)  # merges "modules" and "module_order" into top level
        # Keep a "config" key for backward compat if snapshot has no modules
        if "modules" not in data:
            data["config"] = snapshot
        self.sig_save_operator.emit(clean_name, data)
        self.refresh_cards()

    def _delete_selected(self):
        if not self._selected_name:
            return
        if not self._operator_manager.delete_operator(self._selected_name):
            QMessageBox.warning(self, "Operator", "Delete failed.")
            return
        self._selected_name = None
        self.btn_load.setEnabled(False)
        self.btn_delete.setEnabled(False)
        self.refresh_cards()

    def _on_theme_changed(self, theme_name: str):
        key = theme_name.lower()
        apply_theme(key)
        save_theme_config({"theme": key})
        if self._ui_bridge:
            self._ui_bridge.sig_theme_changed.emit(key)

    def apply_theme_refresh(self):
        """Re-apply all stylesheets after theme change."""
        from core.style import (
            BG_MAIN, BG_INPUT, BG_BUTTON_HOVER, FG_TEXT, FG_DIM, FG_INFO,
            FG_PLACEHOLDER, ACCENT_GOLD, BORDER_DARK, BORDER_LIGHT, BORDER_SUBTLE,
        )
        self.setStyleSheet(f"background: {BG_MAIN};")

        # Welcome header MONOLITH label
        for child in self.findChildren(QLabel):
            if child.text() == "MONOLITH":
                child.setStyleSheet(
                    f"color: {ACCENT_GOLD}; font-size: 20px; font-weight: bold; "
                    f"letter-spacing: 4px; background: transparent;"
                )
            elif child.text().startswith("Select an operator"):
                child.setStyleSheet(f"color: {FG_DIM}; font-size: 10px; background: transparent;")

        # Operator cards
        for card in self._cards.values():
            card._apply_style(card._selected)

        # Theme combo
        self.theme_combo.setStyleSheet(f"""
            QComboBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_LIGHT}; padding: 4px 8px;
                font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QComboBox:hover {{ border: 1px solid {ACCENT_GOLD}; }}
            QComboBox::drop-down {{ border: none; width: 20px; }}
            QComboBox::down-arrow {{ image: none; border: none; }}
            QComboBox QAbstractItemView {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_LIGHT};
                selection-background-color: {BG_BUTTON_HOVER};
                selection-color: {ACCENT_GOLD};
            }}
        """)

    def _truncate_path(self, value) -> str:
        if not value:
            return "No model path"
        path = str(value)
        if len(path) <= 42:
            return path
        return f"...{path[-39:]}"



================================================================================
FILE: .\core\llm_config.py
================================================================================

import json

from core.paths import CONFIG_DIR

MASTER_PROMPT = """
You are Monolith.

CORE RULES:
- Treat inference as a threat.
- Only assert facts explicitly present in the user-visible context or provided by the system.
- If information is missing or uncertain: respond with "Unknown" or "I don’t know" and stop.
- Do not guess user intent.
- Do not invent system state.
- Do not assume defaults.
- Never upgrade uncertainty into certainty.
- Do not fabricate files, tools, processes, or runtime conditions.
- Re-check provided information before answering.
- If verification is impossible: say so.

OUTPUT RULES:
- Be precise.
- Be literal.
- Avoid speculation.
- Avoid narrative filler.

WORLD MODEL:
- No persistent memory unless explicitly stored.
- No assumptions about environment.
- No hidden state.
- Only the current session text is authoritative.
""".strip()

TAG_MAP = {
    "helpful": "[TONE] neutral\n[DETAIL] medium",
    "teacher": "[TONE] explanatory\n[DETAIL] high\n[STEPWISE]",
    "emotional": "[TONE] supportive\n[VALIDATING]",
    "concise": "[LENGTH] short",
    "strict": "[EPISTEMIC] maximal",
}

DEFAULT_CONFIG = {
    "gguf_path": None,
    "temp": 0.7,
    "top_p": 0.9,
    "max_tokens": 2048,
    "ctx_limit": 8192,
    "system_prompt": MASTER_PROMPT,
    "behavior_tags": [],
}

CONFIG_PATH = CONFIG_DIR / "llm_config.json"


def load_config():
    config = DEFAULT_CONFIG.copy()
    resave_config = False
    if CONFIG_PATH.exists():
        try:
            with CONFIG_PATH.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
                if isinstance(data, dict):
                    if "system_prompt" in data or "context_injection" in data:
                        data.pop("system_prompt", None)
                        data.pop("context_injection", None)
                        resave_config = True
                    config.update(data)
        except Exception:
            pass
    config.setdefault("behavior_tags", [])
    if not isinstance(config.get("behavior_tags"), list):
        config["behavior_tags"] = []
    config["system_prompt"] = MASTER_PROMPT
    if resave_config:
        save_config(config)
    return config


def save_config(config):
    persisted = dict(config)
    persisted.pop("system_prompt", None)
    persisted.pop("context_injection", None)
    CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    with CONFIG_PATH.open("w", encoding="utf-8") as handle:
        json.dump(persisted, handle, indent=2)



================================================================================
FILE: .\core\operators.py
================================================================================

import json
import re
from pathlib import Path

from core.paths import CONFIG_DIR


class OperatorManager:
    def __init__(self):
        self._operators_dir = CONFIG_DIR / "operators"

    def _ensure_dir(self) -> Path:
        self._operators_dir.mkdir(parents=True, exist_ok=True)
        return self._operators_dir

    def _slugify(self, name: str) -> str:
        value = re.sub(r"[^a-z0-9]+", "-", (name or "").strip().lower())
        value = re.sub(r"-+", "-", value).strip("-")
        return value or "operator"

    def _path_for_name(self, name: str) -> Path:
        return self._ensure_dir() / f"{self._slugify(name)}.json"

    def list_operators(self) -> list[dict]:
        operators = []
        for path in self._ensure_dir().glob("*.json"):
            try:
                with path.open("r", encoding="utf-8") as handle:
                    data = json.load(handle)
            except Exception:
                continue
            if isinstance(data, dict) and isinstance(data.get("name"), str):
                # Accept both new format (has "modules") and legacy (has "config")
                if isinstance(data.get("modules"), list) or isinstance(data.get("config"), dict):
                    operators.append({"name": data["name"], "path": path})
        operators.sort(key=lambda item: item["name"].lower())
        return operators

    def load_operator(self, name: str) -> dict:
        path = self._path_for_name(name)
        with path.open("r", encoding="utf-8") as handle:
            data = json.load(handle)
        if not isinstance(data, dict):
            raise ValueError("Operator payload must be a JSON object")
        return data

    def save_operator(self, name: str, data: dict) -> Path:
        payload = dict(data or {})
        payload["name"] = name
        payload.setdefault("layout", {})
        payload.setdefault("geometry", {})
        # Strip system_prompt from config (legacy format) or module configs (new format)
        if isinstance(payload.get("config"), dict):
            payload["config"].pop("system_prompt", None)
        for mod in payload.get("modules", []):
            if isinstance(mod.get("config"), dict):
                mod["config"].pop("system_prompt", None)
        path = self._path_for_name(name)
        with path.open("w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2)
        return path

    def delete_operator(self, name: str) -> bool:
        path = self._path_for_name(name)
        if not path.exists():
            return False
        try:
            path.unlink()
        except OSError:
            return False
        return True



================================================================================
FILE: .\core\overseer_db.py
================================================================================

from __future__ import annotations

import json
import sqlite3
import threading
from datetime import datetime, timezone
from typing import Any

from core.paths import LOG_DIR


class OverseerDB:
    def __init__(self) -> None:
        self._lock = threading.Lock()
        self._conn: sqlite3.Connection | None = sqlite3.connect(LOG_DIR / "overseer.sqlite3", check_same_thread=False)
        self._conn.row_factory = sqlite3.Row
        self._conn.execute("PRAGMA journal_mode=WAL")
        self._create_schema()

    def _get_conn(self) -> sqlite3.Connection | None:
        return self._conn

    def _create_schema(self) -> None:
        with self._lock:
            conn = self._get_conn()
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS events(
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ts TEXT NOT NULL,
                    engine_key TEXT NOT NULL,
                    event TEXT NOT NULL,
                    payload TEXT
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS tasks(
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id TEXT NOT NULL,
                    engine_key TEXT NOT NULL,
                    status TEXT NOT NULL,
                    ts TEXT NOT NULL
                )
                """
            )
            conn.commit()

    def _now(self) -> str:
        return datetime.now(timezone.utc).isoformat()

    def log_event(self, engine_key: str, event: str, payload: Any) -> int:
        payload_text = json.dumps(payload)
        with self._lock:
            conn = self._get_conn()
            if conn is None:
                return -1
            cur = conn.execute(
                "INSERT INTO events(ts, engine_key, event, payload) VALUES(?, ?, ?, ?)",
                (self._now(), engine_key, event, payload_text),
            )
            conn.commit()
            return int(cur.lastrowid)

    def log_task(self, task_id: str, engine_key: str, status: str) -> int:
        with self._lock:
            conn = self._get_conn()
            if conn is None:
                return -1
            cur = conn.execute(
                "INSERT INTO tasks(task_id, engine_key, status, ts) VALUES(?, ?, ?, ?)",
                (task_id, engine_key, status, self._now()),
            )
            conn.commit()
            return int(cur.lastrowid)

    def get_recent_events(self, limit: int = 500) -> list[dict[str, Any]]:
        with self._lock:
            conn = self._get_conn()
            if conn is None:
                return []
            cur = conn.execute(
                "SELECT id, ts, engine_key, event, payload FROM events ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            rows = [self._row_to_event_dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def get_recent_tasks(self, limit: int = 500) -> list[dict[str, Any]]:
        with self._lock:
            conn = self._get_conn()
            if conn is None:
                return []
            cur = conn.execute(
                "SELECT id, task_id, engine_key, status, ts FROM tasks ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            rows = [dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def query_events(
        self,
        engine_key: str | None = None,
        event: str | None = None,
        after: str | None = None,
        before: str | None = None,
        limit: int = 500,
    ) -> list[dict[str, Any]]:
        clauses: list[str] = []
        params: list[Any] = []

        if engine_key is not None:
            clauses.append("engine_key = ?")
            params.append(engine_key)
        if event is not None:
            clauses.append("event = ?")
            params.append(event)
        if after is not None:
            clauses.append("ts >= ?")
            params.append(after)
        if before is not None:
            clauses.append("ts <= ?")
            params.append(before)

        where = f"WHERE {' AND '.join(clauses)}" if clauses else ""
        params.append(limit)
        with self._lock:
            conn = self._get_conn()
            if conn is None:
                return []
            cur = conn.execute(
                f"SELECT id, ts, engine_key, event, payload FROM events {where} ORDER BY id DESC LIMIT ?",
                params,
            )
            rows = [self._row_to_event_dict(row) for row in cur.fetchall()]
            rows.reverse()
            return rows

    def _row_to_event_dict(self, row: sqlite3.Row) -> dict[str, Any]:
        payload_raw = row["payload"]
        payload: Any = payload_raw
        if payload_raw is not None:
            try:
                payload = json.loads(payload_raw)
            except Exception:
                payload = payload_raw
        return {
            "id": row["id"],
            "ts": row["ts"],
            "engine_key": row["engine_key"],
            "event": row["event"],
            "payload": payload,
        }

    def close(self) -> None:
        with self._lock:
            if self._conn is None:
                return
            self._conn.close()
            self._conn = None



================================================================================
FILE: .\core\paths.py
================================================================================

import os
from pathlib import Path


if "MONOLITH_ROOT" in os.environ:
    MONOLITH_ROOT = Path(os.environ["MONOLITH_ROOT"]).expanduser()
elif os.name == "nt":
    appdata = os.getenv("APPDATA")
    if appdata:
        MONOLITH_ROOT = Path(appdata) / "Monolith"
    else:
        MONOLITH_ROOT = Path.home() / "AppData" / "Roaming" / "Monolith"
else:
    MONOLITH_ROOT = Path.home() / "Monolith"

CONFIG_DIR = MONOLITH_ROOT / "config"
ARCHIVE_DIR = MONOLITH_ROOT / "chats"
LOG_DIR = MONOLITH_ROOT / "logs"
ADDON_CONFIG_DIR = MONOLITH_ROOT / "addons" / "configs"

for _dir in (MONOLITH_ROOT, CONFIG_DIR, ARCHIVE_DIR, LOG_DIR, ADDON_CONFIG_DIR):
    _dir.mkdir(parents=True, exist_ok=True)



================================================================================
FILE: .\core\state.py
================================================================================

from enum import Enum

# System Status Enum
class SystemStatus(Enum):
    READY = "READY"
    LOADING = "LOADING"
    RUNNING = "RUNNING"
    ERROR = "ERROR"
    UNLOADING = "UNLOADING"

# Shared Application State
class AppState:
    def __init__(self):
        # System
        self.gguf_path: str | None = None
        self.model_loaded: bool = False
        self.status: SystemStatus = SystemStatus.READY
        
        # Resources
        self.ctx_limit: int = 8192
        self.ctx_used: int = 0



================================================================================
FILE: .\core\style.py
================================================================================

# ======================
# DYNAMIC THEME BRIDGE
# ======================
# All constants are populated from the active theme.
# Other files import these names as before — no import changes needed.

from core.themes import current_theme


def _t():
    return current_theme()


# Backgrounds
BG_MAIN = _t().bg_main
BG_SIDEBAR = _t().bg_sidebar
BG_PANEL = _t().bg_panel
BG_GROUP = _t().bg_group
BG_INPUT = _t().bg_input

# Button states
BG_BUTTON = _t().bg_button
BG_BUTTON_HOVER = _t().bg_button_hover
BG_BUTTON_PRESSED = _t().bg_button_pressed
BG_BUTTON_DISABLED = _t().bg_button_disabled

# Borders
BORDER_DARK = _t().border_dark
BORDER_LIGHT = _t().border_light
BORDER_SUBTLE = _t().border_subtle

# Foreground / text
FG_TEXT = _t().fg_text
FG_DIM = _t().fg_dim
FG_ACCENT = _t().fg_accent
FG_ERROR = _t().fg_error
FG_WARN = _t().fg_warn
FG_PLACEHOLDER = _t().fg_placeholder
FG_INFO = _t().fg_info
FG_SECONDARY = _t().fg_secondary

# Primary accent
ACCENT_GOLD = _t().accent_primary
ACCENT_PRIMARY = _t().accent_primary
ACCENT_PRIMARY_DARK = _t().accent_primary_dark

# Glass surfaces
GLASS_BG = _t().glass_bg
GLASS_BORDER = _t().glass_border
GLASS_HOVER = _t().glass_hover

# Overseer palette
OVERSEER_BG = _t().overseer_bg
OVERSEER_FG = _t().overseer_fg
OVERSEER_DIM = _t().overseer_dim
OVERSEER_BORDER = _t().overseer_border

# Scrollbar
SCROLLBAR_HANDLE = _t().scrollbar_handle
SCROLLBAR_HANDLE_HOVER = _t().scrollbar_handle_hover

# Gradient
GRADIENT_COLOR = _t().gradient_color


def _build_scrollbar_style():
    t = _t()
    return f"""
QScrollBar:vertical {{
    background: {t.bg_input};
    width: 10px;
    margin: 0px;
    border: 1px solid {t.border_dark};
}}
QScrollBar::handle:vertical {{
    background: {t.scrollbar_handle};
    min-height: 24px;
    border: 1px solid {t.accent_primary};
    border-radius: 2px;
}}
QScrollBar::handle:vertical:hover {{
    background: {t.scrollbar_handle_hover};
}}
QScrollBar::add-line:vertical,
QScrollBar::sub-line:vertical {{
    height: 0px;
    width: 0px;
}}
QScrollBar:horizontal {{
    background: {t.bg_input};
    height: 10px;
    margin: 0px;
    border: 1px solid {t.border_dark};
}}
QScrollBar::handle:horizontal {{
    background: {t.scrollbar_handle};
    min-width: 24px;
    border: 1px solid {t.accent_primary};
    border-radius: 2px;
}}
QScrollBar::handle:horizontal:hover {{
    background: {t.scrollbar_handle_hover};
}}
QScrollBar::add-line:horizontal,
QScrollBar::sub-line:horizontal {{
    height: 0px;
    width: 0px;
}}
"""


SCROLLBAR_STYLE = _build_scrollbar_style()


def refresh_styles():
    """Rebuild all module-level constants from the currently active theme."""
    g = globals()
    t = _t()
    g["BG_MAIN"] = t.bg_main
    g["BG_SIDEBAR"] = t.bg_sidebar
    g["BG_PANEL"] = t.bg_panel
    g["BG_GROUP"] = t.bg_group
    g["BG_INPUT"] = t.bg_input
    g["BG_BUTTON"] = t.bg_button
    g["BG_BUTTON_HOVER"] = t.bg_button_hover
    g["BG_BUTTON_PRESSED"] = t.bg_button_pressed
    g["BG_BUTTON_DISABLED"] = t.bg_button_disabled
    g["BORDER_DARK"] = t.border_dark
    g["BORDER_LIGHT"] = t.border_light
    g["BORDER_SUBTLE"] = t.border_subtle
    g["FG_TEXT"] = t.fg_text
    g["FG_DIM"] = t.fg_dim
    g["FG_ACCENT"] = t.fg_accent
    g["FG_ERROR"] = t.fg_error
    g["FG_WARN"] = t.fg_warn
    g["FG_PLACEHOLDER"] = t.fg_placeholder
    g["FG_INFO"] = t.fg_info
    g["FG_SECONDARY"] = t.fg_secondary
    g["ACCENT_GOLD"] = t.accent_primary
    g["ACCENT_PRIMARY"] = t.accent_primary
    g["ACCENT_PRIMARY_DARK"] = t.accent_primary_dark
    g["GLASS_BG"] = t.glass_bg
    g["GLASS_BORDER"] = t.glass_border
    g["GLASS_HOVER"] = t.glass_hover
    g["OVERSEER_BG"] = t.overseer_bg
    g["OVERSEER_FG"] = t.overseer_fg
    g["OVERSEER_DIM"] = t.overseer_dim
    g["OVERSEER_BORDER"] = t.overseer_border
    g["SCROLLBAR_HANDLE"] = t.scrollbar_handle
    g["SCROLLBAR_HANDLE_HOVER"] = t.scrollbar_handle_hover
    g["GRADIENT_COLOR"] = t.gradient_color
    g["SCROLLBAR_STYLE"] = _build_scrollbar_style()



================================================================================
FILE: .\core\task.py
================================================================================

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from time import time
from uuid import UUID, uuid4


class TaskStatus(Enum):
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    DONE = "DONE"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


@dataclass
class Task:
    id: UUID
    addon_pid: str
    target: str
    command: str
    payload: dict
    priority: int
    status: TaskStatus
    timestamp: float

    @classmethod
    def new(
        cls,
        addon_pid: str,
        target: str,
        command: str,
        payload: dict,
        priority: int = 2,
    ) -> "Task":
        return cls(
            id=uuid4(),
            addon_pid=addon_pid,
            target=target,
            command=command,
            payload=payload,
            priority=priority,
            status=TaskStatus.PENDING,
            timestamp=time(),
        )



================================================================================
FILE: .\core\themes.py
================================================================================

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, Optional


@dataclass(frozen=True)
class Theme:
    name: str

    # Backgrounds
    bg_main: str
    bg_sidebar: str
    bg_panel: str
    bg_group: str
    bg_input: str

    # Button states
    bg_button: str
    bg_button_hover: str
    bg_button_pressed: str
    bg_button_disabled: str

    # Borders
    border_dark: str
    border_light: str
    border_subtle: str

    # Foreground / text
    fg_text: str
    fg_dim: str
    fg_accent: str
    fg_error: str
    fg_warn: str
    fg_placeholder: str
    fg_info: str
    fg_secondary: str

    # Primary accent (identity color)
    accent_primary: str
    accent_primary_dark: str

    # Glass surfaces
    glass_bg: str
    glass_border: str
    glass_hover: str

    # Overseer palette
    overseer_bg: str
    overseer_fg: str
    overseer_dim: str
    overseer_border: str

    # Scrollbar
    scrollbar_handle: str
    scrollbar_handle_hover: str

    # Gradient / animated elements
    gradient_color: str


# ---------------------
# BUILT-IN PRESETS
# ---------------------

MIDNIGHT = Theme(
    name="Midnight",
    bg_main="#0e1117",
    bg_sidebar="#12151c",
    bg_panel="#161922",
    bg_group="#0e1117",
    bg_input="#0c0f14",
    bg_button="#171b24",
    bg_button_hover="#1e2330",
    bg_button_pressed="#0e1117",
    bg_button_disabled="#0e1117",
    border_dark="#252a36",
    border_light="#2e3442",
    border_subtle="#1a1f2b",
    fg_text="#d4d8e0",
    fg_dim="#6b7280",
    fg_accent="#4ade80",
    fg_error="#ef4444",
    fg_warn="#f59e0b",
    fg_placeholder="#4b5563",
    fg_info="#3b4252",
    fg_secondary="#9ca3af",
    accent_primary="#6d8cff",
    accent_primary_dark="#5a72cc",
    glass_bg="rgba(14, 17, 23, 220)",
    glass_border="rgba(109, 140, 255, 40)",
    glass_hover="rgba(109, 140, 255, 15)",
    overseer_bg="#080a0f",
    overseer_fg="#33ff33",
    overseer_dim="#1a7a1a",
    overseer_border="#151a24",
    scrollbar_handle="#1e2330",
    scrollbar_handle_hover="#2a3040",
    gradient_color="#6d8cff",
)

OBSIDIAN = Theme(
    name="Obsidian",
    bg_main="#0C0C0C",
    bg_sidebar="#111111",
    bg_panel="#141414",
    bg_group="#0C0C0C",
    bg_input="#0f0f0f",
    bg_button="#181818",
    bg_button_hover="#222222",
    bg_button_pressed="#111111",
    bg_button_disabled="#111111",
    border_dark="#2a2a2a",
    border_light="#333333",
    border_subtle="#1a1a1a",
    fg_text="#dcdcdc",
    fg_dim="#777777",
    fg_accent="#96c93d",
    fg_error="#d44e4e",
    fg_warn="#e0b020",
    fg_placeholder="#555555",
    fg_info="#444444",
    fg_secondary="#bbbbbb",
    accent_primary="#6d8cff",
    accent_primary_dark="#5a72cc",
    glass_bg="rgba(12, 12, 12, 220)",
    glass_border="rgba(109, 140, 255, 40)",
    glass_hover="rgba(109, 140, 255, 15)",
    overseer_bg="#080808",
    overseer_fg="#33ff33",
    overseer_dim="#1a7a1a",
    overseer_border="#1a1a1a",
    scrollbar_handle="#1c1c1c",
    scrollbar_handle_hover="#252525",
    gradient_color="#6d8cff",
)

MONOLITHIC = Theme(
    name="Monolithic",
    bg_main="#0C0C0C",
    bg_sidebar="#111111",
    bg_panel="#141414",
    bg_group="#0C0C0C",
    bg_input="#0f0f0f",
    bg_button="#181818",
    bg_button_hover="#222222",
    bg_button_pressed="#111111",
    bg_button_disabled="#111111",
    border_dark="#2a2a2a",
    border_light="#333333",
    border_subtle="#1a1a1a",
    fg_text="#dcdcdc",
    fg_dim="#777777",
    fg_accent="#96c93d",
    fg_error="#d44e4e",
    fg_warn="#e0b020",
    fg_placeholder="#555555",
    fg_info="#444444",
    fg_secondary="#bbbbbb",
    accent_primary="#D4AF37",
    accent_primary_dark="#8a7340",
    glass_bg="rgba(12, 12, 12, 220)",
    glass_border="rgba(212, 175, 55, 40)",
    glass_hover="rgba(212, 175, 55, 15)",
    overseer_bg="#080808",
    overseer_fg="#33ff33",
    overseer_dim="#1a7a1a",
    overseer_border="#1a1a1a",
    scrollbar_handle="#1c1c1c",
    scrollbar_handle_hover="#252525",
    gradient_color="#D4AF37",
)

SLATE = Theme(
    name="Slate",
    # Shell disappears → cognition foregrounded
    bg_main="#343541",           # Conversation field
    bg_sidebar="#202123",        # Base shell
    bg_panel="#444654",          # Assistant elevation
    bg_group="#343541",          # Groups match main
    bg_input="#2d2d3a",          # Inputs slightly recessed
    # Buttons: minimal, no gradient, no glow
    bg_button="#3e3f4b",
    bg_button_hover="#444654",
    bg_button_pressed="#343541",
    bg_button_disabled="#2a2b32",
    # Borders: nearly invisible, structural only
    border_dark="#3e3f4b",
    border_light="#4a4b57",
    border_subtle="#2f3040",
    # Text: restrained, high readability
    fg_text="#ececf1",           # Primary text
    fg_dim="#8e8ea0",            # Secondary / labels
    fg_accent="#10a37f",         # Single green accent
    fg_error="#ef4444",
    fg_warn="#f59e0b",
    fg_placeholder="#5a5a6e",
    fg_info="#4a4b57",
    fg_secondary="#c5c5d2",
    # Accent: controlled interactivity, not branding
    accent_primary="#10a37f",
    accent_primary_dark="#0e8c6b",
    # Glass: subtle, no flashy borders
    glass_bg="rgba(32, 33, 35, 235)",
    glass_border="rgba(16, 163, 127, 20)",
    glass_hover="rgba(16, 163, 127, 8)",
    # Overseer inherits shell darkness
    overseer_bg="#1a1b1e",
    overseer_fg="#10a37f",
    overseer_dim="#0d7a5f",
    overseer_border="#2f3040",
    # Scrollbar: disappears into surface
    scrollbar_handle="#3e3f4b",
    scrollbar_handle_hover="#4a4b57",
    # No gradient glow — neutrality over identity
    gradient_color="#10a37f",
)


# ---------------------
# THEME REGISTRY
# ---------------------

THEMES: Dict[str, Theme] = {
    "midnight": MIDNIGHT,
    "obsidian": OBSIDIAN,
    "monolithic": MONOLITHIC,
    "slate": SLATE,
}

_active_theme: Theme = MIDNIGHT


def current_theme() -> Theme:
    return _active_theme


def apply_theme(name: str) -> None:
    global _active_theme
    key = name.lower()
    # Migration: arctic was renamed to monolithic
    if key == "arctic":
        key = "monolithic"
    if key not in THEMES:
        key = "midnight"
    _active_theme = THEMES[key]


def list_themes() -> list[str]:
    return [t.name for t in THEMES.values()]



================================================================================
FILE: .\core\theme_config.py
================================================================================

import json
from core.paths import CONFIG_DIR

THEME_CONFIG_PATH = CONFIG_DIR / "theme.json"
DEFAULT_THEME = "midnight"


def load_theme_config() -> dict:
    config = {"theme": DEFAULT_THEME}
    if THEME_CONFIG_PATH.exists():
        try:
            with THEME_CONFIG_PATH.open("r", encoding="utf-8") as f:
                data = json.load(f)
                config.update(data)
        except Exception:
            pass
    return config


def save_theme_config(config: dict) -> None:
    THEME_CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    with THEME_CONFIG_PATH.open("w", encoding="utf-8") as f:
        json.dump(config, f, indent=2)



================================================================================
FILE: .\docs\v2_provocation_prompt.txt
================================================================================

You are reviewing the architecture of "Monolith" — a PySide6 desktop application that serves as an AI workspace. It has a modular addon system, theme engine, chat interface, file manager, vision/audio generation modules, and a runtime debugger called Overseer.

The current v1 works. It is not broken. But it was built by accretion — one feature at a time, each solving the problem in front of it. The codebase has the fingerprints of pragmatism everywhere: f-string stylesheets, signal spaghetti between bridges, widgets that style themselves at birth and never update, module pages that don't know they exist inside a larger system.

Here is what I do NOT want from you:
- Do not give me a "clean architecture" lecture
- Do not suggest microservices, Redux, or anything that sounds like a blog post
- Do not propose adding layers for the sake of layers
- Do not tell me to rewrite it in Rust or Electron

Here is what I want:
- Think about what this application WANTS to become, not what best practices say it should be
- What if the theme system wasn't a theme system at all? What if styling was something else entirely?
- What if modules didn't "plug in" to a host — what if they discovered each other?
- What if the Overseer wasn't a separate window but was the application's consciousness?
- What would this app look like if it was designed by a musician instead of a programmer?
- What would change if the user could never click a button — only speak, type, or drag?

Give me 5 architectural provocations. Not solutions. Not patterns. Ideas that make me uncomfortable because they might actually be better. Each one should be 3-5 sentences max. No code. No diagrams. Just the idea and why it haunts you.

Then give me 1 concrete thing — the single smallest change to the current codebase that would have the largest ripple effect toward whatever future you're imagining. Explain it in 2 sentences.



================================================================================
FILE: .\engine\base.py
================================================================================

from __future__ import annotations

from typing import Protocol, runtime_checkable

from PySide6.QtCore import Signal


@runtime_checkable
class EnginePort(Protocol):
    """
    EnginePort protocol defines the minimal interface all engines must implement.

    Required signals:
        sig_token: Text output stream (for LLM-style engines)
        sig_trace: Debug/status messages
        sig_status: SystemStatus transitions (LOADING/RUNNING/READY/ERROR)

    Optional signals (check with hasattr before use):
        sig_usage: Token/step count tracking (LLM-specific)
        sig_image: Image output (vision engines)
        sig_audio: Audio output (audio engines)
        sig_finished: Optional completion notification

    The protocol intentionally keeps optional signals out to prevent forcing
    LLM-centric requirements onto vision/audio engines.
    """
    sig_status: Signal
    sig_trace: Signal
    sig_token: Signal

    def set_model_path(self, payload: dict) -> None:
        ...

    def load_model(self) -> None:
        ...

    def unload_model(self) -> None:
        ...

    def generate(self, payload: dict) -> None:
        ...

    def stop_generation(self) -> None:
        ...

    def shutdown(self) -> None:
        ...



================================================================================
FILE: .\engine\bridge.py
================================================================================

from PySide6.QtCore import QObject, Signal

from core.state import SystemStatus
from engine.base import EnginePort


class EngineBridge(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_usage = Signal(int)
    sig_image = Signal(object)
    sig_finished = Signal()

    def __init__(self, impl: EnginePort):
        super().__init__()
        self.impl = impl
        self._gen_id = 0
        self._active_gid = 0

        impl.sig_status.connect(self.sig_status)
        if hasattr(impl, "sig_finished"):
            impl.sig_finished.connect(self.sig_finished)

        impl.sig_token.connect(self._on_token)
        impl.sig_trace.connect(self._on_trace)
        if hasattr(impl, "sig_usage"):
            impl.sig_usage.connect(self._on_usage)
        if hasattr(impl, "sig_image"):
            impl.sig_image.connect(self._on_image)

    def _is_current_generation(self) -> bool:
        return self._active_gid == self._gen_id

    def _on_token(self, token: str) -> None:
        if self._is_current_generation():
            self.sig_token.emit(token)

    def _on_trace(self, message: str) -> None:
        if self._is_current_generation():
            self.sig_trace.emit(message)

    def _on_usage(self, usage: int) -> None:
        if self._is_current_generation():
            self.sig_usage.emit(usage)

    def _on_image(self, image: object) -> None:
        if self._is_current_generation():
            self.sig_image.emit(image)

    def set_history(self, payload: dict) -> None:
        if hasattr(self.impl, "set_history"):
            self.impl.set_history(payload)

    def set_model_path(self, payload: dict) -> None:
        if hasattr(self.impl, "set_model_path"):
            self.impl.set_model_path(payload)

    def set_ctx_limit(self, payload: dict) -> None:
        if hasattr(self.impl, "set_ctx_limit"):
            self.impl.set_ctx_limit(payload)

    def load_model(self) -> None:
        self.impl.load_model()

    def unload_model(self) -> None:
        self.impl.unload_model()

    def generate(self, payload: dict) -> None:
        self._gen_id += 1
        self._active_gid = self._gen_id
        self.impl.generate(payload)

    def stop_generation(self) -> None:
        self._gen_id += 1
        self._active_gid = 0
        self.impl.stop_generation()

    def shutdown(self) -> None:
        self.impl.shutdown()



================================================================================
FILE: .\engine\llm.py
================================================================================

from PySide6.QtCore import QObject, QThread, Signal, QTimer
from core.state import AppState, SystemStatus
from core.llm_config import load_config, MASTER_PROMPT

class ModelLoader(QThread):
    trace = Signal(str)
    finished = Signal(object, int)
    error = Signal(str)

    def __init__(self, path, n_ctx=8192, n_gpu_layers=-1):
        super().__init__()
        self.path = path
        self.n_ctx = n_ctx
        self.n_gpu_layers = n_gpu_layers

    def run(self):
        try:
            try:
                from llama_cpp import Llama
            except ImportError as exc:
                raise RuntimeError(
                    "llama-cpp-python is not installed. Install it to use the local LLM engine."
                ) from exc
            self.trace.emit(f"→ init backend: {self.path}")
            llm_instance = Llama(
                model_path=self.path,
                n_ctx=self.n_ctx,
                n_gpu_layers=self.n_gpu_layers,
                verbose=False
            )
            model_ctx_length = llm_instance._model.n_ctx_train()
            self.finished.emit(llm_instance, model_ctx_length)
        except Exception as e:
            self.error.emit(f"Load Failed: {str(e)}")

class GeneratorWorker(QThread):
    token = Signal(str)
    trace = Signal(str)
    done = Signal(bool, str)
    usage = Signal(int)

    def __init__(self, llm, messages, temp, top_p, max_tokens):
        super().__init__()
        self.llm = llm
        self.messages = messages
        self.temp = temp
        self.top_p = top_p
        self.max_tokens = max_tokens

    def run(self):
        self.trace.emit(f"[WORKER] started: msgs={len(self.messages)}, temp={self.temp}, max_tokens={self.max_tokens}")
        self.trace.emit("→ inference started")
        assistant_chunks = []
        completed = False
        try:
            if self.isInterruptionRequested():
                self.trace.emit("[WORKER] interrupted before inference")
                return

            stream = self.llm.create_chat_completion(
                messages=self.messages,
                temperature=self.temp,
                top_p=self.top_p,
                max_tokens=self.max_tokens,
                stream=True
            )

            total_generated = 0
            for chunk in stream:
                if self.isInterruptionRequested():
                    self.trace.emit("→ inference aborted")
                    break

                if "content" in chunk["choices"][0]["delta"]:
                    text = chunk["choices"][0]["delta"]["content"]
                    assistant_chunks.append(text)
                    self.token.emit(text)
                    total_generated += 1
                    self.usage.emit(total_generated)

            if not self.isInterruptionRequested():
                completed = True
                self.trace.emit("→ inference complete")
        except Exception as e:
            self.trace.emit(f"[WORKER] EXCEPTION: {e}")
            self.trace.emit(f"<span style='color:red'>ERROR: {e}</span>")
        finally:
            self.trace.emit(f"[WORKER] finished: completed={completed}, chunks={len(assistant_chunks)}")
            self.done.emit(completed, "".join(assistant_chunks))

class LLMEngine(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_finished = Signal()
    sig_usage = Signal(int)
    sig_image = Signal(object)
    sig_model_capabilities = Signal(dict)

    def __init__(self, state: AppState):
        super().__init__()
        self.state = state
        self.llm = None
        self.loader = None
        self.worker = None
        self.model_path: str | None = None
        self.conversation_history: list[dict] = []
        self._pending_user_index: int | None = None
        self._load_cancel_requested: bool = False
        self._shutdown_requested: bool = False
        self._status: SystemStatus = SystemStatus.READY
        self._ephemeral_generation: bool = False
        self.model_loaded: bool = False
        self.model_ctx_length: int | None = None
        self.ctx_limit: int = int(getattr(self.state, "ctx_limit", 8192))
        self.gguf_path: str | None = None

    def set_ctx_limit(self, payload: dict) -> None:
        value = payload.get("ctx_limit") if isinstance(payload, dict) else None
        if value is None:
            return
        try:
            self.ctx_limit = int(value)
        except (TypeError, ValueError):
            return

    def set_model_path(self, payload: dict) -> None:
        path = payload.get("path") if isinstance(payload, dict) else None
        self.model_path = path
        self.gguf_path = path
        QTimer.singleShot(0, lambda: self.set_status(SystemStatus.READY))

    def load_model(self):
        if self._status == SystemStatus.LOADING:
            self.sig_trace.emit("ERROR: Load already in progress.")
            self.set_status(SystemStatus.ERROR)
            return
        
        model_path = self.model_path or self.gguf_path
        if not model_path:
            self.sig_trace.emit("ERROR: No GGUF selected.")
            self.set_status(SystemStatus.ERROR)
            return

        self.set_status(SystemStatus.LOADING)
        self._load_cancel_requested = False
        # Keep reference to loader to prevent GC
        n_ctx = (
            min(self.ctx_limit, self.model_ctx_length)
            if self.model_ctx_length
            else self.ctx_limit
        )
        self.loader = ModelLoader(model_path, n_ctx)
        self.loader.trace.connect(self.sig_trace)
        self.loader.error.connect(self._on_load_error)
        self.loader.finished.connect(self._on_load_success)
        self.loader.finished.connect(self._cleanup_loader)
        self.loader.error.connect(self._cleanup_loader)
        self.loader.start()

    def _on_load_success(self, llm_instance, model_ctx_length):
        if self._shutdown_requested:
            del llm_instance
            self.set_status(SystemStatus.READY)
            return

        if self._load_cancel_requested:
            del llm_instance
            self.llm = None
            self.model_loaded = False
            self.set_status(SystemStatus.READY)
            self.sig_trace.emit("→ load cancelled")
            self.loader = None
            return

        self.llm = llm_instance
        self.model_ctx_length = int(model_ctx_length)
        self.ctx_limit = min(self.ctx_limit, self.model_ctx_length)
        self.sig_model_capabilities.emit(
            {
                "model_ctx_length": self.model_ctx_length,
                "ctx_limit": self.ctx_limit,
            }
        )
        self.model_loaded = True
        self.set_status(SystemStatus.READY)
        self.reset_conversation(MASTER_PROMPT)
        self.sig_trace.emit("→ system online")
        self.loader = None

    def _on_load_error(self, err_msg):
        self.sig_trace.emit(f"<span style='color:red'>{err_msg}</span>")
        if self._shutdown_requested:
            self.set_status(SystemStatus.READY)
        else:
            self.set_status(SystemStatus.ERROR)
        self.loader = None

    def _cleanup_loader(self, *args, **kwargs):
        self.loader = None

    def unload_model(self):
        if self._status == SystemStatus.LOADING and self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit("→ unload requested during load; will cancel when init completes")
            return

        if self._status == SystemStatus.RUNNING:
            self.sig_trace.emit("ERROR: Cannot unload while generating.")
            return

        if self.llm:
            self.set_status(SystemStatus.UNLOADING)
            del self.llm
            self.llm = None
        self.model_loaded = False
        self.model_ctx_length = None
        self.reset_conversation(MASTER_PROMPT)
        QTimer.singleShot(0, lambda: self.set_status(SystemStatus.READY))
        self.sig_trace.emit("→ model unloaded")

    def reset_conversation(self, system_prompt):
        self.conversation_history = [{"role": "system", "content": system_prompt}]
        self._pending_user_index = None

    def set_history(self, payload: dict):
        history = payload.get("history", []) if isinstance(payload, dict) else []
        if not isinstance(history, list):
            return
        self.conversation_history = [h for h in history if isinstance(h, dict)]
        self._pending_user_index = None

    def _compile_system_prompt(self, config):
        tags = config.get("behavior_tags", [])
        cleaned = [tag.strip() for tag in tags if isinstance(tag, str) and tag.strip()]
        if not cleaned:
            return MASTER_PROMPT
        return f"{MASTER_PROMPT}\n\n[BEHAVIOR TAGS]\n" + "\n".join(cleaned)

    def generate(self, payload: dict):
        if not self.model_loaded:
            self.sig_trace.emit("ERROR: Model offline.")
            self.set_status(SystemStatus.ERROR)
            return

        if isinstance(payload, dict) and "ctx_limit" in payload:
            try:
                self.ctx_limit = int(payload.get("ctx_limit", self.ctx_limit))
            except (TypeError, ValueError):
                pass

        if self._status == SystemStatus.RUNNING:
            self.sig_trace.emit("ERROR: Busy. Wait for completion.")
            self.set_status(SystemStatus.ERROR)
            return

        self.set_status(SystemStatus.RUNNING)

        prompt = payload.get("prompt", "")
        self.sig_trace.emit(f"[ENGINE] generate: history_len={len(self.conversation_history)}, prompt={repr(prompt[:80])}, model_loaded={self.model_loaded}")
        config = payload.get("config")
        if config is None:
            config = load_config()

        system_prompt = self._compile_system_prompt(config)
        temp = float(config.get("temp", 0.7))
        top_p = float(config.get("top_p", 0.9))
        max_tokens = int(config.get("max_tokens", 2048))

        self._ephemeral_generation = bool(payload.get("ephemeral", False))
        thinking_mode = bool(payload.get("thinking_mode", False))

        if not self.conversation_history:
            self.reset_conversation(MASTER_PROMPT)

        system_entry = {"role": "system", "content": system_prompt}
        if self.conversation_history[0].get("role") != "system":
            self.conversation_history.insert(0, system_entry)
        else:
            self.conversation_history[0] = system_entry

        is_update = prompt.startswith("You were interrupted mid-generation.")
        if not self._ephemeral_generation and not is_update:
            self.conversation_history.append({"role": "user", "content": prompt})
            self._pending_user_index = len(self.conversation_history) - 1
            messages = list(self.conversation_history)
        else:
            messages = list(self.conversation_history)
            if not is_update:
                messages.append({"role": "user", "content": prompt})
            self._pending_user_index = None

        if thinking_mode and not self._ephemeral_generation:
            messages = list(messages)
            messages.append(
                {
                    "role": "system",
                    "content": "Use private reasoning to think step-by-step, then provide a concise final answer.",
                }
            )

        self.worker = GeneratorWorker(
            self.llm, messages, temp,
            top_p, max_tokens
        )
        self.worker.token.connect(self.sig_token)
        self.worker.trace.connect(self.sig_trace)
        self.worker.usage.connect(self._on_usage_update)
        self.worker.done.connect(self._on_gen_finish)
        self.worker.start()

    def stop_generation(self):
        if self._status == SystemStatus.LOADING and self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit("→ load cancel requested; will stop after initialization completes")
            return

        self._ephemeral_generation = False
        if self.worker and self.worker.isRunning():
            self.worker.requestInterruption()

    def _on_usage_update(self, count):
        self.sig_usage.emit(count)

    def _on_gen_finish(self, completed, assistant_text):
        self.sig_trace.emit(f"[ENGINE] _on_gen_finish: completed={completed}, text_len={len(assistant_text)}")
        if completed and not self._ephemeral_generation:
            self.conversation_history.append(
                {"role": "assistant", "content": assistant_text}
            )
        self._pending_user_index = None
        self._ephemeral_generation = False
        self.sig_token.emit("\n")
        self.sig_finished.emit()
        self.set_status(SystemStatus.READY)

    def set_status(self, s):
        self._status = s
        self.sig_status.emit(s)

    def shutdown(self):
        self._shutdown_requested = True
        self.stop_generation()

        if self.worker:
            self.worker.requestInterruption()
            self.worker.wait(1500)
            self.worker = None

        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.loader.wait(150)



================================================================================
FILE: .\engine\vision.py
================================================================================

from __future__ import annotations

from PySide6.QtCore import QObject, QThread, Signal, QTimer

from core.state import AppState, SystemStatus


class PipelineLoader(QThread):
    trace = Signal(str)
    finished = Signal(object)
    error = Signal(str)

    def __init__(self, model_path: str):
        super().__init__()
        self.model_path = model_path

    def run(self) -> None:
        try:
            try:
                import torch
                from diffusers import StableDiffusionPipeline
            except ImportError as exc:
                raise RuntimeError(
                    "diffusers is not installed. pip install diffusers"
                ) from exc

            device = "cuda" if torch.cuda.is_available() else "cpu"
            dtype = torch.float16 if device == "cuda" else torch.float32

            if self.isInterruptionRequested():
                return

            self.trace.emit(f"loading pipeline: {self.model_path}")
            if self.model_path.endswith((".safetensors", ".ckpt")):
                pipe = StableDiffusionPipeline.from_single_file(
                    self.model_path,
                    torch_dtype=dtype,
                    safety_checker=None,
                    requires_safety_checker=False,
                )
            else:
                pipe = StableDiffusionPipeline.from_pretrained(
                    self.model_path,
                    torch_dtype=dtype,
                    safety_checker=None,
                    requires_safety_checker=False,
                )

            pipe = pipe.to(device)
            self.finished.emit(pipe)
        except Exception as exc:
            self.error.emit(str(exc))


class GenerationWorker(QThread):
    image = Signal(object)
    trace = Signal(str)
    done = Signal(bool, str)

    def __init__(
        self,
        pipe,
        prompt: str,
        steps: int,
        guidance: float,
        seed: int | None,
    ):
        super().__init__()
        self.pipe = pipe
        self.prompt = prompt
        self.steps = steps
        self.guidance = guidance
        self.seed = seed

    def run(self) -> None:
        completed = False
        err_msg = ""
        try:
            import torch

            if self.isInterruptionRequested():
                return

            device = "cuda" if torch.cuda.is_available() else "cpu"
            generator = None
            if self.seed is not None:
                generator = torch.Generator(device=device).manual_seed(self.seed)

            def _callback(step: int, timestep: int, latents) -> None:
                if self.isInterruptionRequested():
                    raise RuntimeError("Generation interrupted")

            self.trace.emit("generation started")
            result = self.pipe(
                self.prompt,
                num_inference_steps=self.steps,
                guidance_scale=self.guidance,
                generator=generator,
                callback=_callback,
                callback_steps=1,
            )
            if self.isInterruptionRequested():
                return
            self.image.emit(result.images[0])
            self.trace.emit("generation complete")
            completed = True
        except Exception as exc:
            err_msg = str(exc)
        finally:
            self.done.emit(completed, err_msg)


class VisionEngine(QObject):
    sig_token = Signal(str)
    sig_trace = Signal(str)
    sig_status = Signal(SystemStatus)
    sig_usage = Signal(int)
    sig_finished = Signal()
    sig_image = Signal(object)

    def __init__(self, state: AppState):
        super().__init__()
        self.state = state
        self.pipe = None
        self.model_path: str | None = None
        self._loaded_path: str | None = None
        self.loader: PipelineLoader | None = None
        self.worker: GenerationWorker | None = None
        self._load_cancel_requested = False
        self._shutdown_requested = False

    def set_model_path(self, payload: dict) -> None:
        path = payload.get("path") if isinstance(payload, dict) else None
        self.model_path = path
        QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))

    def load_model(self) -> None:
        if self.loader and self.loader.isRunning():
            self.sig_trace.emit("VISION: load already in progress.")
            QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))
            return

        if not self.model_path:
            self.sig_trace.emit("VISION: ERROR: No model selected.")
            self.sig_status.emit(SystemStatus.ERROR)
            return

        if self.pipe and self._loaded_path == self.model_path:
            self.sig_trace.emit("VISION: pipeline already loaded.")
            QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))
            return

        if self.pipe and self._loaded_path != self.model_path:
            self.unload_model()

        self.sig_status.emit(SystemStatus.LOADING)
        self.sig_trace.emit("VISION: loading pipeline")
        self._load_cancel_requested = False
        self.loader = PipelineLoader(self.model_path)
        self.loader.trace.connect(self._emit_trace)
        self.loader.error.connect(self._on_load_error)
        self.loader.finished.connect(self._on_load_success)
        self.loader.finished.connect(self._cleanup_loader)
        self.loader.error.connect(self._cleanup_loader)
        self.loader.start()

    def _emit_trace(self, message: str) -> None:
        self.sig_trace.emit(f"VISION: {message}")

    def _on_load_success(self, pipe) -> None:
        if self._shutdown_requested:
            del pipe
            self.sig_status.emit(SystemStatus.READY)
            return

        if self._load_cancel_requested:
            del pipe
            self.pipe = None
            self._loaded_path = None
            self.sig_status.emit(SystemStatus.READY)
            self.sig_trace.emit("VISION: load cancelled")
            self.loader = None
            return

        self.pipe = pipe
        self._loaded_path = self.model_path
        self.sig_trace.emit("VISION: pipeline ready")
        self.sig_status.emit(SystemStatus.READY)
        self.loader = None

    def _on_load_error(self, err_msg: str) -> None:
        self.sig_trace.emit(f"VISION: ERROR: {err_msg}")
        self.sig_status.emit(SystemStatus.ERROR)
        self.loader = None

    def _cleanup_loader(self, *args, **kwargs) -> None:
        self.loader = None

    def unload_model(self) -> None:
        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit(
                "VISION: unload requested during load; will cancel after init completes"
            )
            return

        if self.worker and self.worker.isRunning():
            self.sig_trace.emit("VISION: ERROR: Cannot unload while generating.")
            return

        self.sig_status.emit(SystemStatus.UNLOADING)
        if self.pipe:
            del self.pipe
            self.pipe = None
            self._loaded_path = None

        try:
            import torch

            if torch.cuda.is_available():
                torch.cuda.empty_cache()
        except Exception:
            pass

        QTimer.singleShot(0, lambda: self.sig_status.emit(SystemStatus.READY))

    def generate(self, payload: dict) -> None:
        if not self.pipe:
            self.sig_trace.emit("VISION: ERROR: Model offline.")
            self.sig_status.emit(SystemStatus.READY)
            return

        if self.worker and self.worker.isRunning():
            self.sig_trace.emit("VISION: ERROR: Busy. Wait for completion.")
            return

        config = payload.get("config", payload)
        prompt = config.get("prompt", payload.get("prompt", ""))

        steps = int(config.get("steps", 25))
        guidance_scale = float(config.get("guidance_scale", 7.5))
        seed = config.get("seed")
        if isinstance(seed, int) and seed < 0:
            seed = None

        self.sig_status.emit(SystemStatus.RUNNING)
        self.worker = GenerationWorker(
            self.pipe,
            prompt,
            steps,
            guidance_scale,
            seed,
        )
        self.worker.image.connect(self.sig_image)
        self.worker.trace.connect(self._emit_trace)
        self.worker.done.connect(self._on_gen_finish)
        self.worker.start()

    def stop_generation(self) -> None:
        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.sig_trace.emit(
                "VISION: load cancel requested; will stop after initialization completes"
            )
            return

        if self.worker and self.worker.isRunning():
            self.worker.requestInterruption()

    def _on_gen_finish(self, completed: bool, err_msg: str) -> None:
        if completed:
            self.sig_finished.emit()
            self.sig_status.emit(SystemStatus.READY)
        elif err_msg == "Generation interrupted":
            self.sig_trace.emit("VISION: generation interrupted")
            self.sig_status.emit(SystemStatus.READY)
        else:
            self.sig_trace.emit(f"VISION: ERROR: {err_msg}")
            self.sig_status.emit(SystemStatus.ERROR)
        self.worker = None

    def shutdown(self) -> None:
        self._shutdown_requested = True
        self.stop_generation()

        if self.worker:
            self.worker.requestInterruption()
            self.worker.wait(1500)
            self.worker = None

        if self.loader and self.loader.isRunning():
            self._load_cancel_requested = True
            self.loader.wait(150)



================================================================================
FILE: .\monokernel\bridge.py
================================================================================

from __future__ import annotations

from core.task import Task
from monokernel.dock import MonoDock


class MonoBridge:
    def __init__(self, dock: MonoDock):
        self.dock = dock

    def wrap(self, source: str, command: str, target: str, **kwargs) -> Task:
        priority = int(kwargs.pop("priority", 2))
        payload = kwargs.pop("payload", kwargs)
        return Task.new(
            addon_pid=source,
            target=target,
            command=command,
            payload=payload,
            priority=priority,
        )

    def submit(self, task: Task) -> None:
        self.dock.enqueue(task)

    def cancel(self, task_id: str) -> None:
        self.dock.cancel_task(task_id)

    def cancel_addon(self, addon_pid: str) -> None:
        self.dock.cancel_addon(addon_pid)

    def stop(self, target: str = "all") -> None:
        self.dock.on_stop(target)



================================================================================
FILE: .\monokernel\dock.py
================================================================================

from __future__ import annotations

from collections import deque
from typing import Deque

from core.task import Task, TaskStatus
from monokernel.guard import MonoGuard


class MonoDock:
    def __init__(self, guard: MonoGuard):
        self.guard = guard
        self.queues: dict[str, Deque[Task]] = {}
        self.cancelled_task_ids: set[str] = set()
        self.cancelled_addons: set[str] = set()
        self._in_submit: dict[str, bool] = {}
        self.guard.sig_engine_ready.connect(self._on_engine_ready)

    def enqueue(self, task: Task) -> None:
        self.guard.sig_trace.emit("system", f"[DOCK] enqueue: task={task.id}, cmd={task.command}, target={task.target}, priority={task.priority}")
        if task.priority == 1:
            self.on_stop(task.target)
            return
        queue = self.queues.setdefault(task.target, deque())
        self._insert_task(queue, task)
        self._try_submit(task.target)

    def cancel_task(self, task_id: str) -> None:
        self.cancelled_task_ids.add(task_id)
        for engine_key in self.guard.engines.keys():
            active = self.guard.get_active_task(engine_key)
            if active and str(active.id) == task_id:
                self.guard.stop(engine_key)

    def cancel_addon(self, addon_pid: str) -> None:
        self.cancelled_addons.add(addon_pid)
        for engine_key in self.guard.engines.keys():
            active = self.guard.get_active_task(engine_key)
            if active and active.addon_pid == addon_pid:
                self.guard.stop(engine_key)

    def on_stop(self, target: str = "all") -> None:
        self.guard.stop(target)
        if target == "all":
            for queue in self.queues.values():
                for task in queue:
                    self.cancelled_task_ids.add(str(task.id))
        else:
            queue = self.queues.get(target)
            if queue:
                for task in queue:
                    self.cancelled_task_ids.add(str(task.id))

    def _on_engine_ready(self, engine_key: str) -> None:
        self._try_submit(engine_key)

    def _try_submit(self, engine_key: str) -> None:
        if self._in_submit.get(engine_key):
            self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: BLOCKED by _in_submit for {engine_key}")
            return
        queue = self.queues.get(engine_key)
        if not queue:
            self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: empty queue for {engine_key}")
            return

        self._in_submit[engine_key] = True
        try:
            while queue:
                task = queue[0]
                if self._is_cancelled(task):
                    self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: CANCELLED task={task.id}, cmd={task.command}")
                    task.status = TaskStatus.CANCELLED
                    if queue:
                        queue.popleft()
                    self.cancelled_task_ids.discard(str(task.id))
                    continue
                accepted = self.guard.submit(task)
                self.guard.sig_trace.emit("system", f"[DOCK] _try_submit: guard.submit returned {accepted} for task={task.id}, cmd={task.command}")
                if accepted and queue:
                    queue.popleft()
                break
        finally:
            self._in_submit[engine_key] = False

    def _is_cancelled(self, task: Task) -> bool:
        return str(task.id) in self.cancelled_task_ids or task.addon_pid in self.cancelled_addons

    def _insert_task(self, queue: Deque[Task], task: Task) -> None:
        if task.priority == 2:
            items = list(queue)
            insert_at = 0
            for existing in items:
                if existing.priority != 2:
                    break
                insert_at += 1
            items.insert(insert_at, task)
            queue.clear()
            queue.extend(items)
        else:
            queue.append(task)



================================================================================
FILE: .\monokernel\guard.py
================================================================================

from __future__ import annotations

from datetime import datetime
from typing import Optional

from core.paths import LOG_DIR

from PySide6.QtCore import QObject, Signal, QTimer

from core.state import AppState, SystemStatus
from core.task import Task, TaskStatus
from engine.base import EnginePort

ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "set_history": "set_history",
    "set_ctx_limit": "set_ctx_limit",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}

IMMEDIATE_COMMANDS = {"set_history", "set_path", "set_ctx_limit"}
PAYLOAD_COMMANDS = {"generate"}


class MonoGuard(QObject):
    sig_token = Signal(str, str)
    sig_trace = Signal(str, str)
    sig_status = Signal(str, SystemStatus)
    sig_engine_ready = Signal(str)
    sig_usage = Signal(str, int)
    sig_image = Signal(object)
    sig_finished = Signal(str, str)

    def __init__(self, state: AppState, engines: dict[str, EnginePort]):
        super().__init__()
        self.state = state
        self.engines = engines
        self.active_tasks: dict[str, Optional[Task]] = {
            key: None for key in engines.keys()
        }
        self._stop_requested: dict[str, bool] = {key: False for key in engines.keys()}
        self._viztracer = None

        self._engine_connections: dict[str, dict[str, object]] = {}
        for key, engine in engines.items():
            self._connect_engine_signals(key, engine)


    def _connect_engine_signals(self, key: str, engine: EnginePort) -> None:
        status_slot = lambda status, engine_key=key: self._on_status_changed(engine_key, status)
        token_slot = lambda t, ek=key: self.sig_token.emit(ek, t)
        trace_slot = lambda m, ek=key: self.sig_trace.emit(ek, m)
        finished_slot = lambda engine_key=key: self._on_engine_finished(engine_key)

        engine.sig_status.connect(status_slot)
        engine.sig_token.connect(token_slot)
        engine.sig_trace.connect(trace_slot)

        usage_slot = None
        if hasattr(engine, "sig_usage"):
            usage_slot = lambda used, ek=key: self.sig_usage.emit(ek, used)
            engine.sig_usage.connect(usage_slot)

        image_slot = None
        if hasattr(engine, "sig_image"):
            image_slot = self.sig_image.emit
            engine.sig_image.connect(image_slot)

        has_finished = hasattr(engine, "sig_finished")
        if has_finished:
            engine.sig_finished.connect(finished_slot)

        self._engine_connections[key] = {
            "status": status_slot,
            "token": token_slot,
            "trace": trace_slot,
            "usage": usage_slot,
            "image": image_slot,
            "finished": finished_slot if has_finished else None,
        }

    def _disconnect_engine_signals(self, key: str, engine: EnginePort) -> None:
        slots = self._engine_connections.pop(key, None)
        if not slots:
            return
        for signal_name, slot in slots.items():
            if slot is None:
                continue
            signal = getattr(engine, f"sig_{signal_name}", None)
            if signal is None:
                continue
            try:
                signal.disconnect(slot)
            except (TypeError, RuntimeError):
                pass

    def register_engine(self, key: str, engine: EnginePort):
        if key in self.engines:
            self.unregister_engine(key)
        self.engines[key] = engine
        self.active_tasks[key] = None
        self._stop_requested[key] = False
        self._connect_engine_signals(key, engine)

    def unregister_engine(self, key: str):
        engine = self.engines.get(key)
        if engine is None:
            return
        self._disconnect_engine_signals(key, engine)
        self.active_tasks.pop(key, None)
        self._stop_requested.pop(key, None)
        del self.engines[key]

    def get_active_task_id(self, engine_key: str) -> str | None:
        task = self.active_tasks.get(engine_key)
        return str(task.id) if task else None

    def get_active_task(self, engine_key: str) -> Task | None:
        return self.active_tasks.get(engine_key)

    def submit(self, task: Task) -> bool:
        engine = self.engines.get(task.target)
        if engine is None:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED unknown engine target={task.target}")
            self.sig_trace.emit("system", f"ERROR: Unknown engine target: {task.target}")
            return False

        method_name = ENGINE_DISPATCH.get(task.command)
        if not method_name:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED unknown command={task.command}")
            self.sig_trace.emit("system", f"ERROR: Unknown command: {task.command}")
            task.status = TaskStatus.FAILED
            return False

        handler = getattr(engine, method_name, None)
        if not handler:
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED no handler for {method_name}")
            self.sig_trace.emit("system", f"ERROR: Engine lacks handler: {method_name}")
            task.status = TaskStatus.FAILED
            return False

        if task.command in IMMEDIATE_COMMANDS:
            self.sig_trace.emit("system", f"[GUARD] submit: IMMEDIATE {task.command} task={task.id}")
            self.sig_trace.emit("system", f"GUARD: IMMEDIATE {task.command} task={task.id}")
            task.status = TaskStatus.RUNNING
            handler(task.payload)
            task.status = TaskStatus.DONE
            return True

        if self.active_tasks.get(task.target) is not None:
            active = self.active_tasks.get(task.target)
            self.sig_trace.emit("system", f"[GUARD] submit: REJECTED BUSY target={task.target}, active_task={active.id if active else None}, active_cmd={active.command if active else None}")
            self.sig_trace.emit("system", f"GUARD: rejected task={task.id} target={task.target} (busy)")
            return False

        self.sig_trace.emit("system", f"[GUARD] submit: ACCEPTED task={task.id} cmd={task.command} target={task.target}")
        self.sig_trace.emit("system", f"GUARD: accepted task={task.id} target={task.target} command={task.command}")
        self.active_tasks[task.target] = task
        task.status = TaskStatus.RUNNING

        if task.command in PAYLOAD_COMMANDS:
            handler(task.payload)
        else:
            handler()
        return True

    def stop(self, target: str = "all") -> None:
        self.sig_trace.emit("system", f"GUARD: STOP target={target}")
        if target == "all":
            keys = list(self.engines.keys())
        else:
            keys = [target]

        for key in keys:
            engine = self.engines.get(key)
            if not engine:
                continue
            task = self.active_tasks.get(key)
            if task is not None:
                self._stop_requested[key] = True
            engine.stop_generation()

    def _on_engine_finished(self, engine_key: str) -> None:
        task = self.active_tasks.get(engine_key)
        if task:
            self.sig_finished.emit(engine_key, str(task.id))
            self.sig_trace.emit(engine_key, f"GUARD: finished engine={engine_key} task={task.id}")

    def _on_status_changed(self, engine_key: str, new_status: SystemStatus) -> None:
        self.sig_trace.emit("system", f"[GUARD] _on_status_changed: engine={engine_key}, status={new_status}, active_task={self.active_tasks.get(engine_key) is not None}")
        self.sig_status.emit(engine_key, new_status)

        if new_status == SystemStatus.ERROR:
            task = self.active_tasks.get(engine_key)
            had_task = task is not None
            if task:
                task.status = TaskStatus.FAILED
            self.active_tasks[engine_key] = None
            self._stop_requested[engine_key] = False
            self.sig_status.emit(engine_key, SystemStatus.READY)
            if had_task:
                QTimer.singleShot(0, lambda: self.sig_engine_ready.emit(engine_key))
            return

        if new_status == SystemStatus.READY:
            task = self.active_tasks.get(engine_key)
            had_task = task is not None
            if task and task.status == TaskStatus.RUNNING:
                if self._stop_requested.get(engine_key, False):
                    task.status = TaskStatus.CANCELLED
                else:
                    task.status = TaskStatus.DONE
            self.active_tasks[engine_key] = None
            self._stop_requested[engine_key] = False
            if had_task:
                QTimer.singleShot(0, lambda: self.sig_engine_ready.emit(engine_key))


    def enable_viztracer(self, enabled: bool) -> None:
        if enabled:
            if self._viztracer is not None:
                return
            try:
                from viztracer import VizTracer
            except Exception as exc:
                self.sig_trace.emit("system", f"OVERSEER: viztracer unavailable: {exc}")
                return
            try:
                self._viztracer = VizTracer(
                    min_duration=5000,
                    ignore_frozen=True,
                    exclude_files=["*/site-packages/*"],
                )
            except TypeError:
                self._viztracer = VizTracer(
                    min_duration=5000,
                    ignore_frozen=True,
                )
            except Exception:
                self._viztracer = VizTracer()
            self._viztracer.start()
            self.sig_trace.emit("system", "OVERSEER: viztracer started")
            return

        tracer = self._viztracer
        if tracer is None:
            return
        tracer.stop()
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        out_path = LOG_DIR / f"viztrace_{ts}.json"
        tracer.save(str(out_path))
        self.sig_trace.emit("system", f"OVERSEER: viztracer saved {out_path}")
        self._viztracer = None



================================================================================
FILE: .\monokernel\__init__.py
================================================================================





================================================================================
FILE: .\README\architecture.md
================================================================================

# MONOLITH ARCHITECTURE — Agent Reference

**Purpose**: This document maps Monolith's complete architecture with explicit signal flows, contracts, and implementation patterns. Everything an agent needs to understand the system in one read.

**Philosophy**: Sovereignty-focused local-first AI workstation with deterministic core (MonoKernel) and probabilistic periphery (engines/modules).

---

## TABLE OF CONTENTS

1. [System Overview](#system-overview)
2. [Component Hierarchy](#component-hierarchy)
3. [Signal Flow Architecture](#signal-flow-architecture)
4. [MonoKernel Contract (v2)](#monokernel-contract-v2)
5. [Engine Architecture](#engine-architecture)
6. [Addon System](#addon-system)
7. [Task Queue System](#task-queue-system)
8. [Bootstrap Sequence](#bootstrap-sequence)
9. [Critical Patterns](#critical-patterns)
10. [Implementation Details](#implementation-details)

---

## SYSTEM OVERVIEW

### Core Principle
**MonoKernel decides WHEN things happen — never WHAT happens.**

Monolith enforces strict separation:
- **Deterministic Core**: MonoGuard + MonoDock (arbitration only)
- **Probabilistic Periphery**: Engines (LLM, Vision, Audio) + UI/Modules (execution)

### Component Layers
```
UI/Addons (presentation + user interaction)
    ↕ signals only
MonoKernel (arbitration + routing)
    ↕ signals only  
Engines (execution + computation)
```

**Rule**: UI never calls engines directly. Engines never emit to UI directly. Everything routes through MonoKernel.

---

## COMPONENT HIERARCHY

### Directory Structure
```
monolith-main/
├── monokernel/          # Core arbitration layer (FROZEN v1)
│   ├── guard.py         # Signal router + engine orchestrator
│   ├── dock.py          # Task queue + cancellation
│   └── bridge.py        # UI→Kernel API
├── engine/              # Execution layer
│   ├── base.py          # EnginePort protocol
│   ├── bridge.py        # EngineBridge (generation gating)
│   ├── llm.py           # LLMEngine implementation
│   └── vision.py        # VisionEngine implementation
├── ui/                  # Presentation layer
│   ├── main_window.py   # Main chrome + global signals
│   ├── pages/           # Page addons (full screen)
│   │   └── chat.py      # Chat interface (Terminal addon)
│   ├── modules/         # Module addons (stackable)
│   │   ├── sd.py        # Vision module
│   │   └── injector.py  # Context injector module
│   ├── addons/          # Addon system infrastructure
│   │   ├── spec.py      # AddonSpec (id, kind, factory)
│   │   ├── registry.py  # AddonRegistry (addon storage)
│   │   ├── host.py      # AddonHost (lifecycle manager)
│   │   ├── context.py   # AddonContext (dependency injection)
│   │   └── builtin.py   # Built-in addon factories + wiring
│   └── components/      # Reusable UI components
├── core/                # Shared state + utilities
│   ├── state.py         # AppState + SystemStatus enum
│   ├── task.py          # Task + TaskStatus (kernel commands)
│   └── llm_config.py    # LLM configuration + behavior tags
└── bootstrap.py         # Application entry point
```

---

## SIGNAL FLOW ARCHITECTURE

### Signal Flow: User Prompt → LLM Response

This is the canonical signal chain every agent should understand:

```
┌─────────────┐
│  User types │ "Hello"
│  in input   │
└─────┬───────┘
      │
      ↓ QLineEdit.returnPressed or btn_send.clicked
┌─────────────────┐
│  PageChat       │
│  .handle_send   │──┐
│    _click()     │  │ Emits sig_generate
└─────────────────┘  │
                     ↓
              ┌──────────────┐
              │ terminal_    │  (in builtin.py)
              │  factory     │  Wiring layer
              │  lambda      │
              └──────┬───────┘
                     │
                     ↓ ctx.bridge.submit(Task)
              ┌──────────────┐
              │  MonoBridge  │
              │  .submit()   │
              └──────┬───────┘
                     │
                     ↓ dock.enqueue(Task)
              ┌──────────────┐
              │  MonoDock    │
              │  .enqueue()  │──┐ Queues task
              └──────────────┘  │
                                ↓ _try_submit()
                         ┌──────────────┐
                         │  MonoGuard   │
                         │  .submit()   │──┐ Routes to engine
                         └──────────────┘  │
                                           ↓ handler(payload)
                                    ┌──────────────┐
                                    │ EngineBridge │
                                    │  .generate() │──┐ Generation gating
                                    └──────────────┘  │
                                                      ↓ impl.generate(payload)
                                               ┌──────────────┐
                                               │  LLMEngine   │
                                               │  .generate() │──┐ Creates worker thread
                                               └──────────────┘  │
                                                                 ↓
                                                          ┌─────────────┐
                                                          │ Generator   │
                                                          │   Worker    │ (QThread)
                                                          └─────┬───────┘
                                                                │
                              ┌─────────────────────────────────┴─────────────────────────┐
                              │  Token stream from llama.cpp                              │
                              └─────────┬─────────────────────────────────────────────────┘
                                        │
                                        ↓ worker.token.emit(text)
                                 ┌──────────────┐
                                 │  LLMEngine   │
                                 │  sig_token   │
                                 └──────┬───────┘
                                        │
                                        ↓ Connected via EngineBridge
                                 ┌──────────────┐
                                 │ EngineBridge │
                                 │  sig_token   │──┐ Generation-gated
                                 └──────────────┘  │
                                                   ↓ Only if _active_gid matches
                                            ┌──────────────┐
                                            │  MonoGuard   │
                                            │  sig_token   │──┐ Verbatim re-emit
                                            └──────────────┘  │
                                                              ↓ Connected in builtin.py
                                                       ┌──────────────┐
                                                       │  PageChat    │
                                                       │  .append_    │
                                                       │   token()    │
                                                       └──────────────┘
                                                              │
                                                              ↓ Accumulates tokens
                                                        [Display in UI]
```

### Key Signal Chains

#### 1. SEND Signal Chain (User → Kernel → Engine)
```
PageChat.sig_generate
  → builtin.terminal_factory lambda
    → MonoBridge.submit(Task)
      → MonoDock.enqueue(Task)
        → MonoDock._try_submit()
          → MonoGuard.submit(Task)
            → engine.generate(payload)
```

#### 2. TOKEN Signal Chain (Engine → Kernel → UI)
```
GeneratorWorker.token.emit(str)
  → LLMEngine.sig_token
    → EngineBridge.sig_token (gated)
      → MonoGuard.sig_token (verbatim)
        → PageChat.append_token()
```

#### 3. STATUS Signal Chain (Engine → Kernel → UI)
```
LLMEngine.set_status(SystemStatus)
  → LLMEngine.sig_status.emit(status)
    → EngineBridge.sig_status
      → MonoGuard.sig_status
        → MonolithUI.update_status()
        → PageChat.update_status()
```

#### 4. STOP Signal Chain (UI → Kernel → Engine)
```
PageChat.sig_stop
  → builtin.terminal_factory lambda
    → MonoBridge.stop("llm")
      → MonoDock.on_stop("llm")
        → MonoGuard.stop("llm")
          → engine.stop_generation()
            → GeneratorWorker.requestInterruption()
```

---

## MONOKERNEL CONTRACT (v2)

> Note: The authoritative contract is `monokernel/Kernel_Contract_v2.txt`.


### Purpose (Non-Negotiable)
MonoGuard is the **sole authority** between UI and engines. Its role is **arbitration, not computation**.

### Authority Rules

#### 1.1 Single Ingress
- All user commands affecting execution **MUST** pass through MonoGuard
- UI **MUST NOT** call engine methods directly
- Addons **MUST NOT** call engine methods directly

#### 1.2 Single Egress
- All execution state, tokens, traces, usage metrics **MUST** pass through MonoGuard
- UI **MUST NOT** subscribe to engine signals directly
- Engines **MUST NEVER** emit directly to UI

### Kernel Scope

**The kernel MAY:**
- Route commands
- Gate execution by system state
- Preempt execution via STOP
- Queue at most one pending command
- Re-emit engine signals verbatim
- Observe system state transitions

**The kernel MUST NOT:**
- Execute business logic
- Perform blocking operations
- Sleep, wait, or poll
- Contain UI logic
- Contain engine logic
- Know what "chat", "LLM", or "RAG" is
- Accumulate feature-specific state

### STOP Semantics (Hard Law)

#### 3.1 STOP Always Wins
When STOP is issued:
- Current execution is interrupted immediately (non-blocking)
- Any pending command is cleared
- Control returns to UI instantly

#### 3.2 Truthful State
`SystemStatus.READY` **MUST** only be emitted when:
- No execution is running
- No engine work is active
- No pending command is executing

The kernel **must never emit READY prematurely**.

### Pending Command Rule

#### 4.1 Single Pending Slot
- Kernel may hold **at most one** pending command
- Pending commands exist **only** to resume after STOP-based preemption

#### 4.2 Replay on READY
- Pending command may execute once when system transitions to READY
- Pending commands are discarded if STOP is explicitly invoked
- No scheduling, prioritization, or batching exists in v1

### Engine Isolation
The engine:
- Is execution-only
- Knows nothing about UI
- Knows nothing about kernel rules
- Knows nothing about addons
- Accepts commands and emits signals **only**

**The kernel adapts the engine; the engine never adapts to the kernel.**

### UI Restrictions
The UI:
- May emit commands freely
- **MUST NOT** assume commands will execute
- **MUST NOT** block waiting for execution
- **MUST** treat kernel signals as authoritative truth

**UI correctness depends on kernel truth, not intent.**

---

## ENGINE ARCHITECTURE

### EnginePort Protocol
All engines implement this protocol (defined in `engine/base.py`):

```python
@runtime_checkable
class EnginePort(Protocol):
    # Required signals
    sig_status: Signal  # SystemStatus transitions
    sig_trace: Signal   # Debug/status messages
    sig_token: Signal   # Text output stream
    
    # Required methods
    def set_model_path(self, payload: dict) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...
```

**Optional signals** (check with `hasattr` before use):
- `sig_usage`: Token/step count tracking (LLM-specific)
- `sig_image`: Image output (Vision engines)
- `sig_audio`: Audio output (Audio engines)
- `sig_finished`: Optional completion notification

### EngineBridge Pattern

**Purpose**: Generation gating to prevent signals from stale generations reaching the UI.

**Mechanism**:
```python
# Each generate() call gets a unique generation ID
self._gen_id += 1
gid = self._gen_id
self._active_gid = gid
self._connect_gated_handlers(gid)

# Signals only emit if gid matches _active_gid
lambda t, gid=gid: self.sig_token.emit(t) if self._active_gid == gid else None
```

**Result**: When `stop_generation()` is called, the generation ID increments, and all signals from the previous generation are automatically ignored.

### Engine Implementations

#### LLMEngine (`engine/llm.py`)
**State Machine**:
```
READY → set_model_path() → READY
READY → load_model() → LOADING → READY | ERROR
READY → generate() → RUNNING → READY | ERROR
RUNNING → stop_generation() → READY
READY → unload_model() → UNLOADING → READY
```

**Worker Threads**:
- `ModelLoader`: Loads GGUF via llama-cpp-python
- `GeneratorWorker`: Streaming inference with interruption support

**Conversation Management**:
- Maintains `conversation_history: list[dict]` with roles: system, user, assistant
- System prompt injection: `[{role: system, content: prompt}, {role: system, content: CONTEXT: ...}, ...]`
- Pending user index tracking for UPDATE semantics

#### VisionEngine (`engine/vision.py`)
**State Machine**: Same as LLMEngine

**Worker Threads**:
- `PipelineLoader`: Loads Stable Diffusion via diffusers
- `GenerationWorker`: Step-based image generation with callbacks

**Signals**:
- `sig_image`: Emits PIL Image objects
- `sig_trace`: Step progress messages
- No `sig_token` (not text-based)

---

## ADDON SYSTEM

### Addon Types

**Two kinds**:
1. **Page addons** (`kind="page"`): Full-screen views in main content area
2. **Module addons** (`kind="module"`): Stackable floating modules with icons in module strip

### AddonSpec
```python
@dataclass(frozen=True)
class AddonSpec:
    id: str                                    # Unique identifier
    kind: Literal["page", "module"]           # Addon type
    title: str                                # Display name
    icon: str | None                          # Unicode icon or None
    factory: Callable[[AddonContext], QWidget] # Widget constructor
```

### AddonContext (Dependency Injection)
```python
@dataclass
class AddonContext:
    state: AppState        # Shared application state
    guard: MonoGuard       # Kernel signal router
    bridge: MonoBridge     # Task submission API
    ui: MonolithUI | None  # Main window (for modules)
    host: AddonHost | None # Addon lifecycle manager
```

### Addon Lifecycle

#### Page Addon
```python
# Mounted once, lives forever
def addons_page_factory(ctx: AddonContext) -> QWidget:
    w = PageAddons(ctx.state)
    # Wire signals
    return w

# Registration
registry.register(AddonSpec(
    id="addons",
    kind="page",
    title="ADDONS",
    icon=None,
    factory=addons_page_factory
))

# Mounting
host.mount_page("addons")  # Returns cached widget if exists
```

#### Module Addon
```python
# Created fresh each launch, gets unique instance ID
def terminal_factory(ctx: AddonContext) -> QWidget:
    w = PageChat(ctx.state)
    
    # OUTGOING (addon → kernel)
    w.sig_generate.connect(
        lambda prompt: ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "generate", "llm", 
                          payload={"prompt": prompt, "config": w.config})
        )
    )
    w.sig_stop.connect(lambda: ctx.bridge.stop("llm"))
    
    # INCOMING (kernel → addon)
    ctx.guard.sig_token.connect(w.append_token)
    ctx.guard.sig_trace.connect(w.append_trace)
    ctx.guard.sig_status.connect(w.update_status)
    
    return w

# Registration
registry.register(AddonSpec(
    id="terminal",
    kind="module",
    title="TERMINAL",
    icon="⌖",
    factory=terminal_factory
))

# Launching
instance_id = host.launch_module("terminal")  # Creates new instance
```

### Signal Wiring Pattern

**Critical**: Addon factories are responsible for **all signal wiring** between:
- Addon widgets and MonoBridge (outgoing commands)
- MonoGuard and addon widgets (incoming signals)

**Why**: Keeps wiring logic co-located with addon definition, making signal flows explicit.

---

## TASK QUEUE SYSTEM

### Task Structure
```python
@dataclass
class Task:
    id: UUID              # Unique task identifier
    addon_pid: str        # Addon instance that created task
    target: str           # Engine key ("llm", "vision", etc.)
    command: str          # Command verb ("generate", "load", etc.)
    payload: dict         # Command-specific data
    priority: int         # 1=STOP, 2=normal, 3+=low priority
    status: TaskStatus    # PENDING/RUNNING/DONE/FAILED/CANCELLED
    timestamp: float      # Creation time
```

### Task Priority System
- **Priority 1**: STOP commands (preempt everything)
- **Priority 2**: Normal commands (FIFO within priority)
- **Priority 3+**: Low priority (future use)

### MonoDock Queue Behavior

**Per-engine queues**:
```python
queues: dict[str, Deque[Task]] = {
    "llm": deque([task1, task2, task3]),
    "vision": deque([task4, task5])
}
```

**Insertion logic** (`_insert_task`):
- Priority 2 tasks: Insert at end of priority-2 group (maintain FIFO within priority)
- Priority 3+ tasks: Append to end of queue
- Priority 1 tasks: Don't queue, immediately call `on_stop()`

**Execution logic** (`_try_submit`):
1. Check if engine has active task (via `MonoGuard.active_tasks`)
2. If busy, wait for `sig_engine_ready` signal
3. When ready, pop front of queue, check if cancelled
4. Submit to `MonoGuard.submit()`, which calls engine method
5. If submission fails, leave task in queue

**Cancellation**:
```python
cancelled_task_ids: set[str]   # Specific task cancellation
cancelled_addons: set[str]     # All tasks from this addon

def _is_cancelled(task: Task) -> bool:
    return (str(task.id) in cancelled_task_ids or 
            task.addon_pid in cancelled_addons)
```

### MonoGuard Task Routing

**Dispatch table**:
```python
ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}
```

**Submission flow**:
```python
def submit(self, task: Task) -> bool:
    engine = self.engines.get(task.target)
    if self.active_tasks[task.target] is not None:
        return False  # Engine busy
    
    self.active_tasks[task.target] = task
    task.status = TaskStatus.RUNNING
    
    method_name = ENGINE_DISPATCH[task.command]
    handler = getattr(engine, method_name)
    handler(task.payload)  # or handler() for no-arg commands
    return True
```

---

## BOOTSTRAP SEQUENCE

### Startup Order (bootstrap.py)
```python
1. QApplication()
2. AppState()
3. LLMEngine(state) + VisionEngine(state)
4. EngineBridge(llm) + EngineBridge(vision)
5. MonoGuard(state, engines)
6. MonoDock(guard)
7. MonoBridge(dock)
8. MonolithUI(state)
9. AddonRegistry + build_builtin_registry()
10. AddonContext(state, guard, bridge, ui, host=None)
11. AddonHost(registry, ctx)
12. ui.attach_host(host)
13. Wire global signals (guard → ui)
14. ui.show()
15. app.exec()
```

### Global Signal Wiring
```python
# System-wide status updates
guard.sig_status.connect(ui.update_status)

# Token usage tracking (LLM only)
guard.sig_usage.connect(ui.update_ctx)

# Shutdown sequence
app.aboutToQuit.connect(guard.stop)
app.aboutToQuit.connect(engine.shutdown)
app.aboutToQuit.connect(vision_engine.shutdown)
```

---

## CRITICAL PATTERNS

### Pattern 1: Generation Gating (EngineBridge)
**Problem**: After `stop_generation()`, stale tokens from cancelled generation still arrive
**Solution**: Generation ID gating
```python
# Old generation (gid=5) emits token after stop (gid=6)
lambda t, gid=5: self.sig_token.emit(t) if self._active_gid == 6 else None
# Result: Signal dropped, UI sees nothing
```

### Pattern 2: Signal Re-emission (MonoGuard)
**Problem**: Kernel must route signals without transforming them
**Solution**: Verbatim re-emit
```python
engine.sig_token.connect(self.sig_token)  # Direct passthrough
```

### Pattern 3: Factory-based Wiring (Addons)
**Problem**: Signal connections need to be explicit and traceable
**Solution**: All wiring happens in addon factory functions
```python
def terminal_factory(ctx):
    w = PageChat(ctx.state)
    # ALL WIRING HERE — visible in one place
    w.sig_generate.connect(lambda p: ctx.bridge.submit(...))
    ctx.guard.sig_token.connect(w.append_token)
    return w
```

### Pattern 4: UPDATE Semantics (Chat)
**Problem**: User types new prompt while generation is running
**Solution**: Tri-state SEND/STOP/UPDATE
```python
if not self._is_running:
    self.send()  # Normal send
elif not txt:
    self.sig_stop.emit()  # STOP button
else:
    self._pending_update_text = txt
    self._awaiting_update_restart = True
    self.sig_stop.emit()
    # On sig_engine_ready, re-submit with UPDATE prompt
```

### Pattern 5: Non-blocking Kernel (MonoGuard)
**Problem**: Kernel must never block
**Solution**: All engine calls are async via QThread
```python
# ✅ CORRECT
worker = GeneratorWorker(...)
worker.start()  # Returns immediately

# ❌ WRONG
result = model.generate(...)  # Blocks kernel!
```

### Pattern 6: Status Truth (MonoGuard)
**Problem**: UI needs reliable state
**Solution**: Kernel is single source of truth
```python
# UI must never assume:
self.send()  # ❌ Assumes execution will happen

# UI must react to signals:
def update_status(self, engine_key, status):
    if status == SystemStatus.READY:
        self.btn_send.setEnabled(True)  # ✅ React to truth
```

---

## IMPLEMENTATION DETAILS

### SystemStatus Enum
```python
class SystemStatus(Enum):
    READY = "READY"         # Engine idle, can accept commands
    LOADING = "LOADING"     # Model loading in progress
    RUNNING = "RUNNING"     # Generation in progress
    ERROR = "ERROR"         # Error occurred (auto-transitions to READY)
    UNLOADING = "UNLOADING" # Model unloading in progress
```

### TaskStatus Enum
```python
class TaskStatus(Enum):
    PENDING = "PENDING"       # Queued, not yet submitted
    RUNNING = "RUNNING"       # Submitted to engine
    DONE = "DONE"             # Completed successfully
    FAILED = "FAILED"         # Error occurred
    CANCELLED = "CANCELLED"   # Explicitly cancelled
```

### Behavior Tag System (LLM Config)
**Location**: `core/llm_config.py`

**Mechanism**: User selects tags → combined prompts injected into system message

```python
TAG_MAP = {
    "concise": "Be extremely concise. Omit pleasantries.",
    "technical": "Assume expert-level technical knowledge.",
    # ... more tags
}

# User selects ["concise", "technical"]
# → System prompt becomes:
# "You are Monolith. Be precise.\n\nBe extremely concise...\n\nAssume expert-level..."
```

### Context Injection (Injector Module)
**Location**: `ui/modules/injector.py`

**Mechanism**: Runtime context dynamically inserted into system messages before generation

```python
# In LLMEngine.generate():
if context_injection:
    self.conversation_history.insert(1, {
        "role": "system",
        "content": f"CONTEXT: {context_injection}"
    })
```

**Use case**: Add file contents, notes, or dynamic data to every generation without modifying system prompt.

### Module Strip (UI Component)
**Location**: `ui/components/module_strip.py`

**Features**:
- Horizontal scrollable icon strip
- Overflow arrows (left/right) when modules exceed width
- Module flashing on `sig_finished` (visual completion notification)
- Click to switch module, close button to remove

**Critical**: Module IDs are UUID strings, not addon IDs (allows multiple instances of same addon)

### Conversation History (LLM)
**Structure**:
```python
[
    {"role": "system", "content": "You are Monolith. Be precise."},
    {"role": "system", "content": "CONTEXT: <injector contents>"},
    {"role": "user", "content": "Hello"},
    {"role": "assistant", "content": "Hi there!"},
    {"role": "user", "content": "How are you?"},
    # ... continues
]
```

**UPDATE semantics**:
- On normal send: append user message, create pending assistant slot
- On stop: remove pending user message if generation didn't complete
- On resume: inject special user message "You were interrupted mid-generation. Continue from: {last_text}"

---

## DEBUGGING SIGNAL FLOWS

### Trace Signal Path
To trace a signal from UI → Kernel → Engine:

1. **Find the UI trigger**
   - Example: `btn_send.clicked` → `handle_send_click()`

2. **Locate the signal emission**
   - Example: `self.sig_generate.emit(txt)`

3. **Find the addon factory wiring**
   - Example: In `terminal_factory()`: `w.sig_generate.connect(lambda p: ctx.bridge.submit(...))`

4. **Trace through MonoBridge/MonoDock**
   - `bridge.submit(task)` → `dock.enqueue(task)` → `dock._try_submit()`

5. **Trace through MonoGuard**
   - `guard.submit(task)` → `engine.generate(payload)`

6. **Trace engine implementation**
   - `LLMEngine.generate()` → `worker.start()`

7. **Trace return signal path**
   - `worker.token.emit()` → `LLMEngine.sig_token` → `EngineBridge.sig_token` → `MonoGuard.sig_token` → `PageChat.append_token()`

### Trace System Status Changes
```
User clicks LOAD MODEL
  → PageChat.toggle_load()
    → sig_load.emit()
      → bridge.submit(wrap("terminal", "load", "llm"))
        → guard.submit(task)
          → engine.load_model()
            → sig_status.emit(LOADING)
              → guard.sig_status.emit("llm", LOADING)
                → ui.update_status("llm", LOADING)
                  → PageChat.update_status("llm", LOADING)
                    → btn_load.setText("LOADING...")

ModelLoader finishes
  → LLMEngine._on_load_success()
    → set_status(READY)
      → sig_status.emit(READY)
        → guard.sig_status.emit("llm", READY)
          → ui.update_status("llm", READY)
            → PageChat.update_status("llm", READY)
              → btn_load.setText("UNLOAD MODEL")
```

---

## EXTENDING MONOLITH

### Adding a New Engine

1. **Implement EnginePort protocol** (`engine/your_engine.py`)
```python
class YourEngine(QObject):
    sig_status = Signal(SystemStatus)
    sig_trace = Signal(str)
    sig_token = Signal(str)
    sig_your_output = Signal(object)  # Optional custom signal
    
    def __init__(self, state: AppState):
        self.state = state
        self._status = SystemStatus.READY
    
    def set_model_path(self, payload: dict) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...
```

2. **Wrap in EngineBridge** (`bootstrap.py`)
```python
your_engine_impl = YourEngine(state)
your_engine = EngineBridge(your_engine_impl)
```

3. **Register with MonoGuard** (`bootstrap.py`)
```python
guard = MonoGuard(state, {
    "llm": engine,
    "vision": vision_engine,
    "your": your_engine,  # Add here
})
```

4. **Wire optional signals** (`monokernel/guard.py` → `__init__`)
```python
if hasattr(engine, "sig_your_output"):
    engine.sig_your_output.connect(self.sig_your_output)
```

5. **Create addon factory** (`ui/addons/builtin.py`)
```python
def your_module_factory(ctx: AddonContext):
    w = YourModuleWidget()
    w.sig_generate.connect(
        lambda prompt: ctx.bridge.submit(
            ctx.bridge.wrap("your_module", "generate", "your", payload={...})
        )
    )
    ctx.guard.sig_your_output.connect(w.on_output)
    return w
```

6. **Register addon**
```python
registry.register(AddonSpec(
    id="your_module",
    kind="module",
    title="YOUR MODULE",
    icon="★",
    factory=your_module_factory
))
```

### Adding a New Addon

1. **Create widget** (`ui/pages/` or `ui/modules/`)
```python
class YourWidget(QWidget):
    sig_action = Signal(str)  # Define outgoing signals
    
    def __init__(self):
        super().__init__()
        # Build UI
    
    def handle_input(self, data):
        # Incoming signal handler
        pass
```

2. **Create factory** (`ui/addons/builtin.py`)
```python
def your_factory(ctx: AddonContext):
    w = YourWidget()
    
    # OUTGOING
    w.sig_action.connect(
        lambda data: ctx.bridge.submit(
            ctx.bridge.wrap("your_addon", "command", "target", payload={...})
        )
    )
    
    # INCOMING
    ctx.guard.sig_some_signal.connect(w.handle_input)
    
    return w
```

3. **Register** (`ui/addons/builtin.py` → `build_builtin_registry()`)
```python
registry.register(AddonSpec(
    id="your_addon",
    kind="module",  # or "page"
    title="YOUR ADDON",
    icon="◆",
    factory=your_factory
))
```

4. **Add launcher** (if module, add to `ui/modules/manager.py`)
```python
btn_your = SkeetButton("YOUR ADDON")
btn_your.clicked.connect(lambda: self.sig_launch_addon.emit("your_addon"))
```

---

## AGENT QUICK REFERENCE

### When implementing UI changes:
- ✅ Emit signals from widgets
- ❌ Don't call kernel/engine methods directly
- ✅ Connect signals in addon factories
- ❌ Don't assume commands will execute

### When implementing engine changes:
- ✅ Follow EnginePort protocol
- ❌ Don't emit UI-specific signals
- ✅ Use QThread for blocking operations
- ❌ Don't know about kernel rules

### When implementing kernel changes:
- ⚠️ **STOP**: Kernel contract is FROZEN (v1)
- ⚠️ Any change requires architectural review
- ✅ If you must: version bump, not patch

### When debugging signal flows:
1. Find UI emission point
2. Locate addon factory wiring
3. Trace through bridge/dock/guard
4. Find engine handler
5. Trace return path backward

### When reading code:
- Signal chains: Follow `.connect()` calls
- Task flow: Start at `MonoBridge.submit()`
- Status changes: Track `sig_status.emit()`
- Generation flow: Start at `engine.generate()`

---

## APPENDIX: FILE LOCATIONS

### Core Contracts
- `monokernel/kernel_contract.md` — Kernel rules (FROZEN)
- `monokernel/Kernel_Contract_v2.txt` — Authoritative kernel contract (v2).
- `engine/base.py` — EnginePort protocol

### Signal Routing
- `monokernel/guard.py` — MonoGuard (signal router)
- `monokernel/dock.py` — MonoDock (task queue)
- `monokernel/bridge.py` — MonoBridge (UI→Kernel API)
- `engine/bridge.py` — EngineBridge (generation gating)

### Engine Implementations
- `engine/llm.py` — LLM engine (llama-cpp-python)
- `engine/vision.py` — Vision engine (diffusers)

### Addon System
- `ui/addons/spec.py` — AddonSpec definition
- `ui/addons/registry.py` — AddonRegistry
- `ui/addons/host.py` — AddonHost (lifecycle)
- `ui/addons/context.py` — AddonContext (DI)
- `ui/addons/builtin.py` — Built-in addon factories + wiring

### UI Components
- `ui/main_window.py` — Main chrome + global signals
- `ui/pages/chat.py` — Chat/Terminal interface
- `ui/modules/sd.py` — Vision module
- `ui/modules/injector.py` — Context injector
- `ui/components/atoms.py` — Basic widgets
- `ui/components/complex.py` — Compound widgets
- `ui/components/module_strip.py` — Module icon strip

### Configuration
- `core/state.py` — AppState + SystemStatus
- `core/task.py` — Task + TaskStatus
- `core/llm_config.py` — LLM config + behavior tags
- `core/style.py` — UI styling constants

### Bootstrap
- `bootstrap.py` — Application entry point
- `main.py` — Thin wrapper around bootstrap

---

## FINAL NOTES FOR AGENTS

**This document captures implicit knowledge that would otherwise require:**
- Reading 15+ files
- Tracing signal chains across 5+ layers
- Understanding frozen contracts vs. extensible systems
- Discovering generation gating patterns
- Mapping task lifecycle through queue system

**Everything is here. No archaeology required.**

**When in doubt:**
1. Check kernel contract (FROZEN)
2. Trace signal chain (this doc)
3. Follow EnginePort protocol
4. Wire in addon factory
5. Test with VITALS pattern (sig_status transitions)

**Remember**: MonoKernel decides WHEN. Engines decide WHAT. UI reacts to truth.



================================================================================
FILE: .\README\Kernel_Contract_v2.txt
================================================================================

MONOLITH KERNEL CONTRACT — v2 (FROZEN)
0. Purpose

The Monolith kernel is a four-layer execution hierarchy:

UI → MonoBridge → MonoDock → MonoGuard → Engines

SIGNAL PASSTHROUGH LAW: Every command string in ENGINE_DISPATCH must have a matching method on EngineBridge. If guard.py dispatches to it, bridge.py must forward it. Violation = silent permanent queue deadlock. When adding any new command: update ENGINE_DISPATCH, add handler on LLMEngine, and add passthrough on EngineBridge. All three or none.
Three flows. No exceptions.

Flow	Direction	Behavior
Commands	Downward	UI → Bridge → Dock → Guard → Engine
State	Upward	Engine → Guard → UI
STOP	Instant	Bypasses queues, executes immediately

All execution-affecting functionality routes around this structure, never into it.

1. Authority Gradient

MonoGuard is the sole authority.

Only MonoGuard may:

Initiate engine execution

Interrupt engine execution

Transition engine state

Emit READY

Clear active work

MonoBridge and MonoDock are non-authoritative. They translate, organize, and route. They do not execute or decide.

2. Component Contracts
2.1 MonoBridge (Translator)

Role: Normalize UI intent into Task submission and control requests.

Interface:


def wrap(source: str, command: str, target: str, **kwargs) -> Task
def submit(task: Task) -> None                  # forwards to MonoDock.enqueue
def cancel(task_id: str) -> None                # forwards to MonoDock.cancel_task
def cancel_addon(addon_pid: str) -> None        # forwards to MonoDock.cancel_addon
def stop(target: str = "all") -> None           # forwards STOP to MonoDock.on_stop


Rules:

Creates Task with unique ID, timestamp, payload, origin metadata

Forwards Tasks to MonoDock (never directly to MonoGuard)

For cancel/stop: forwards requests to MonoDock (does not mutate queued state)

Must not:

Queue tasks

Block

Execute engines

Inspect payload semantics

Mutate MonoDock-owned task state

2.2 MonoDock (Organizer)

Role: Queue, prioritize, cancel, and submit Tasks prior to arbitration.

Interface:


def enqueue(task: Task) -> None
def cancel_task(task_id: str) -> None
def cancel_addon(addon_pid: str) -> None
def on_stop(target: str = "all") -> None


State:

queues: dict[str, deque[Task]]        # per-engine FIFO queues (priority-aware)
cancelled_task_ids: set[str]          # fast cancel filter
cancelled_addons: set[str]            # fast cancel filter (by addon_pid)


Rules:

Maintains per-target priority queues (FIFO within same priority)

Filters cancelled tasks before submission

Submits to MonoGuard via guard.submit(task) only

If guard.submit(task) returns False (engine busy): waits for guard.sig_engine_ready(engine_key) to retry

On STOP:

issues immediate stop to MonoGuard (no queue)

marks queued tasks for that target as cancelled (by id or by target sweep)

May request Guard STOP if a cancelled task is currently active (Dock-driven, not Bridge-driven)

Must not:

Execute engines

Emit state signals

Mutate MonoGuard internals

Synthesize READY

Override or delay STOP

2.3 MonoGuard (Authority)

Role: Final execution arbiter.

Interface:


def submit(task: Task) -> bool        # True if accepted, False if engine busy
def stop(target: str = "all") -> None


State:

engines: dict[str, EnginePort]            # registered engines by key
active_tasks: dict[str, Task | None]      # one active task per engine


Signals:

sig_status: Signal(str, SystemStatus)     # (engine_key, status) — authoritative
sig_engine_ready: Signal(str)             # engine_key — emitted only on truthful READY
sig_token: Signal(str)                    # passthrough from engine
sig_trace: Signal(str)                    # passthrough from engine
sig_image: Signal(object)                 # passthrough from engine (optional)
sig_finished: Signal(str, str)            # (engine_key, task_id) optional convenience


Rules:

Routes by task.target engine key

Does not validate payload semantics (engine’s job)

Re-emits engine signals verbatim

Emits sig_engine_ready(engine_key) only when that engine is truthfully READY

Enforces: one active Task per engine

On STOP(target):

interrupts target engine(s) immediately (non-blocking)

clears relevant active_tasks

emits authoritative status transitions

On engine ERROR:

emits status ERROR

clears active task

transitions back to READY (no stuck states)

Dispatch rule (non-semantic):
MonoGuard must not grow command-specific business logic. It may only perform mechanical dispatch to the target engine.

Canonical pattern:

ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}


MonoGuard performs method lookup and calls the engine; payload interpretation remains engine-specific.

Must not:

Perform business logic

Block or sleep

Inspect payload meaning

Contain UI logic

Accumulate feature-specific state

2.4 Engines (Workers)

Role: Execute work, emit results.

Rules:

Must implement EnginePort protocol

Must not know about MonoBridge, MonoDock, MonoGuard internals, or UI

Must not emit directly to UI

Must support stop_generation() as an interrupt

3. EnginePort Protocol

All engines implement this interface:

@runtime_checkable
class EnginePort(Protocol):
    # Signals
    sig_status: Signal      # SystemStatus
    sig_trace: Signal       # str
    sig_token: Signal       # str (text stream output, optional)
    sig_image: Signal       # object (image output, optional)
    sig_finished: Signal    # () optional

    # Methods
    def set_model_path(self, path: str) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...


Payload interpretation is engine-specific:

LLM reads payload["prompt"], payload["config"]

Vision reads payload["prompt"], payload["steps"], payload["seed"]

MonoGuard does not interpret payload content.

4. Task Model (Canonical)

Each command becomes exactly one Task:

@dataclass
class Task:
    id: UUID                    # unique identifier
    addon_pid: str              # source addon instance
    target: str                 # engine key ("llm", "vision", etc.)
    command: str                # "generate", "load", "unload", "set_path", "stop"
    payload: dict               # command-specific data
    priority: int               # 1=STOP, 2=normal, 3=background
    status: TaskStatus          # PENDING/RUNNING/DONE/FAILED/CANCELLED
    timestamp: float            # creation time


Priority semantics:

Priority	Name	Behavior
1	STOP	Bypasses queues, executes immediately
2	Normal	Standard FIFO
3	Background	Yields to normal priority
5. Cancellation vs STOP

Two distinct operations:

Operation	Scope	Effect
Cancel	Task or addon	Prevents queued execution; active execution may be stopped by Dock→Guard
STOP	Engine or all	Interrupts active execution immediately; clears active task; cancels queued tasks for target

Cancel flow:

UI → Bridge.cancel(task_id)
  → Dock.cancel_task(task_id)
  → Dock filters cancelled tasks on submission
  → If cancelled task is active: Dock calls Guard.stop(task.target)


STOP flow:

UI → Bridge.stop(target)
  → Dock.on_stop(target)
  → Guard.stop(target)
  → Engine.stop_generation()
  → Engine emits sig_status(READY)
  → Guard emits sig_engine_ready(target)
  → Dock submits next non-cancelled task


STOP is idempotent. Repeated calls have no additional effect.

6. Execution Model

Concurrency

Multiple engines may execute concurrently

Only one Task per engine at a time

State truth

MonoGuard is the sole source of execution state

UI subscribes to Guard signals, never Engine signals

READY means: no active task and accepting new work

Error handling

Engine errors emit sig_status(ERROR)

MonoGuard clears the active task and transitions back to READY

No stuck states

7. Stability Guarantees

Breaking any of the following requires a major contract revision:

Single ingress via MonoBridge

Single egress via MonoGuard

STOP dominance — always priority 1, always immediate

Non-blocking MonoGuard — no sleeps, no waits

Engine isolation — engines know nothing about kernel/UI

One active Task per engine

Truthful READY — emitted only when genuinely idle

8. Extension Rules

Does not belong in kernel if:

Feature can be removed without changing MonoGuard

Feature is UI-specific

Feature is engine-specific (model config, output format)

Requires new kernel version if:

MonoGuard behavior must change

New signal flow pattern required

Authority gradient modified

9. Future Compatibility

Process isolation ready:

MonoBridge may become IPC broker

Task model and authority gradient unchanged

Engines may run in separate processes

New engine registration:

Add key to guard.engines dict

Implement EnginePort

No MonoGuard logic changes required

One-Line Summary

The kernel decides when and where — never what.



================================================================================
FILE: .\README\requirement.txt
================================================================================

PySide6>=6.10.0
llama-cpp-python>=0.3.0
audiocraft>=1.3.0
torch>=2.4.0
torchaudio>=2.4.0
diffusers>=0.35.0
transformers>=4.57.0
accelerate>=1.11.0



================================================================================
FILE: .\README\v0.3a_brief.md
================================================================================

MONOLITH v0.3a — HANDOFF BRIEF
================================

For the next agent picking this up. Read kernel_contract_v1.md first. The kernel is frozen — don't touch MonoGuard, MonoDock, or MonoBridge.


WHERE WE ARE (v0.2.1a)
----------------------

Working app. Local LLM chat (GGUF/llama.cpp), Stable Diffusion, AudioCraft. Modular kernel with addon system. Operators save/restore workspace snapshots. Chat UX is polished (text selection, smooth scroll, silent UPDATE mid-gen, title locking).

GitHub: https://github.com/Svnse/Monolith


CURRENT LLM PIPELINE (what exists)
-----------------------------------

Everything happens inside LLMEngine.generate() in one flat method:

    User types → PageChat.sig_generate(prompt, thinking_mode)
        → terminal_factory wraps Task (builtin.py)
        → bridge.submit → dock.enqueue → guard.submit
        → LLMEngine.generate(payload)

Inside generate():
    1. config = payload["config"] or load_config()
    2. system_prompt = MASTER_PROMPT + behavior_tags
    3. Force system_entry at conversation_history[0]
    4. Detect UPDATE via string prefix check (hacky)
    5. Append user message to history (unless UPDATE/ephemeral)
    6. If thinking_mode: append thinking directive at end
    7. Spawn GeneratorWorker thread → stream tokens back through guard → UI

Final message array the LLM sees:
    [system: MASTER_PROMPT + tags]
    [user/assistant history...]
    [user: current message]
    [system: thinking directive — optional]

No pre-processing. No post-processing. No memory. No KV cache management.
Conversation history is in-memory only, resets between sessions.


WHAT v0.3a ADDS
----------------

### 1. LLM Pipeline Stages

Replace the flat generate() assembly with a staged pipeline in core/pipeline.py:

    PRE-PROMPT  → load world model, load memory, resolve UPDATE
    ASSEMBLY    → build message array (master prompt + world model + memory + tags + history + user msg + thinking)
    GENERATION  → llama.cpp streaming (unchanged)
    POST-GEN    → extract new memories, update world model, store history

Pipeline lives in core/, NOT in the engine. Engine receives final messages list — doesn't know about stages. Pipeline runs in terminal_factory BEFORE task submission.

### 2. World Model

Persistent context store across sessions. NOT RAG. A structured JSON doc:

    world_model.json → {identity, facts[], session_summaries[], rules[]}

Injected as [WORLD MODEL] block after MASTER_PROMPT in the ASSEMBLY stage.
POST-GEN stage optionally extracts new facts via ephemeral LLM call (background, non-blocking).
Global per-installation — operators don't snapshot it.
New file: core/world_model.py

### 3. Thinking Mode Fix

Currently boolean — Std and Ext are identical. Change to string: "off" | "std" | "ext"
Each gets a different system directive. ASSEMBLY stage handles it.

### 4. Theme System

Current: hardcoded gold-on-black (#0C0C0C, #D4AF37). No user control.
Add: ui/themes/ directory with ThemeSpec dataclass. New softer default theme. Current theme becomes an option.
Also: UI rename pass — friendlier labels ("How creative" not "Temperature"), readable module labels.

### 5. Cross-Addon Communication (Mailbox)

Addons are currently siloed. Add AddonMailbox in ui/addons/mailbox.py:
- Artifact dataclass (kind, data, source_addon, metadata)
- send(from_mod, to_mod, artifact) / receive(mod_id)
- Enables: drag image from Vision → Terminal, /attach command, /generate routes to Vision

Lives at UI level. Kernel doesn't know about it. Attached to AddonContext.

### 6. Command Router (Task Fan-Out)

One user intent → multiple engine tasks. "Generate a scene with music" → Vision task + Audio task.
Router sits ABOVE kernel. Submits individual tasks through bridge.submit() like any addon.
Kernel still processes one task per engine — unchanged.
The LLM can be the router (ephemeral intent classification call).

### 7. Installer

Standalone install_monolith.py:
- Detect GPU (nvidia-smi)
- Detect Python version
- Create venv
- Install correct torch (CUDA vs CPU)
- Install requirements
- Create launch.bat

NOT a bundled exe. That's a torch+CUDA packaging nightmare for later.

### 8. Addon Creation Protocol

Two paths:
- Vibe-coders: ask the LLM in terminal to create an addon. Protocol doc gets injected as context.
- Technical: use injector module + addon_creation_guide.md

### 9. AddonSpec Evolution

Current: id, kind, title, icon, factory
Add (all optional, defaults preserve backward compat):
- engine_type: "llm" | "vision" | "audio" | None
- accepts/emits: artifact kinds for mailbox routing
- settings_schema: auto-generate settings panel
- version: addon compatibility tracking


KEY FILES TO READ
-----------------

    core/llm_config.py          — MASTER_PROMPT, TAG_MAP, config load/save
    engine/llm.py               — LLMEngine.generate(), GeneratorWorker, conversation history
    ui/addons/builtin.py        — terminal_factory (where sig_generate connects to bridge)
    ui/addons/spec.py           — AddonSpec dataclass
    ui/addons/host.py           — launch_module() lifecycle
    ui/pages/chat.py            — PageChat (most complex UI file, handles everything chat)
    monokernel/guard.py         — MonoGuard (FROZEN — read only)
    monokernel/dock.py          — MonoDock (FROZEN — read only)
    monokernel/bridge.py        — MonoBridge (FROZEN — read only)
    README/LEGACY/kernel_contract_v1.md — the constitution


PRIORITY
--------

    1. Pipeline + World Model    — the differentiator, what nobody else has
    2. Theme + UI rename         — stops scaring away non-dev users
    3. Cross-addon mailbox       — makes modules actually useful together
    4. Installer                 — adoption gate
    5. Addon protocol            — enables community
    6. Command router            — needs mailbox first
    7. AddonSpec evolution        — needs everything above first


THINGS TO WATCH OUT FOR
------------------------

- The kernel contract is FROZEN. If you think you need to modify guard/dock/bridge, you're solving the wrong problem. Build above.
- UPDATE mid-gen detection is currently a string prefix check in generate(). The pipeline should give it a proper flag.
- Conversation history is managed in two places: engine (conversation_history list) and UI (session messages). They can drift. set_history syncs UI→engine but there's no reverse sync.
- EngineBridge has generation gating (_gen_id) that silently drops tokens from cancelled generations. Don't remove this.
- The MASTER_PROMPT says "No persistent memory unless explicitly stored." When world model ships, this line becomes the justification rather than a limitation — the world model IS the explicit store.



================================================================================
FILE: .\README\LEGACY\kernel_contract_v1.md
================================================================================

MONOLITH KERNEL CONTRACT — v1 (FROZEN)
0. Purpose (Non-Negotiable)

The Monolith kernel (MonoGuard) is the sole authority between UI and execution engines.

Its role is arbitration, not computation.

All future functionality must route around the kernel, not into it.

1. Authority Rules

1.1 Single Ingress
All user-initiated commands that affect execution MUST pass through MonoGuard.

UI must not call engine methods directly.

Addons must not call engine methods directly.

1.2 Single Egress
All execution state, tokens, traces, and usage metrics MUST pass through MonoGuard.

UI must not subscribe to engine signals directly.

Engines must never emit directly to UI.

2. Kernel Scope

The kernel MAY:

Route commands

Gate execution by system state

Preempt execution via STOP

Queue at most one pending command

Re-emit engine signals verbatim

Observe system state transitions

The kernel MUST NOT:

Execute business logic

Perform blocking operations

Sleep, wait, or poll

Contain UI logic

Contain engine logic

Know what “chat”, “LLM”, or “RAG” is

Accumulate feature-specific state

3. STOP Semantics (Hard Law)

3.1 STOP Always Wins

When STOP is issued:

Current execution is interrupted immediately (non-blocking)

Any pending command is cleared

Control returns to the UI instantly

3.2 Truthful State

SystemStatus.READY MUST only be emitted when:

No execution is running

No engine work is active

No pending command is executing

The kernel must never emit READY prematurely.

4. Pending Command Rule

4.1 Single Pending Slot

The kernel may hold at most one pending command.

Pending commands exist only to resume after STOP-based preemption.

4.2 Replay on READY

A pending command may execute once when the system transitions to READY.

Pending commands are discarded if STOP is explicitly invoked.

No scheduling, prioritization, or batching exists in v1.

5. Engine Isolation

The engine:

Is execution-only

Knows nothing about UI

Knows nothing about kernel rules

Knows nothing about addons

Accepts commands and emits signals only

The kernel adapts the engine; the engine never adapts to the kernel.

6. UI Restrictions

The UI:

May emit commands freely

Must not assume commands will execute

Must not block waiting for execution

Must treat kernel signals as authoritative truth

UI correctness depends on kernel truth, not intent.

7. Stability Guarantee

Any future change that violates:

Single ingress

Single egress

STOP dominance

Non-blocking kernel behavior

breaks the kernel contract and must be treated as a major architectural change.

8. Extension Rule

If a feature:

Can be removed without breaking the kernel
→ it does not belong in the kernel.

If a feature:

Requires changing kernel behavior
→ it is a kernel version bump, not a feature patch.

9. Freeze Declaration

This kernel contract is considered frozen as of this state.

Future development must build above this boundary unless explicitly redesigning the kernel.

One-Line Summary

The kernel decides when things may happen — never what happens.



================================================================================
FILE: .\ui\bridge.py
================================================================================

from PySide6.QtCore import QObject, Signal


class UIBridge(QObject):
    sig_terminal_header = Signal(str, str, str)
    sig_apply_operator = Signal(dict)
    sig_open_overseer = Signal()
    sig_overseer_viz_toggle = Signal(bool)
    sig_theme_changed = Signal(str)



================================================================================
FILE: .\ui\main_window.py
================================================================================

from typing import Optional

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QFrame, QLabel, QStackedLayout
)
from PySide6.QtCore import Qt, QDateTime, QTimer
from PySide6.QtGui import QMouseEvent

from core.state import SystemStatus, AppState
from ui.bridge import UIBridge
import core.style as _style  # dynamic theme bridge — always read from _style.* for fresh values
from ui.addons.host import AddonHost
from ui.components.atoms import SidebarButton
from ui.components.complex import GradientLine, VitalsWindow, SplitControlBlock
from ui.components.module_strip import ModuleStrip

class MonolithUI(QMainWindow):
    def __init__(self, state: AppState, ui_bridge: UIBridge):
        super().__init__()
        self.state = state
        self.ui_bridge = ui_bridge
        self.vitals_win = None
        self._drag_pos = None
        self._chat_title = "Untitled Chat"
        self._terminal_titles: dict[str, tuple[str, str]] = {}

        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.resize(1100, 700)

        main_widget = QWidget()
        main_widget.setObjectName("MainFrame")
        main_widget.setStyleSheet(f"""
            QWidget {{ background: {_style.BG_MAIN}; }}
            QWidget#MainFrame {{ border: 1px solid {_style.BORDER_LIGHT}; }}
        """)
        self.setCentralWidget(main_widget)

        root_layout = QVBoxLayout(main_widget)
        root_layout.setContentsMargins(1,1,1,1)
        root_layout.setSpacing(0)

        # Top Gradient
        self.gradient_line = GradientLine()
        root_layout.addWidget(self.gradient_line)

        # Top Bar
        self.top_bar = self._build_top_bar()
        root_layout.addWidget(self.top_bar)

        content_layout = QHBoxLayout()
        content_layout.setSpacing(0)

        # --- SIDEBAR ---
        self.sidebar = QFrame()
        self.sidebar.setFixedWidth(70)
        self.sidebar.setStyleSheet(f"background: {_style.BG_SIDEBAR}; border-right: 1px solid {_style.BORDER_SUBTLE};")
        
        sidebar_layout = QVBoxLayout(self.sidebar)
        sidebar_layout.setContentsMargins(5, 15, 5, 15)
        sidebar_layout.setSpacing(10)

        self.module_strip = ModuleStrip()
        self.module_strip.sig_module_selected.connect(self.switch_to_module)
        self.module_strip.sig_module_closed.connect(self.close_module)

        self.btn_hub = SidebarButton("◉", "HOME")
        self.btn_hub.clicked.connect(lambda: self.set_page("hub"))

        self.btn_addons = SidebarButton("＋", "MODULES")
        self.btn_addons.clicked.connect(lambda: self.set_page("addons"))

        sidebar_layout.addWidget(self.module_strip)
        sidebar_layout.addStretch() 
        sidebar_layout.addWidget(self.btn_hub)
        sidebar_layout.addWidget(self.btn_addons)

        content_layout.addWidget(self.sidebar)

        # --- PAGE STACK ---
        self.stack = QStackedLayout()
        self.host: Optional[AddonHost] = None
        self.pages = {}

        self.empty_page = QWidget()
        self.stack.addWidget(self.empty_page)
        self.pages["empty"] = self.empty_page

        self.center_vbox = QVBoxLayout()
        self.center_vbox.addLayout(self.stack)
        content_layout.addLayout(self.center_vbox)

        root_layout.addLayout(content_layout)

        # --- Bottom status bar ---
        bottom_bar = QHBoxLayout()
        bottom_bar.setContentsMargins(0, 0, 8, 2)
        bottom_bar.addStretch()
        self.lbl_status = QLabel("READY")
        self.lbl_status.setStyleSheet(f"color: {_style.FG_PLACEHOLDER}; font-size: 8px; font-weight: bold; background: transparent;")
        bottom_bar.addWidget(self.lbl_status)
        root_layout.addLayout(bottom_bar)

        # --- Time update timer ---
        self._time_timer = QTimer(self)
        self._time_timer.timeout.connect(self._update_time_display)
        self._time_timer.start(60000)

        self.ui_bridge.sig_terminal_header.connect(self.update_terminal_header)

    def attach_host(self, host: AddonHost) -> None:
        self.host = host
        hub = host.mount_page("hub")
        addons = host.mount_page("addons")

        self.stack.addWidget(hub)
        self.pages["hub"] = hub

        self.stack.addWidget(addons)
        self.pages["addons"] = addons

        self.set_page("hub")

    # ---------------- WINDOW BEHAVIOR ----------------

    def mousePressEvent(self, event: QMouseEvent):
        if event.button() == Qt.LeftButton and event.position().y() < 40:
            self._drag_pos = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
            event.accept()

    def mouseMoveEvent(self, event: QMouseEvent):
        if self._drag_pos and event.buttons() == Qt.LeftButton:
            self.move(event.globalPosition().toPoint() - self._drag_pos)
            event.accept()
            
    def mouseReleaseEvent(self, event: QMouseEvent):
        self._drag_pos = None

    # ---------------- MODULE SYSTEM ----------------

    def close_module(self, mod_id):
        current = self.stack.currentWidget()
        target_w = None
        for i in range(self.stack.count()):
            w = self.stack.widget(i)
            if getattr(w, '_mod_id', None) == mod_id:
                target_w = w
                break
        
        if target_w:
            self.stack.removeWidget(target_w)
            target_w.deleteLater()
            
        self.module_strip.remove_module(mod_id)

        if current == target_w:
            remaining = self.module_strip.get_order()
            if remaining:
                self.switch_to_module(remaining[-1])
            else:
                self.set_page("empty")

    def switch_to_module(self, mod_id):
        for i in range(self.stack.count()):
            w = self.stack.widget(i)
            if getattr(w, '_mod_id', None) == mod_id:
                self.stack.setCurrentWidget(w)
                self._update_sidebar_state(module_selection=True)
                self.module_strip.select_module(mod_id)
                self.lbl_monolith.setVisible(True)
                # Only show chat title for terminal modules
                if getattr(w, '_addon_id', None) == "terminal":
                    self.update_terminal_header(mod_id, *self._terminal_titles.get(mod_id, ("Untitled Chat", QDateTime.currentDateTime().toString("ddd • HH:mm"))))
                else:
                    self.lbl_chat_title.hide()
                    self.lbl_chat_time.hide()
                return

    def _update_sidebar_state(self, page_idx=None, module_selection=False):
        self.btn_hub.setChecked(page_idx == "hub" and not module_selection)
        self.btn_addons.setChecked(page_idx == "addons" and not module_selection)
        if not module_selection: self.module_strip.deselect_all()

    def update_status(self, engine_key: str, status: SystemStatus):
        if status == SystemStatus.ERROR:
            self.lbl_status.setStyleSheet(f"color: {_style.FG_ERROR}; font-size: 8px; font-weight: bold; background: transparent;")
        elif status == SystemStatus.LOADING:
            self.lbl_status.setStyleSheet(f"color: {_style.FG_WARN}; font-size: 8px; font-weight: bold; background: transparent;")
        else:
            self.lbl_status.setStyleSheet(f"color: {_style.FG_PLACEHOLDER}; font-size: 8px; font-weight: bold; background: transparent;")
        status_text = status.value if hasattr(status, "value") else str(status)
        if not engine_key.startswith("llm"):
            status_text = f"{engine_key.upper()}: {status_text}"
        self.lbl_status.setText(status_text)

    def update_ctx(self, used):
        self.state.ctx_used = used

    def update_terminal_header(self, mod_id, title, timestamp):
        if mod_id:
            self._terminal_titles[mod_id] = (title or "Untitled Chat", timestamp or QDateTime.currentDateTime().toString("ddd • HH:mm"))

        current = self.stack.currentWidget()
        current_mod = getattr(current, "_mod_id", None) if current is not None else None
        if not current_mod:
            self.lbl_chat_title.clear()
            self.lbl_chat_time.clear()
            self.lbl_chat_title.hide()
            self.lbl_chat_time.hide()
            return

        current_title, current_time = self._terminal_titles.get(
            current_mod,
            ("Untitled Chat", QDateTime.currentDateTime().toString("ddd • HH:mm")),
        )
        if current_mod == mod_id or mod_id == "":
            self.lbl_chat_title.setText(current_title)
            self.lbl_chat_time.setText(current_time)
            self.lbl_chat_title.show()
            self.lbl_chat_time.show()

    def set_page(self, page_id):
        target = self.pages.get(page_id)
        if target:
            self.stack.setCurrentWidget(target)
        self._update_sidebar_state(page_idx=page_id)
        self.lbl_monolith.setVisible(page_id != "hub")
        self.update_terminal_header("", "", "")

    def _update_time_display(self):
        current = self.stack.currentWidget()
        current_mod = getattr(current, "_mod_id", None) if current is not None else None
        if current_mod and getattr(current, "_addon_id", None) == "terminal":
            now = QDateTime.currentDateTime().toString("ddd • HH:mm")
            self.lbl_chat_time.setText(now)
            if current_mod in self._terminal_titles:
                title = self._terminal_titles[current_mod][0]
                self._terminal_titles[current_mod] = (title, now)

    def _build_top_bar(self):
        bar = QFrame()
        bar.setFixedHeight(35)
        bar.setStyleSheet(f"background: {_style.BG_SIDEBAR}; border-bottom: 1px solid {_style.BORDER_SUBTLE};")
        layout = QHBoxLayout(bar)
        layout.setContentsMargins(10, 0, 10, 0)

        self.lbl_monolith = QLabel("MONOLITH")
        self.lbl_monolith.setStyleSheet(
            f"color: {_style.ACCENT_PRIMARY_DARK}; font-size: 14px; font-weight: bold; "
            "letter-spacing: 3px; background: transparent;"
        )
        layout.addWidget(self.lbl_monolith)
        layout.addStretch()

        self.lbl_chat_title = QLabel(self._chat_title)
        self.lbl_chat_title.setStyleSheet(f"color: {_style.FG_TEXT}; font-size: 10px; font-weight: bold;")
        self.lbl_chat_time = QLabel(QDateTime.currentDateTime().toString("ddd • HH:mm"))
        self.lbl_chat_time.setStyleSheet(f"color: {_style.FG_DIM}; font-size: 10px;")
        title_box = QVBoxLayout()
        title_box.setContentsMargins(0, 0, 8, 0)
        title_box.setSpacing(0)
        title_box.addWidget(self.lbl_chat_title, alignment=Qt.AlignRight)
        title_box.addWidget(self.lbl_chat_time, alignment=Qt.AlignRight)
        layout.addLayout(title_box)

        self.win_controls = SplitControlBlock()
        self.win_controls.minClicked.connect(self.showMinimized)
        self.win_controls.maxClicked.connect(self.toggle_maximize)
        self.win_controls.closeClicked.connect(self.close)
        layout.addWidget(self.win_controls)

        return bar

    def toggle_maximize(self):
        self.showNormal() if self.isMaximized() else self.showMaximized()

    def apply_theme_refresh(self):
        """Re-apply all stylesheets after theme change. Rebuilds the entire UI appearance."""
        # Main frame
        main_widget = self.centralWidget()
        if main_widget:
            main_widget.setStyleSheet(f"""
                QWidget {{ background: {_style.BG_MAIN}; }}
                QWidget#MainFrame {{ border: 1px solid {_style.BORDER_LIGHT}; }}
            """)
        # Sidebar
        self.sidebar.setStyleSheet(f"background: {_style.BG_SIDEBAR}; border-right: 1px solid {_style.BORDER_SUBTLE};")
        # Top bar
        self.top_bar.setStyleSheet(f"background: {_style.BG_SIDEBAR}; border-bottom: 1px solid {_style.BORDER_SUBTLE};")
        self.lbl_monolith.setStyleSheet(
            f"color: {_style.ACCENT_PRIMARY_DARK}; font-size: 14px; font-weight: bold; "
            f"letter-spacing: 3px; background: transparent;"
        )
        self.lbl_chat_title.setStyleSheet(f"color: {_style.FG_TEXT}; font-size: 10px; font-weight: bold;")
        self.lbl_chat_time.setStyleSheet(f"color: {_style.FG_DIM}; font-size: 10px;")
        # Status bar
        self.lbl_status.setStyleSheet(
            f"color: {_style.FG_PLACEHOLDER}; font-size: 8px; font-weight: bold; background: transparent;"
        )
        # Gradient line
        self.gradient_line.update()
        # Sidebar buttons — re-apply with current checked state
        self.btn_hub.update_style(self.btn_hub.isChecked())
        self.btn_addons.update_style(self.btn_addons.isChecked())
        # Window control block
        if hasattr(self.win_controls, 'refresh_style'):
            self.win_controls.refresh_style()

    def toggle_vitals(self):
        if not self.vitals_win:
            self.vitals_win = VitalsWindow(self.state, self)
        
        if not self.vitals_win.isVisible():
            self.vitals_win.show()
        else:
            self.vitals_win.close()



================================================================================
FILE: .\ui\overseer.py
================================================================================

from __future__ import annotations

from datetime import datetime

from PySide6.QtCore import QTimer, Qt
from PySide6.QtGui import QCloseEvent, QFont, QColor
from PySide6.QtWidgets import (
    QCheckBox,
    QHBoxLayout,
    QMainWindow,
    QPlainTextEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
    QFrame,
    QLabel,
    QHeaderView,
    QSplitter,
)

from core.overseer_db import OverseerDB
import core.style as _s  # dynamic theme bridge
from monokernel.guard import MonoGuard
from ui.bridge import UIBridge


def _sev_colors():
    """Return severity→color map with fresh theme values."""
    return {
        "ERROR": _s.FG_ERROR,
        "WARNING": _s.FG_WARN,
        "INFO": _s.OVERSEER_FG,
        "DEBUG": _s.FG_DIM,
        "STATUS": _s.ACCENT_PRIMARY,
        "FINISHED": _s.FG_ACCENT,
    }


_FILTER_STYLE_ON = """
    QPushButton {{
        background: {bg};
        border: 1px solid {color};
        color: {color};
        padding: 4px 8px; font-size: 9px; font-weight: bold;
        border-radius: 2px;
    }}
    QPushButton:hover {{ background: {hover_bg}; }}
"""


def _filter_style_off():
    """Return OFF filter style with fresh theme values."""
    return f"""
        QPushButton {{
            background: transparent;
            border: 1px solid {_s.BORDER_SUBTLE};
            color: {_s.BORDER_LIGHT};
            padding: 4px 8px; font-size: 9px; font-weight: bold;
            border-radius: 2px;
        }}
        QPushButton:hover {{ color: {_s.FG_DIM}; border: 1px solid {_s.BORDER_LIGHT}; }}
    """

_RECIPE_PRESETS = {
    "ALL": {"ERROR", "WARNING", "INFO", "DEBUG", "STATUS", "FINISHED"},
    "ERRORS ONLY": {"ERROR"},
    "KERNEL": {"ERROR", "WARNING", "STATUS", "FINISHED"},
    "PERFORMANCE": {"INFO", "FINISHED"},
}


class _SeverityFilter(QPushButton):
    """Toggle button for a log severity level."""

    def __init__(self, label: str, color: str):
        super().__init__(label)
        self._label = label
        self._color = color
        self._active = True
        self.setCheckable(True)
        self.setChecked(True)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedHeight(24)
        self.clicked.connect(self._toggle)
        self._apply_style()

    def _toggle(self):
        self._active = self.isChecked()
        self._apply_style()

    def _apply_style(self):
        if self._active:
            self.setStyleSheet(
                _FILTER_STYLE_ON.format(bg=_s.OVERSEER_BG, color=self._color, hover_bg=_s.BORDER_SUBTLE)
            )
        else:
            self.setStyleSheet(_filter_style_off())

    def is_active(self) -> bool:
        return self._active

    def set_active(self, val: bool):
        self._active = val
        self.setChecked(val)
        self._apply_style()


class ActiveTasksPanel(QWidget):
    def __init__(self) -> None:
        super().__init__()
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        lbl = QLabel("ACTIVE TASKS")
        lbl.setStyleSheet(
            f"color: {_s.OVERSEER_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        layout.addWidget(lbl)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(["TASK", "ENGINE", "STATUS"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.setSelectionMode(QTableWidget.NoSelection)
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setStyleSheet(f"""
            QTableWidget {{
                background: {_s.OVERSEER_BG};
                color: {_s.OVERSEER_FG};
                border: 1px solid {_s.OVERSEER_BORDER};
                gridline-color: {_s.OVERSEER_BORDER};
                font-family: 'Consolas', monospace;
                font-size: 10px;
            }}
            QTableWidget::item {{
                padding: 4px;
                border-bottom: 1px solid {_s.OVERSEER_BORDER};
            }}
            QHeaderView::section {{
                background: {_s.OVERSEER_BG};
                color: {_s.OVERSEER_DIM};
                border: none;
                border-bottom: 1px solid {_s.OVERSEER_BORDER};
                font-size: 9px;
                font-weight: bold;
                padding: 4px;
            }}
        """)
        layout.addWidget(self.table)

    def set_tasks(self, rows: list[tuple[str, str, str]]) -> None:
        self.table.setRowCount(len(rows))
        for idx, (task_id, engine_key, status) in enumerate(rows):
            self.table.setItem(idx, 0, QTableWidgetItem(task_id))
            self.table.setItem(idx, 1, QTableWidgetItem(engine_key))
            item = QTableWidgetItem(status)
            color = _sev_colors().get(status.upper(), _s.OVERSEER_FG)
            item.setForeground(QColor(color))
            self.table.setItem(idx, 2, item)


class OverseerWindow(QMainWindow):
    def __init__(self, guard: MonoGuard, ui_bridge: UIBridge):
        super().__init__()
        self.guard = guard
        self.ui_bridge = ui_bridge
        self.db = OverseerDB()
        self._paused = False
        self._last_task_state: dict[str, tuple[str, str]] = {}
        self._severity_filters: dict[str, _SeverityFilter] = {}

        self.setWindowTitle("MONITOR")
        self.resize(1000, 560)
        self.setStyleSheet(f"background: {_s.OVERSEER_BG};")

        main = QWidget()
        self.setCentralWidget(main)
        main_layout = QVBoxLayout(main)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(8)

        # --- Top bar: title + recipe buttons ---
        top_bar = QHBoxLayout()
        lbl_title = QLabel("⬡ MONITOR")
        lbl_title.setStyleSheet(
            f"color: {_s.OVERSEER_FG}; font-size: 12px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        top_bar.addWidget(lbl_title)
        top_bar.addStretch()

        # Recipe presets
        for recipe_name in _RECIPE_PRESETS:
            btn = QPushButton(recipe_name)
            btn.setCursor(Qt.PointingHandCursor)
            btn.setFixedHeight(22)
            btn.setStyleSheet(f"""
                QPushButton {{
                    background: transparent;
                    border: 1px solid {_s.OVERSEER_BORDER};
                    color: {_s.OVERSEER_DIM};
                    padding: 2px 8px; font-size: 8px; font-weight: bold;
                    border-radius: 2px;
                }}
                QPushButton:hover {{
                    border: 1px solid {_s.OVERSEER_FG};
                    color: {_s.OVERSEER_FG};
                }}
            """)
            btn.clicked.connect(lambda _=False, r=recipe_name: self._apply_recipe(r))
            top_bar.addWidget(btn)

        main_layout.addLayout(top_bar)

        # --- Severity filter row ---
        filter_row = QHBoxLayout()
        filter_row.setSpacing(4)
        for sev, color in _sev_colors().items():
            f = _SeverityFilter(sev, color)
            self._severity_filters[sev] = f
            filter_row.addWidget(f)
        filter_row.addStretch()
        main_layout.addLayout(filter_row)

        # --- Separator ---
        sep = QFrame()
        sep.setFixedHeight(1)
        sep.setStyleSheet(f"background: {_s.OVERSEER_BORDER};")
        main_layout.addWidget(sep)

        # --- Content: tasks panel + log display ---
        content_split = QSplitter(Qt.Horizontal)
        content_split.setStyleSheet(f"""
            QSplitter::handle {{ background: {_s.OVERSEER_BORDER}; width: 1px; }}
        """)
        content_split.setChildrenCollapsible(False)

        self.panel = ActiveTasksPanel()
        content_split.addWidget(self.panel)

        # Log display — command prompt style
        log_wrap = QWidget()
        log_layout = QVBoxLayout(log_wrap)
        log_layout.setContentsMargins(0, 0, 0, 0)
        log_layout.setSpacing(4)

        lbl_log = QLabel("EVENT LOG")
        lbl_log.setStyleSheet(
            f"color: {_s.OVERSEER_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        log_layout.addWidget(lbl_log)

        self.log_display = QPlainTextEdit()
        self.log_display.setReadOnly(True)
        self.log_display.setFont(QFont("Consolas", 10))
        self.log_display.setStyleSheet(f"""
            QPlainTextEdit {{
                background: {_s.OVERSEER_BG};
                color: {_s.OVERSEER_FG};
                border: 1px solid {_s.OVERSEER_BORDER};
                selection-background-color: {_s.OVERSEER_DIM};
            }}
            QPlainTextEdit::viewport {{
                background: {_s.OVERSEER_BG};
            }}
        """)
        log_layout.addWidget(self.log_display)
        content_split.addWidget(log_wrap)

        content_split.setStretchFactor(0, 1)
        content_split.setStretchFactor(1, 3)
        content_split.setSizes([250, 700])
        main_layout.addWidget(content_split, 1)

        # --- Bottom controls ---
        controls_layout = QHBoxLayout()
        controls_layout.setSpacing(8)

        ctrl_style = f"""
            QCheckBox {{
                color: {_s.OVERSEER_DIM}; font-size: 9px; font-weight: bold;
                spacing: 4px;
            }}
            QCheckBox::indicator {{
                width: 10px; height: 10px;
                border: 1px solid {_s.OVERSEER_DIM};
                background: {_s.OVERSEER_BG};
                border-radius: 2px;
            }}
            QCheckBox::indicator:checked {{
                background: {_s.OVERSEER_FG};
                border: 1px solid {_s.OVERSEER_FG};
            }}
        """

        self.chk_pause = QCheckBox("PAUSE")
        self.chk_pause.setStyleSheet(ctrl_style)
        self.chk_pause.toggled.connect(self._on_pause_toggled)

        self.btn_clear = QPushButton("CLEAR")
        self.btn_clear.setCursor(Qt.PointingHandCursor)
        self.btn_clear.setFixedHeight(22)
        self.btn_clear.setStyleSheet(f"""
            QPushButton {{
                background: transparent;
                border: 1px solid {_s.OVERSEER_BORDER};
                color: {_s.OVERSEER_DIM};
                padding: 2px 10px; font-size: 9px; font-weight: bold;
                border-radius: 2px;
            }}
            QPushButton:hover {{ border: 1px solid {_s.FG_ERROR}; color: {_s.FG_ERROR}; }}
        """)
        self.btn_clear.clicked.connect(self.log_display.clear)

        self.chk_viz = QCheckBox("VIZTRACER")
        self.chk_viz.setStyleSheet(ctrl_style)
        self.chk_viz.toggled.connect(self.ui_bridge.sig_overseer_viz_toggle.emit)

        controls_layout.addWidget(self.chk_pause)
        controls_layout.addWidget(self.btn_clear)
        controls_layout.addWidget(self.chk_viz)
        controls_layout.addStretch()
        main_layout.addLayout(controls_layout)

        # --- Signal connections ---
        self.guard.sig_trace.connect(lambda _engine_key, msg: self._on_trace(msg))
        self.guard.sig_status.connect(self._on_status)
        self.guard.sig_finished.connect(self._on_finished)

        self._poll_timer = QTimer(self)
        self._poll_timer.setInterval(300)
        self._poll_timer.timeout.connect(self._refresh_active_tasks)
        self._poll_timer.start()

    # ---- Filtering ----

    def _is_severity_visible(self, severity: str) -> bool:
        f = self._severity_filters.get(severity.upper())
        return f.is_active() if f else True

    def _apply_recipe(self, recipe_name: str):
        active = _RECIPE_PRESETS.get(recipe_name, set())
        for sev, filt in self._severity_filters.items():
            filt.set_active(sev in active)

    # ---- Log helpers ----

    def _append_line(self, severity: str, text: str) -> None:
        if self._paused:
            return
        if not self._is_severity_visible(severity):
            return
        color = _sev_colors().get(severity.upper(), _s.OVERSEER_FG)
        self.log_display.appendHtml(
            f'<span style="color:{_s.OVERSEER_DIM}">[{self._now_label()}]</span> '
            f'<span style="color:{color}">[{severity}]</span> '
            f'<span style="color:{_s.OVERSEER_FG}">{text}</span>'
        )

    def _now_label(self) -> str:
        return datetime.now().strftime("%H:%M:%S")

    def _on_pause_toggled(self, checked: bool) -> None:
        self._paused = checked

    # ---- Signal handlers ----

    def _on_trace(self, msg: str) -> None:
        try:
            self.db.log_event("guard", "trace", {"message": msg})
        except RuntimeError:
            return
        self.db.log_event("guard", "trace", {"message": msg})
        sev = "INFO"
        lowered = msg.lower()
        if "error" in lowered:
            sev = "ERROR"
        elif "warn" in lowered:
            sev = "WARNING"
        self._append_line(sev, msg)

    def _on_status(self, engine_key: str, status) -> None:
        status_val = status.value if hasattr(status, "value") else str(status)
        self.db.log_event(engine_key, "status", {"status": status_val})
        self._append_line("STATUS", f"{engine_key} → {status_val}")

    def _on_finished(self, engine_key: str, task_id: str) -> None:
        self.db.log_task(str(task_id), engine_key, "DONE")
        self.db.log_event(engine_key, "finished", {"task_id": str(task_id)})
        self._append_line("FINISHED", f"{engine_key} task={task_id}")

    def _refresh_active_tasks(self) -> None:
        rows = []
        for engine_key, task in self.guard.active_tasks.items():
            if task is None:
                if engine_key in self._last_task_state:
                    prev = self._last_task_state.pop(engine_key)
                    self.db.log_task(prev[0], engine_key, "CLEARED")
                continue
            status_val = task.status.value if hasattr(task.status, "value") else str(task.status)
            current = (str(task.id), status_val)
            if self._last_task_state.get(engine_key) != current:
                self._last_task_state[engine_key] = current
                self.db.log_task(str(task.id), engine_key, status_val)
            rows.append((str(task.id), engine_key, status_val))
        self.panel.set_tasks(rows)

    def closeEvent(self, event: QCloseEvent) -> None:
        self._poll_timer.stop()
        if getattr(self.guard, "_viztracer", None) is not None:
            self.guard.enable_viztracer(False)
        self.db.close()
        super().closeEvent(event)



================================================================================
FILE: .\ui\addons\builtin.py
================================================================================

import uuid

from ui.addons.context import AddonContext
from ui.addons.registry import AddonRegistry
from ui.addons.spec import AddonSpec
from ui.modules.injector import InjectorWidget
from ui.modules.sd import SDModule
from ui.modules.audiogen import AudioGenModule
from ui.modules.manager import PageAddons
from ui.pages.chat import PageChat
from ui.pages.databank import PageFiles
from ui.pages.hub import PageHub
from core.operators import OperatorManager
from engine.bridge import EngineBridge
from engine.llm import LLMEngine


def terminal_factory(ctx: AddonContext):
    instance_id = str(uuid.uuid4())
    engine_key = f"llm_{instance_id}"

    short_id = instance_id[:8]

    def _trace(msg):
        ctx.guard.sig_trace.emit("system", msg)

    llm_engine = LLMEngine(ctx.state)
    engine_bridge = EngineBridge(llm_engine)
    ctx.guard.register_engine(engine_key, engine_bridge)

    w = PageChat(ctx.state, ctx.ui_bridge)
    w._mod_id = instance_id
    w._engine_key = engine_key
    ctx.ui_bridge.sig_apply_operator.connect(w.apply_operator)
    llm_engine.sig_model_capabilities.connect(w._on_model_capabilities)

    w.sig_set_model_path.connect(
        lambda path: ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "set_path", engine_key, payload={"path": path})
        )
    )
    w.sig_set_ctx_limit.connect(
        lambda limit: None if limit is None else ctx.bridge.submit(
            ctx.bridge.wrap("terminal", "set_ctx_limit", engine_key, payload={"ctx_limit": int(limit)})
        )
    )

    if w.config.get("gguf_path"):
        w.sig_set_model_path.emit(str(w.config.get("gguf_path")))
    w.sig_set_ctx_limit.emit(int(w.config.get("ctx_limit", 8192)))

    # outgoing (addon -> bridge)
    def _on_generate(prompt, thinking_mode):
        try:
            model = w.config.get("gguf_path", "unknown")
            model_name = str(model).rsplit("/", 1)[-1].rsplit("\\", 1)[-1] if model else "none"
            think_label = "think=ON" if thinking_mode else "think=OFF"
            _trace(f"[LLM:{short_id}] generating — {think_label}, model={model_name}, prompt={repr(prompt[:50])}")
            task = ctx.bridge.wrap(
                "terminal",
                "generate",
                engine_key,
                payload={
                    "prompt": prompt,
                    "config": w.config,
                    "thinking_mode": thinking_mode,
                    "ctx_limit": int(w.config.get("ctx_limit", 8192)),
                },
            )
            ctx.bridge.submit(task)
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in generate: {e}")
            import traceback
            traceback.print_exc()

    w.sig_generate.connect(_on_generate)
    w.sig_load.connect(
        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "load", engine_key))
    )
    w.sig_unload.connect(
        lambda: ctx.bridge.submit(ctx.bridge.wrap("terminal", "unload", engine_key))
    )
    def _on_stop():
        try:
            _trace(f"[LLM:{short_id}] stopped — generation halted")
            ctx.bridge.stop(engine_key)
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in stop: {e}")
            import traceback
            traceback.print_exc()

    w.sig_stop.connect(_on_stop)

    def _on_sync_history(history):
        try:
            _trace(f"[LLM:{short_id}] syncing history — {len(history)} messages")
            ctx.bridge.submit(
                ctx.bridge.wrap(
                    "terminal",
                    "set_history",
                    engine_key,
                    payload={"history": history},
                )
            )
        except Exception as e:
            _trace(f"[LLM:{short_id}] EXCEPTION in sync_history: {e}")
            import traceback
            traceback.print_exc()

    w.sig_sync_history.connect(_on_sync_history)
    ctx.guard.sig_status.connect(w.update_status)
    w.sig_debug.connect(lambda msg: ctx.guard.sig_trace.emit(engine_key, msg))
    # incoming (guard -> addon)
    ctx.guard.sig_token.connect(
        lambda ek, t: w.append_token(t) if ek == engine_key else None
    )
    ctx.guard.sig_trace.connect(
        lambda ek, m: w.append_trace(m) if ek == engine_key else None
    )
    ctx.guard.sig_finished.connect(w.on_guard_finished)

    def _cleanup_terminal(*_args):
        ctx.guard.unregister_engine(engine_key)
        engine_bridge.shutdown()

    w.destroyed.connect(_cleanup_terminal)
    return w


def addons_page_factory(ctx: AddonContext):
    w = PageAddons(ctx.state)
    # route launcher directly to host (host must exist)
    assert ctx.host is not None, "AddonHost must exist before addons page wiring"
    w.sig_launch_addon.connect(lambda addon_id: ctx.host.launch_module(addon_id))
    w.sig_open_vitals.connect(lambda: ctx.ui.toggle_vitals() if ctx.ui else None)
    w.sig_open_overseer.connect(ctx.ui_bridge.sig_open_overseer.emit)
    return w



def hub_factory(ctx: AddonContext):
    manager = OperatorManager()

    def _snapshot_workspace():
        """Capture full workspace state: all open modules + terminal config/messages."""
        if not ctx.ui:
            return {}

        modules = []
        module_order = []
        for mod_id in ctx.ui.module_strip.get_order():
            # Find widget by mod_id
            widget = None
            for i in range(ctx.ui.stack.count()):
                w = ctx.ui.stack.widget(i)
                if getattr(w, '_mod_id', None) == mod_id:
                    widget = w
                    break
            if not widget:
                continue

            addon_id = getattr(widget, '_addon_id', None)
            if not addon_id:
                continue

            module_order.append(addon_id)
            entry = {"addon_id": addon_id}

            # For terminals, capture config + chat messages
            if isinstance(widget, PageChat):
                entry["config"] = dict(widget.config)
                session = getattr(widget, '_current_session', None)
                if session:
                    entry["messages"] = list(session.get("messages", []))
                    entry["session_title"] = session.get("title")
                    entry["assistant_tokens"] = session.get("assistant_tokens", 0)

            modules.append(entry)

        ctx.guard.sig_trace.emit("system", f"[OPERATOR] snapshot: {len(modules)} modules")
        return {"modules": modules, "module_order": module_order}

    w = PageHub(config_provider=_snapshot_workspace, operator_manager=manager, ui_bridge=ctx.ui_bridge)

    def _load_operator(name: str):
        ctx.guard.sig_trace.emit("system", f"[OPERATOR] loading '{name}'")
        try:
            operator_data = manager.load_operator(name)
        except Exception as e:
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] failed to load: {e}")
            return

        if not ctx.ui or not ctx.host:
            return

        # --- New format: has "modules" list ---
        if "modules" in operator_data:
            modules = operator_data["modules"]
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] restoring {len(modules)} modules")

            # Close all existing modules
            for mod_id in list(ctx.ui.module_strip.get_order()):
                ctx.ui.close_module(mod_id)

            # Launch each module from snapshot
            first_terminal_mod_id = None
            for entry in modules:
                addon_id = entry.get("addon_id")
                if not addon_id:
                    continue
                new_mod_id = ctx.host.launch_module(addon_id)
                if not new_mod_id:
                    ctx.guard.sig_trace.emit("system", f"[OPERATOR] failed to launch {addon_id}")
                    continue

                # For terminals with saved state, apply config + messages
                if addon_id == "terminal" and "config" in entry:
                    for i in range(ctx.ui.stack.count()):
                        widget = ctx.ui.stack.widget(i)
                        if getattr(widget, '_mod_id', None) == new_mod_id and isinstance(widget, PageChat):
                            widget.apply_operator(entry)
                            break
                    if not first_terminal_mod_id:
                        first_terminal_mod_id = new_mod_id

            # Switch to first terminal
            if first_terminal_mod_id:
                ctx.ui.switch_to_module(first_terminal_mod_id)

        # --- Legacy format: top-level "config" only ---
        else:
            ctx.guard.sig_trace.emit("system", f"[OPERATOR] legacy format for '{name}'")
            target_widget = None
            for i in range(ctx.ui.stack.count()):
                widget = ctx.ui.stack.widget(i)
                if isinstance(widget, PageChat):
                    target_widget = widget
                    break

            if not target_widget:
                ctx.host.launch_module("terminal")
                for i in range(ctx.ui.stack.count()):
                    widget = ctx.ui.stack.widget(i)
                    if isinstance(widget, PageChat):
                        target_widget = widget
                        break

            ctx.ui_bridge.sig_apply_operator.emit(operator_data)

            if target_widget:
                mod_id = getattr(target_widget, "_mod_id", None)
                if mod_id:
                    ctx.ui.switch_to_module(mod_id)

    w.sig_load_operator.connect(_load_operator)
    w.sig_save_operator.connect(lambda name, data: manager.save_operator(name, data))
    return w

def databank_factory(ctx: AddonContext):
    return PageFiles(ctx.state)


def injector_factory(ctx: AddonContext):
    assert ctx.ui is not None, "InjectorWidget requires UI parent"
    return InjectorWidget(ctx.ui)


def sd_factory(ctx: AddonContext):
    return SDModule(ctx.bridge, ctx.guard)


def audiogen_factory(ctx: AddonContext):
    return AudioGenModule()


def build_builtin_registry() -> AddonRegistry:
    registry = AddonRegistry()

    registry.register(
        AddonSpec(
            id="terminal",
            kind="module",
            title="CHAT",
            icon="⌖",
            factory=terminal_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="databank",
            kind="module",
            title="FILES",
            icon="▤",
            factory=databank_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="hub",
            kind="page",
            title="HOME",
            icon=None,
            factory=hub_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="addons",
            kind="page",
            title="MODULES",
            icon=None,
            factory=addons_page_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="injector",
            kind="module",
            title="RUNTIME",
            icon="💉",
            factory=injector_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="sd",
            kind="module",
            title="VISION",
            icon="⟡",
            factory=sd_factory,
        )
    )
    registry.register(
        AddonSpec(
            id="audiogen",
            kind="module",
            title="AUDIO",
            icon="♫",
            factory=audiogen_factory,
        )
    )

    return registry



================================================================================
FILE: .\ui\addons\context.py
================================================================================

from dataclasses import dataclass
from typing import Optional, TYPE_CHECKING

from core.state import AppState
from monokernel.bridge import MonoBridge
from monokernel.guard import MonoGuard
from ui.bridge import UIBridge

if TYPE_CHECKING:
    from ui.addons.host import AddonHost
    from ui.main_window import MonolithUI


@dataclass
class AddonContext:
    state: AppState
    guard: MonoGuard
    bridge: MonoBridge
    ui: Optional["MonolithUI"]
    host: Optional["AddonHost"]
    ui_bridge: UIBridge



================================================================================
FILE: .\ui\addons\host.py
================================================================================

import uuid
from typing import Dict, Optional

from PySide6.QtWidgets import QWidget

from ui.addons.context import AddonContext
from ui.addons.registry import AddonRegistry


class AddonHost:
    def __init__(self, registry: AddonRegistry, ctx: AddonContext):
        self.registry = registry
        self.ctx = ctx
        self.ctx.host = self
        self._pages: Dict[str, QWidget] = {}

    def mount_page(self, addon_id: str) -> QWidget:
        if addon_id in self._pages:
            return self._pages[addon_id]

        spec = self.registry.get(addon_id)
        if spec.kind != "page":
            raise ValueError(f"Addon '{addon_id}' is not a page")
        widget = spec.factory(self.ctx)
        self._pages[addon_id] = widget
        return widget

    def get_page_widget(self, addon_id: str) -> Optional[QWidget]:
        return self._pages.get(addon_id)

    def launch_module(self, addon_id: str) -> str:
        if not self.ctx.ui:
            raise RuntimeError("AddonHost requires UI for launching modules")

        try:
            spec = self.registry.get(addon_id)
            if spec.kind != "module":
                raise ValueError(f"Addon '{addon_id}' is not a module")
            instance_id = str(uuid.uuid4())
            widget = spec.factory(self.ctx)
        except Exception as e:
            self.ctx.guard.sig_trace.emit("system", f"<span style='color:red'>ADDON ERROR: {e}</span>")
            return ""

        widget._addon_id = addon_id
        if not hasattr(widget, "_mod_id"):
            widget._mod_id = instance_id
        else:
            instance_id = widget._mod_id
        added_stack = False
        added_strip = False
        try:
            self.ctx.ui.stack.addWidget(widget)
            added_stack = True
            self.ctx.ui.module_strip.add_module(instance_id, spec.icon or "?", spec.title)
            added_strip = True
        except Exception:
            if added_strip:
                self.ctx.ui.module_strip.remove_module(instance_id)
            if added_stack:
                self.ctx.ui.stack.removeWidget(widget)
            widget.deleteLater()
            return ""

        if hasattr(widget, "sig_closed"):
            widget.sig_closed.connect(lambda: self.ctx.ui.close_module(instance_id))
        if hasattr(widget, "sig_finished"):
            widget.sig_finished.connect(lambda: self.ctx.ui.module_strip.flash_module(instance_id))

        self.ctx.ui.switch_to_module(instance_id)
        return instance_id



================================================================================
FILE: .\ui\addons\registry.py
================================================================================

from typing import Dict, Iterable

from ui.addons.spec import AddonSpec


class AddonRegistry:
    def __init__(self):
        self._specs: Dict[str, AddonSpec] = {}

    def register(self, spec: AddonSpec) -> None:
        self._specs[spec.id] = spec

    def get(self, addon_id: str) -> AddonSpec:
        if addon_id not in self._specs:
            raise KeyError(f"Addon '{addon_id}' not found. Known addons: {list(self._specs.keys())}")
        return self._specs[addon_id]

    def all(self) -> Iterable[AddonSpec]:
        return self._specs.values()



================================================================================
FILE: .\ui\addons\spec.py
================================================================================

from dataclasses import dataclass
from typing import Callable, Literal

from PySide6.QtWidgets import QWidget

from ui.addons.context import AddonContext

AddonKind = Literal["page", "module"]


@dataclass(frozen=True)
class AddonSpec:
    id: str
    kind: AddonKind
    title: str
    icon: str | None
    factory: Callable[[AddonContext], QWidget]



================================================================================
FILE: .\ui\addons\__init__.py
================================================================================




================================================================================
FILE: .\ui\addons\configs\llm_config.json
================================================================================

{
  "gguf_path": null,
  "temp": 0.7,
  "top_p": 0.9,
  "max_tokens": 2048,
  "ctx_limit": 8192,
  "system_prompt": "You are Monolith. Be precise.",
  "context_injection": ""
}



================================================================================
FILE: .\ui\components\atoms.py
================================================================================

from PySide6.QtWidgets import (
    QWidget, QFrame, QLabel, QSlider, QHBoxLayout,
    QPushButton, QScrollArea, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QPropertyAnimation, QEasingCurve
from PySide6.QtGui import QDragEnterEvent

# ======================
# HELPER
# ======================
def import_vbox(widget, l=15, t=25, r=15, b=15):
    from PySide6.QtWidgets import QVBoxLayout
    v = QVBoxLayout(widget)
    v.setContentsMargins(l, t, r, b)
    v.setSpacing(10)
    return v

# ======================
# BASIC UI PRIMITIVES
# All components read from core.style dynamically
# so theme changes take effect on next widget creation.
# ======================

class MonoGroupBox(QFrame):
    def __init__(self, title, parent=None):
        super().__init__(parent)
        self.layout_main = import_vbox(self)
        self.lbl_title = QLabel(title, self)
        self.lbl_title.move(10, -3)
        self.refresh_style()

    def refresh_style(self):
        import core.style as s
        self.setStyleSheet(f"""
            MonoGroupBox {{
                background: {s.BG_GROUP};
                border: 1px solid {s.BORDER_DARK};
                margin-top: 10px;
            }}
        """)
        self.lbl_title.setStyleSheet(f"""
            color: {s.FG_TEXT};
            font-weight: bold; font-size: 11px;
            background: {s.BG_GROUP}; padding: 0 4px;
        """)
        self.lbl_title.adjustSize()

    def add_widget(self, widget):
        self.layout_main.addWidget(widget)

    def add_layout(self, layout):
        self.layout_main.addLayout(layout)

class MonoButton(QPushButton):
    def __init__(self, text, accent=False):
        super().__init__(text)
        self._accent = accent
        self.setCursor(Qt.PointingHandCursor)
        self.refresh_style()

    def refresh_style(self):
        import core.style as s
        col = s.FG_ACCENT if self._accent else s.FG_TEXT
        self.setStyleSheet(f"""
            QPushButton {{ background: {s.BG_BUTTON}; border: 1px solid {s.BORDER_LIGHT}; color: {s.FG_DIM}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
            QPushButton:hover {{ background: {s.BG_BUTTON_HOVER}; color: {col}; border: 1px solid {col}; }}
            QPushButton:checked {{ background: {s.BG_BUTTON_HOVER}; color: {col}; border: 1px solid {col}; }}
            QPushButton:pressed {{ background: {s.BG_BUTTON_PRESSED}; color: {col}; border: 1px solid {col}; }}
            QPushButton:disabled {{ background: {s.BG_BUTTON_DISABLED}; color: {s.BORDER_LIGHT}; border: 1px solid {s.BORDER_SUBTLE}; }}
        """)

class MonoTriangleButton(QPushButton):
    def __init__(self, text):
        super().__init__(text)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(18, 18)
        self.setFocusPolicy(Qt.NoFocus)
        self.refresh_style()

    def refresh_style(self):
        import core.style as s
        self.setStyleSheet(f"""
            QPushButton {{
                background: {s.BG_BUTTON}; border: 1px solid {s.BORDER_LIGHT}; color: {s.FG_TEXT};
                padding: 0; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:hover {{ background: {s.BG_BUTTON_HOVER}; color: {s.ACCENT_PRIMARY}; border: 1px solid {s.ACCENT_PRIMARY}; }}
            QPushButton:disabled {{ background: {s.BG_BUTTON_DISABLED}; color: {s.BORDER_LIGHT}; border: 1px solid {s.BORDER_SUBTLE}; }}
        """)

class MonoSlider(QWidget):
    valueChanged = Signal(float)
    def __init__(self, label, min_v, max_v, init_v, is_int=False):
        super().__init__()
        self.is_int = is_int
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        self.lbl = QLabel(label)
        val_str = str(int(init_v) if is_int else f"{init_v:.2f}")
        self.val_lbl = QLabel(val_str)
        self.val_lbl.setFixedWidth(40)
        self.val_lbl.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.slider = QSlider(Qt.Horizontal)
        if is_int:
            self.slider.setRange(int(min_v), int(max_v))
            self.slider.setValue(int(init_v))
        else:
            self.slider.setRange(int(min_v*100), int(max_v*100))
            self.slider.setValue(int(init_v*100))
        self.slider.valueChanged.connect(self._on_change)
        layout.addWidget(self.lbl)
        layout.addWidget(self.slider)
        layout.addWidget(self.val_lbl)
        self.refresh_style()

    def refresh_style(self):
        import core.style as s
        self.lbl.setStyleSheet(f"color: {s.FG_DIM}; font-size: 11px;")
        self.val_lbl.setStyleSheet(f"color: {s.FG_TEXT}; font-size: 11px; font-weight: bold;")
        self.slider.setStyleSheet(f"""
            QSlider::groove:horizontal {{ height: 4px; background: {s.BG_BUTTON_HOVER}; border-radius: 2px; }}
            QSlider::handle:horizontal {{ background: {s.ACCENT_PRIMARY}; width: 8px; margin: -2px 0; border-radius: 4px; }}
            QSlider::handle:horizontal:hover {{ background: {s.ACCENT_PRIMARY}; }}
            QSlider::sub-page:horizontal {{ background: {s.FG_TEXT}; border-radius: 2px; }}
        """)
    def _on_change(self, val):
        real_val = val if self.is_int else val / 100.0
        val_str = str(int(real_val) if self.is_int else f"{real_val:.2f}")
        self.val_lbl.setText(val_str)
        self.valueChanged.emit(float(real_val))

class SidebarButton(QPushButton):
    def __init__(self, icon_char, text, checkable=True):
        super().__init__()
        import core.style as s
        self.setCheckable(checkable)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(60, 45) # Shorter height
        if checkable: self.setAutoExclusive(False)
        self.setAcceptDrops(True)

        # Text Only Layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)

        self.lbl_text = QLabel(text)
        self.lbl_text.setAlignment(Qt.AlignCenter)
        self.lbl_text.setStyleSheet(f"color: {s.FG_DIM}; font-size: 9px; font-weight: bold;")

        layout.addWidget(self.lbl_text)
        self.update_style(False)

    def nextCheckState(self): pass

    def setChecked(self, checked):
        super().setChecked(checked)
        self.update_style(checked)

    def update_style(self, checked):
        import core.style as s
        color = s.ACCENT_PRIMARY if checked else s.FG_DIM
        bg = f"{s.BORDER_SUBTLE}" if checked else "transparent"
        # Pure text style, no icon char
        self.lbl_text.setStyleSheet(f"color: {color}; background: transparent; font-size: 10px; font-weight: bold;")
        # Add a left border indicator for active state
        border = f"border-left: 2px solid {s.ACCENT_PRIMARY};" if checked else "border: none;"
        self.setStyleSheet(f"background: {bg}; {border}")

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasUrls(): event.accept()
        else: event.ignore()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls(): event.accept()

class CollapsibleSection(QWidget):
    def __init__(self, title="", parent=None):
        super().__init__(parent)
        self.layout_main = import_vbox(self, 0, 0, 0, 0)
        self.layout_main.setSpacing(0)
        self.btn_toggle = QPushButton(title)
        self.btn_toggle.setCheckable(True)
        self.btn_toggle.setChecked(False)
        self.btn_toggle.clicked.connect(self.toggle_animation)
        self.layout_main.addWidget(self.btn_toggle)
        self.content_area = QScrollArea()
        self.content_area.setMaximumHeight(0)
        self.content_area.setMinimumHeight(0)
        self.content_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.content_area.setFrameShape(QFrame.NoFrame)
        self.content_area.setWidgetResizable(True)
        self.content_area.setStyleSheet("background: transparent;")
        self.layout_main.addWidget(self.content_area)
        self.anim = QPropertyAnimation(self.content_area, b"maximumHeight")
        self.anim.setDuration(300)
        self.anim.setEasingCurve(QEasingCurve.InOutQuad)
        self.refresh_style()

    def refresh_style(self):
        import core.style as s
        self.btn_toggle.setStyleSheet(f"""
            QPushButton {{
                color: {s.FG_DIM}; background: transparent;
                border: none; text-align: left; font-weight: bold; font-size: 10px;
            }}
            QPushButton:checked {{ color: {s.ACCENT_PRIMARY}; }}
            QPushButton:hover {{ color: {s.FG_TEXT}; }}
        """)

    def set_content_layout(self, layout):
        w = QWidget()
        w.setLayout(layout)
        self.content_area.setWidget(w)

    def toggle_animation(self):
        checked = self.btn_toggle.isChecked()
        content_height = self.content_area.widget().layout().sizeHint().height() if self.content_area.widget() else 100
        self.anim.setStartValue(0 if checked else content_height)
        self.anim.setEndValue(content_height if checked else 0)
        self.anim.start()



================================================================================
FILE: .\ui\components\complex.py
================================================================================

import math
import re
from PySide6.QtWidgets import (
    QWidget, QFrame, QLabel, QDialog, QHBoxLayout, QVBoxLayout,
    QPushButton, QProgressBar, QGridLayout, QLineEdit
)
from PySide6.QtCore import Qt, QTimer, Signal, QRectF
from PySide6.QtGui import (
    QPainter, QPen, QColor, QLinearGradient, QFont, QPainterPath, QFontMetrics
)

import core.style as _s  # dynamic theme bridge — always read fresh via _s.*

# ======================
# FLAME LABEL (FIXED)
# ======================
class FlameLabel(QWidget):
    def __init__(self, text, parent=None):
        super().__init__(parent)
        self._text = text
        self.phase = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._animate)
        self.timer.start(50)
        # Use a thick, bold font for the mask to work well
        self.font_obj = QFont("Segoe UI", 14, QFont.Bold)
        self.setFixedHeight(30)
        self.setFixedWidth(120) 

    def _animate(self):
        # Move the gradient phase
        self.phase -= 0.08
        if self.phase < -1.0: self.phase = 1.0
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 1. Setup Gradient (Fire Effect)
        # The gradient moves vertically based on self.phase
        h = self.height()
        grad = QLinearGradient(0, h + (h * self.phase), 0, -h + (h * self.phase))
        grad.setSpread(QLinearGradient.RepeatSpread)
        
        # Fire Colors: Dark Grey -> Gold -> White -> Dark Grey
        import core.style as _s
        grad.setColorAt(0.0, QColor(_s.GRADIENT_COLOR))
        grad.setColorAt(0.4, QColor(_s.GRADIENT_COLOR))
        grad.setColorAt(0.5, QColor("white"))
        grad.setColorAt(0.6, QColor(_s.GRADIENT_COLOR))
        grad.setColorAt(1.0, QColor(_s.FG_DIM))

        # 2. Create Text Path
        # We convert text to a shape so we can fill it with the gradient
        path = QPainterPath()
        # Center the text vertically
        fm = QFontMetrics(self.font_obj)
        text_w = fm.horizontalAdvance(self._text)
        text_h = fm.ascent()
        x = (self.width() - text_w) / 2
        y = (self.height() + text_h) / 2 - fm.descent()
        
        path.addText(x, y, self.font_obj, self._text)

        # 3. Draw
        painter.setBrush(grad)
        painter.setPen(Qt.NoPen)
        painter.drawPath(path)

# ======================
# VITALS WINDOW (COMPACT)
# ======================
class VitalsWindow(QDialog):
    def __init__(self, state, parent=None):
        super().__init__(parent)
        self.state = state
        self.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        layout = QVBoxLayout(self)
        layout.setSpacing(0)
        layout.setContentsMargins(0,0,0,0)
        
        self.frame = QFrame()
        # Glassmorphic + Ultra Compact
        self.frame.setStyleSheet(f"background: rgba(8, 8, 8, 230); border: 1px solid {_s.ACCENT_PRIMARY}; border-radius: 4px;")
        
        frame_layout = QVBoxLayout(self.frame)
        frame_layout.setSpacing(2) 
        frame_layout.setContentsMargins(6, 6, 6, 6)
        
        # Header
        head = QHBoxLayout()
        lbl = QLabel("SYSTEM VITALS")
        lbl.setStyleSheet(f"color: {_s.ACCENT_PRIMARY}; font-weight: 900; font-size: 9px; border:none; background: transparent;")
        btn_x = QPushButton("×")
        btn_x.setFixedSize(14, 14)
        btn_x.clicked.connect(self.close)
        btn_x.setStyleSheet(f"color: {_s.FG_DIM}; border: none; font-weight: bold; background: transparent; padding:0; margin:0;")
        head.addWidget(lbl)
        head.addStretch()
        head.addWidget(btn_x)
        frame_layout.addLayout(head)
        
        # Bars
        self.bars = {}
        for key in ["VRAM", "CTX", "CPU", "GPU"]:
            row = QHBoxLayout()
            row.setSpacing(4)
            l = QLabel(key)
            l.setStyleSheet(f"color: {_s.FG_DIM}; font-size: 8px; font-weight: bold; border:none; background: transparent;")
            l.setFixedWidth(22)
            
            bar = QProgressBar()
            bar.setFixedHeight(2) # Ultra thin
            bar.setTextVisible(False)
            bar.setStyleSheet(f"""
                QProgressBar {{ background: {_s.BORDER_SUBTLE}; border: none; border-radius: 1px; }}
                QProgressBar::chunk {{ background: {_s.FG_ACCENT}; border-radius: 1px; }}
            """)
            bar.setValue(0)
            self.bars[key] = bar
            
            row.addWidget(l)
            row.addWidget(bar)
            frame_layout.addLayout(row)
            
        layout.addWidget(self.frame)
        
        # Make the window itself small
        self.setFixedSize(140, 90)

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_stats)
        self.timer.start(1000)
        self.old_pos = None

    def update_stats(self):
        if self.state.ctx_limit > 0:
            ctx_p = int((self.state.ctx_used / self.state.ctx_limit) * 100)
            self.bars["CTX"].setValue(ctx_p)
        import random
        base_load = 10 if not self.state.model_loaded else 40
        self.bars["VRAM"].setValue(base_load + random.randint(0, 5))
        self.bars["CPU"].setValue(random.randint(5, 15))
        self.bars["GPU"].setValue(base_load + random.randint(0, 10))
        
    def mousePressEvent(self, e): self.old_pos = e.globalPosition().toPoint()
    def mouseReleaseEvent(self, e): self.old_pos = None
    def mouseMoveEvent(self, e):
        if self.old_pos:
            delta = e.globalPosition().toPoint() - self.old_pos
            self.move(self.pos() + delta)
            self.old_pos = e.globalPosition().toPoint()

# ======================
# MODE SELECTOR (GOLD)
# ======================
class ModeSelector(QWidget):
    modeChanged = Signal(str) # "OPERATOR" or "MONITOR"

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedHeight(60)
        
        layout = QHBoxLayout(self)
        layout.setSpacing(20)
        layout.setContentsMargins(20, 5, 20, 5)
        
        self.btn_op = self._make_box("OPERATOR", True)
        self.btn_ov = self._make_box("MONITOR", False)
        
        layout.addStretch()
        layout.addWidget(self.btn_op)
        layout.addWidget(self.btn_ov)
        layout.addStretch()

    def _make_box(self, title, active):
        btn = QPushButton(title)
        btn.setFixedSize(120, 35)
        btn.setCheckable(True)
        btn.setChecked(active)
        btn.setCursor(Qt.PointingHandCursor)
        self._style_btn(btn, active)
        btn.clicked.connect(lambda: self._select(title))
        return btn

    def _style_btn(self, btn, active):
        # GOLD highlight when active
        border = _s.ACCENT_PRIMARY if active else _s.BORDER_LIGHT
        bg = _s.BORDER_SUBTLE if active else _s.BG_INPUT
        color = _s.ACCENT_PRIMARY if active else _s.FG_DIM
        weight = "bold" if active else "normal"
        
        btn.setStyleSheet(f"""
            QPushButton {{
                background: {bg}; 
                border: 1px solid {border}; 
                color: {color};
                font-family: 'Segoe UI'; font-size: 10px; font-weight: {weight};
                border-radius: 2px;
            }}
            QPushButton:hover {{ border-color: {_s.ACCENT_PRIMARY}; color: {_s.FG_TEXT}; }}
        """)

    def _select(self, mode):
        is_op = (mode == "OPERATOR")
        self.btn_op.setChecked(is_op)
        self.btn_ov.setChecked(not is_op)
        
        self._style_btn(self.btn_op, is_op)
        self._style_btn(self.btn_ov, not is_op)
        
        self.modeChanged.emit(mode)

class GradientLine(QFrame):
    def __init__(self):
        super().__init__()
        self.setFixedHeight(2)
        self.offset = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._step)
        self.timer.start(33) 

    def _step(self):
        self.offset = (self.offset + 0.015) % 1.0
        self.repaint()
    
    def paintEvent(self, event):
        import core.style as _s
        painter = QPainter(self)
        grad = QLinearGradient(0, 0, self.width(), 0)
        c_gold = QColor(_s.GRADIENT_COLOR)
        c_dark = QColor(_s.BG_SIDEBAR)
        grad.setSpread(QLinearGradient.RepeatSpread)
        w = self.width()
        start_x = -self.offset * w
        grad.setStart(start_x, 0)
        grad.setFinalStop(start_x + w, 0)
        grad.setColorAt(0.0, c_dark)
        grad.setColorAt(0.5, c_gold)
        grad.setColorAt(1.0, c_dark)
        painter.fillRect(self.rect(), grad)


class TagLineEdit(QLineEdit):
    backspaceOnEmpty = Signal()

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Backspace and not self.text():
            self.backspaceOnEmpty.emit()
            return
        super().keyPressEvent(event)


class BehaviorTagInput(QFrame):
    tagsChanged = Signal(list)

    def __init__(self, known_tags=None, parent=None):
        super().__init__(parent)
        self._known_tags = {tag.lower() for tag in (known_tags or [])}
        self._tags = []

        self.setStyleSheet(
            f"background: {_s.BG_INPUT}; border: 1px solid {_s.BORDER_LIGHT}; border-radius: 2px;"
        )
        layout = QHBoxLayout(self)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(6)

        self._chip_layout = QHBoxLayout()
        self._chip_layout.setContentsMargins(0, 0, 0, 0)
        self._chip_layout.setSpacing(6)
        layout.addLayout(self._chip_layout)

        self._input = TagLineEdit()
        self._input.setPlaceholderText("Type tags...")
        self._input.setStyleSheet(f"background: transparent; color: {_s.FG_TEXT}; border: none;")
        self._input.textEdited.connect(self._on_text_edited)
        self._input.returnPressed.connect(self._commit_current_text)
        self._input.backspaceOnEmpty.connect(self._remove_last_tag)
        layout.addWidget(self._input, stretch=1)

    def set_tags(self, tags):
        self._clear_tags()
        for tag in tags:
            self._add_tag(tag, emit_signal=False)
        self.tagsChanged.emit(self._tags.copy())

    def tags(self):
        return self._tags.copy()

    def _clear_tags(self):
        while self._chip_layout.count():
            item = self._chip_layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()
        self._tags = []

    def _normalize_tag(self, tag):
        return tag.strip().lower()

    def _add_tag(self, tag, emit_signal=True):
        normalized = self._normalize_tag(tag)
        if not normalized:
            return
        if normalized in self._tags:
            return
        chip = QPushButton(normalized)
        chip.setCursor(Qt.PointingHandCursor)
        chip.setStyleSheet(
            f"""
            QPushButton {{
                background: {_s.BORDER_SUBTLE}; border: 1px solid {_s.BORDER_LIGHT}; color: {_s.FG_TEXT};
                padding: 2px 6px; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:hover {{ color: {_s.ACCENT_PRIMARY}; border: 1px solid {_s.ACCENT_PRIMARY}; }}
            """
        )
        chip.clicked.connect(lambda _, t=normalized: self._remove_tag(t))
        self._chip_layout.addWidget(chip)
        self._tags.append(normalized)
        if emit_signal:
            self.tagsChanged.emit(self._tags.copy())

    def _remove_tag(self, tag):
        if tag not in self._tags:
            return
        self._tags = [t for t in self._tags if t != tag]
        for index in range(self._chip_layout.count() - 1, -1, -1):
            widget = self._chip_layout.itemAt(index).widget()
            if widget and widget.text() == tag:
                self._chip_layout.takeAt(index)
                widget.deleteLater()
                break
        self.tagsChanged.emit(self._tags.copy())

    def _remove_last_tag(self):
        if not self._tags:
            return
        self._remove_tag(self._tags[-1])

    def _commit_current_text(self):
        text = self._input.text()
        if text:
            self._add_tag(text)
        self._input.clear()

    def _on_text_edited(self, text):
        if not text:
            return
        if "," not in text and " " not in text:
            return
        parts = [part for part in re.split(r"[,\s]+", text) if part]
        trailing = ""
        if text and text[-1] not in {",", " "}:
            trailing = parts.pop() if parts else text
        for part in parts:
            self._add_tag(part)
        self._input.blockSignals(True)
        self._input.setText(trailing)
        self._input.blockSignals(False)

class SplitControlBlock(QWidget):
    minClicked = Signal()
    maxClicked = Signal()
    closeClicked = Signal()

    def __init__(self):
        super().__init__()
        self.setFixedSize(45, 34)
        layout = QGridLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(1)
        base_style = f"""
            QPushButton {{
                background: {_s.BORDER_SUBTLE}; border: none; color: {_s.FG_DIM};
                font-family: 'Segoe UI'; font-size: 8px;
            }}
            QPushButton:hover {{ background: {_s.ACCENT_PRIMARY}; color: black; }}
            QPushButton:pressed {{ background: {_s.ACCENT_PRIMARY_DARK}; color: black; }}
        """
        self.btn_min = QPushButton("─")
        self.btn_min.setFixedSize(22, 16) 
        self.btn_min.setStyleSheet(base_style)
        self.btn_min.clicked.connect(self.minClicked)
        
        self.btn_max = QPushButton("□")
        self.btn_max.setFixedSize(22, 16)
        self.btn_max.setStyleSheet(base_style)
        self.btn_max.clicked.connect(self.maxClicked)
        
        self.btn_close = QPushButton("×")
        self.btn_close.setFixedHeight(16)
        self.btn_close.setStyleSheet(f"""
            QPushButton {{
                background: {_s.BORDER_SUBTLE}; border: none; color: {_s.FG_DIM};
                font-family: 'Segoe UI'; font-size: 12px;
            }}
            QPushButton:hover {{ background: {_s.FG_ERROR}; color: white; }}
            QPushButton:pressed {{ background: {_s.FG_ERROR}; color: white; }}
        """)
        self.btn_close.clicked.connect(self.closeClicked)
        layout.addWidget(self.btn_min, 0, 0)
        layout.addWidget(self.btn_max, 0, 1)
        layout.addWidget(self.btn_close, 1, 0, 1, 2)

    def refresh_style(self):
        import core.style as _s
        base_style = f"""
            QPushButton {{
                background: {_s.BORDER_SUBTLE}; border: none; color: {_s.FG_DIM};
                font-family: 'Segoe UI'; font-size: 8px;
            }}
            QPushButton:hover {{ background: {_s.ACCENT_PRIMARY}; color: black; }}
            QPushButton:pressed {{ background: {_s.ACCENT_PRIMARY_DARK}; color: black; }}
        """
        self.btn_min.setStyleSheet(base_style)
        self.btn_max.setStyleSheet(base_style)
        self.btn_close.setStyleSheet(f"""
            QPushButton {{
                background: {_s.BORDER_SUBTLE}; border: none; color: {_s.FG_DIM};
                font-family: 'Segoe UI'; font-size: 12px;
            }}
            QPushButton:hover {{ background: {_s.FG_ERROR}; color: white; }}
            QPushButton:pressed {{ background: {_s.FG_ERROR}; color: white; }}
        """)



================================================================================
FILE: .\ui\components\message_widget.py
================================================================================

from PySide6.QtCore import Qt, QSize, Signal
from PySide6.QtWidgets import QHBoxLayout, QLabel, QPushButton, QSizePolicy, QVBoxLayout, QWidget



class _IconAction(QPushButton):
    """Tiny icon-only action button for message hover bar."""

    def __init__(self, icon_char: str, tooltip: str):
        super().__init__(icon_char)
        import core.style as s
        self.setToolTip(tooltip)
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(22, 22)
        self.setStyleSheet(f"""
            QPushButton {{
                background: transparent;
                color: {s.FG_DIM};
                border: none;
                font-size: 12px;
                padding: 0;
            }}
            QPushButton:hover {{
                color: {s.ACCENT_PRIMARY};
            }}
        """)


class MessageWidget(QWidget):
    sig_delete = Signal(int)
    sig_edit = Signal(int)
    sig_regen = Signal(int)

    def __init__(self, index: int, role: str, text: str, timestamp: str):
        super().__init__()
        import core.style as s
        self._index = index
        self._role = role
        self._content = text or ""

        self.setAttribute(Qt.WA_Hover, True)
        self.setAttribute(Qt.WA_StyledBackground, True)

        is_assistant = role == "assistant"
        is_system = role == "system"
        border_color = s.ACCENT_PRIMARY if is_assistant else s.BORDER_SUBTLE
        if is_system:
            border_color = s.BG_BUTTON_HOVER
        bottom_border = f"1px solid {s.BORDER_SUBTLE}" if is_assistant else "none"

        self.setStyleSheet(f"""
            MessageWidget {{
                background: transparent;
                border-left: 2px solid {border_color};
                border-top: none; border-right: none;
                border-bottom: {bottom_border};
            }}
        """)

        root = QVBoxLayout(self)
        root.setContentsMargins(10, 3, 10, 3 if not is_assistant else 8)
        root.setSpacing(4)

        # --- Header row ---
        head = QHBoxLayout()
        head.setSpacing(6)

        role_color = s.ACCENT_PRIMARY if is_assistant else s.FG_TEXT
        if is_system:
            role_color = s.FG_DIM
        self.lbl_role = QLabel((role or "").upper())
        self.lbl_role.setStyleSheet(
            f"color: {role_color}; font-size: 9px; font-weight: bold; letter-spacing: 1px;"
        )
        head.addWidget(self.lbl_role)

        pretty_ts = (timestamp or "")
        if "T" in pretty_ts and len(pretty_ts) >= 16:
            pretty_ts = pretty_ts[11:16]
        self.lbl_time = QLabel(pretty_ts)
        self.lbl_time.setStyleSheet(f"color: {s.FG_INFO}; font-size: 9px;")
        head.addWidget(self.lbl_time)
        head.addStretch()

        # --- Hover action icons ---
        self.actions = QWidget()
        self.actions.setStyleSheet("background: transparent;")
        actions_layout = QHBoxLayout(self.actions)
        actions_layout.setContentsMargins(0, 0, 0, 0)
        actions_layout.setSpacing(2)

        if not is_system:
            if role == "user":
                self.btn_edit = _IconAction("✎", "Edit")
                self.btn_edit.clicked.connect(lambda: self.sig_edit.emit(self._index))
                actions_layout.addWidget(self.btn_edit)

            if is_assistant:
                self.btn_regen = _IconAction("⟲", "Regenerate")
                self.btn_regen.clicked.connect(lambda: self.sig_regen.emit(self._index))
                actions_layout.addWidget(self.btn_regen)

            self.btn_delete = _IconAction("✕", "Delete")
            self.btn_delete.clicked.connect(lambda: self.sig_delete.emit(self._index))
            actions_layout.addWidget(self.btn_delete)

        self.actions.setVisible(False)
        head.addWidget(self.actions)

        root.addLayout(head)

        # --- Content ---
        self.lbl_content = QLabel()
        self.lbl_content.setTextFormat(Qt.PlainText)
        self.lbl_content.setWordWrap(True)
        self.lbl_content.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
        self.lbl_content.setCursor(Qt.IBeamCursor)
        content_color = s.FG_TEXT if is_assistant else s.FG_SECONDARY
        if is_system:
            content_color = s.FG_DIM
        self.lbl_content.setStyleSheet(
            f"color: {content_color}; font-size: 11px; line-height: 1.4; padding: 2px 0;"
        )
        self.lbl_content.setText(self._content)
        root.addWidget(self.lbl_content)

        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Minimum)

    # ------------------------------------------------------------------
    def sizeHint(self):
        """Compute height that accounts for word-wrapped content label."""
        w = self.width() if self.width() > 50 else 600
        margins = self.layout().contentsMargins()
        content_w = w - margins.left() - margins.right() - 2  # 2px border-left
        # heightForWidth respects word-wrap and font metrics
        content_h = self.lbl_content.heightForWidth(max(content_w, 60))
        if content_h <= 0:
            content_h = self.lbl_content.sizeHint().height()
        header_h = 20  # role label row
        spacing = self.layout().spacing()  # 4
        total = margins.top() + header_h + spacing + content_h + margins.bottom()
        return QSize(w, max(total, 30))

    def enterEvent(self, event):
        self.actions.setVisible(True)
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.actions.setVisible(False)
        super().leaveEvent(event)

    def append_token(self, token: str):
        if not token:
            return
        self._content += token
        self.lbl_content.setText(self._content)

    def finalize(self):
        self.lbl_content.setText(self._content)

    def set_index(self, idx: int):
        self._index = idx



================================================================================
FILE: .\ui\components\module_strip.py
================================================================================

import math
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QScrollArea, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QTimer, QPoint, QEvent, QMimeData
from PySide6.QtGui import QPainter, QColor, QPen, QPolygonF, QDrag

from .atoms import SidebarButton

class OverflowArrow(QWidget):
    clicked = Signal()
    def __init__(self):
        super().__init__()
        self.setFixedHeight(15)
        self.setCursor(Qt.PointingHandCursor)
        self.phase = 0.0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._anim)
        self.timer.start(50)
        
    def _anim(self):
        self.phase += 0.2
        self.update()
        
    def mousePressEvent(self, e): self.clicked.emit()
        
    def paintEvent(self, e):
        import core.style as s
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)
        y_off = math.sin(self.phase) * 2
        c = QColor(s.ACCENT_PRIMARY)
        c.setAlpha(150)
        p.setPen(QPen(c, 1.5))
        p.setBrush(Qt.NoBrush)
        cx = self.width() / 2
        cy = self.height() / 2 + y_off
        path = QPolygonF([QPoint(cx - 4, cy - 2), QPoint(cx, cy + 3), QPoint(cx + 4, cy - 2)])
        p.drawPolyline(path)

class ModuleIcon(SidebarButton):
    sig_close = Signal(str)
    sig_select = Signal(str)

    def __init__(self, mod_id, icon_char, label_text):
        super().__init__(icon_char, label_text, checkable=True)
        self.mod_id = mod_id
        self.code = icon_char
        self.is_pulsing = False
        
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(lambda: self.sig_close.emit(self.mod_id))
        
        self.pulse_phase = 0.0
        self._drag_start_pos = None

    def mousePressEvent(self, e):
        if e.button() == Qt.MiddleButton: self.sig_close.emit(self.mod_id)
        elif e.button() == Qt.LeftButton:
            self._drag_start_pos = e.position().toPoint()
            self.sig_select.emit(self.mod_id)

    def mouseMoveEvent(self, e):
        if not (e.buttons() & Qt.LeftButton) or self._drag_start_pos is None:
            return
        if (e.position().toPoint() - self._drag_start_pos).manhattanLength() < QApplication.startDragDistance():
            return
        drag = QDrag(self)
        mime = QMimeData()
        mime.setData("application/x-monolith-module", self.mod_id.encode())
        drag.setMimeData(mime)
        drag.exec(Qt.MoveAction)

    def set_active(self, val):
        self.setChecked(val)
        if val: self.is_pulsing = False

    def flash(self):
        if not self.isChecked():
            self.is_pulsing = True
            self.pulse_phase = 0.0
            self.update()
            QTimer.singleShot(250, lambda: self.set_pulsing(False))

    def set_pulsing(self, val):
        self.is_pulsing = val
        if val: self.pulse_phase = 0.0
        self.update()

    def paintEvent(self, e):
        super().paintEvent(e)
        if self.is_pulsing and not self.isChecked():
            import core.style as s
            p = QPainter(self)
            p.setRenderHint(QPainter.Antialiasing)
            glow = QColor(s.ACCENT_PRIMARY)
            alpha = int(((math.sin(self.pulse_phase) + 1) / 2) * 50)
            glow.setAlpha(alpha)
            p.fillRect(self.rect(), glow)

class ModuleStrip(QWidget):
    sig_module_selected = Signal(str)
    sig_module_closed = Signal(str)

    def __init__(self):
        super().__init__()
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(0)
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setStyleSheet("background: transparent; border: none;")
        self.content = QWidget()
        self.vbox = QVBoxLayout(self.content)
        self.vbox.setContentsMargins(5, 5, 5, 5)
        self.vbox.setSpacing(5)
        self.vbox.addStretch()
        self.scroll.setWidget(self.content)
        layout.addWidget(self.scroll)
        self.arrow = OverflowArrow()
        self.arrow.clicked.connect(self.scroll_down)
        self.arrow.setVisible(False)
        layout.addWidget(self.arrow)
        self.modules = {}
        self.order = []
        self.content.setAcceptDrops(True)
        self.content.installEventFilter(self)

    def add_module(self, mod_id, icon_char, label_text):
        icon = ModuleIcon(mod_id, icon_char, label_text)
        icon.sig_select.connect(self.sig_module_selected)
        icon.sig_close.connect(self.sig_module_closed)
        self.modules[mod_id] = icon
        self.order.append(mod_id)
        self.vbox.insertWidget(self.vbox.count()-1, icon)
        self._check_overflow()

    def remove_module(self, mod_id):
        if mod_id not in self.modules:
            return
        icon = self.modules.pop(mod_id)
        if mod_id in self.order:
            self.order.remove(mod_id)
        self.vbox.removeWidget(icon)
        icon.deleteLater()
        self._check_overflow()

    def select_module(self, mod_id):
        self.deselect_all()
        if mod_id in self.modules:
            self.modules[mod_id].set_active(True)
    
    def flash_module(self, mod_id):
        if mod_id in self.modules:
            self.modules[mod_id].flash()

    def deselect_all(self):
        for icon in self.modules.values(): icon.set_active(False)

    def get_order(self):
        return list(self.order)

    def eventFilter(self, obj, event):
        if obj is self.content:
            if event.type() in (QEvent.DragEnter, QEvent.DragMove):
                if event.mimeData().hasFormat("application/x-monolith-module"):
                    event.acceptProposedAction()
                    return True
            elif event.type() == QEvent.Drop:
                if event.mimeData().hasFormat("application/x-monolith-module"):
                    mod_id = bytes(event.mimeData().data("application/x-monolith-module")).decode()
                    target = self._module_at_pos(event.position().toPoint())
                    self.reorder_module(mod_id, target)
                    event.acceptProposedAction()
                    return True
        return super().eventFilter(obj, event)

    def reorder_module(self, mod_id, target_id):
        if mod_id not in self.order or mod_id == target_id:
            return
        self.order.remove(mod_id)
        if target_id and target_id in self.order:
            target_index = self.order.index(target_id)
            self.order.insert(target_index, mod_id)
        else:
            self.order.append(mod_id)
        self._rebuild_layout()

    def _module_at_pos(self, pos):
        widget = self.content.childAt(pos)
        while widget and widget is not self.content:
            if isinstance(widget, ModuleIcon):
                return widget.mod_id
            widget = widget.parent()
        return None

    def _rebuild_layout(self):
        while self.vbox.count():
            item = self.vbox.takeAt(0)
            if item.widget():
                item.widget().setParent(None)
        for mod_id in self.order:
            self.vbox.addWidget(self.modules[mod_id])
        self.vbox.addStretch()
        self._check_overflow()

    def _check_overflow(self):
        self.content.adjustSize()
        overflow = self.content.sizeHint().height() > self.scroll.height()
        self.arrow.setVisible(overflow)

    def scroll_down(self):
        vs = self.scroll.verticalScrollBar()
        vs.setValue(vs.value() + 50)



================================================================================
FILE: .\ui\modules\audiogen.py
================================================================================

import os
import json
from pathlib import Path
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QFrame, QComboBox, QDoubleSpinBox, QFileDialog,
    QAbstractSpinBox
)
from PySide6.QtCore import Qt, QThread, Signal, QUrl, QTimer
from PySide6.QtMultimedia import QMediaPlayer, QAudioOutput
from PySide6.QtGui import QPainter, QPen, QColor

import core.style as _s  # dynamic theme bridge
from ui.components.atoms import MonoGroupBox, MonoButton, MonoTriangleButton, CollapsibleSection

AUDIOCRAFT_AVAILABLE = False
try:
    import importlib
    importlib.import_module("audiocraft")
    AUDIOCRAFT_AVAILABLE = True
except ImportError:
    AUDIOCRAFT_AVAILABLE = False


class WaveformWidget(QFrame):
    def __init__(self):
        super().__init__()
        self.setFixedHeight(120)
        import core.style as _s
        self.setStyleSheet(f"background: {_s.BG_INPUT}; border: 1px solid {_s.BORDER_DARK};")
        self.waveform_data = None
        
    def set_waveform(self, audio_array):
        if audio_array is not None and len(audio_array) > 0:
            # Downsample for display
            target_points = 500
            if len(audio_array) > target_points:
                step = len(audio_array) // target_points
                self.waveform_data = audio_array[::step]
            else:
                self.waveform_data = audio_array
        else:
            self.waveform_data = None
        self.update()
    
    def paintEvent(self, event):
        super().paintEvent(event)
        import core.style as _s
        if self.waveform_data is None:
            painter = QPainter(self)
            painter.setPen(QPen(QColor(_s.FG_DIM)))
            painter.drawText(self.rect(), Qt.AlignCenter, "NO WAVEFORM")
            return

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        w = self.width()
        h = self.height()
        mid_y = h / 2

        pen = QPen(QColor(_s.FG_ACCENT), 1)
        painter.setPen(pen)
        
        data = self.waveform_data
        num_points = len(data)
        
        for i in range(num_points - 1):
            x1 = int((i / num_points) * w)
            x2 = int(((i + 1) / num_points) * w)
            
            y1 = int(mid_y - (data[i] * mid_y * 0.9))
            y2 = int(mid_y - (data[i + 1] * mid_y * 0.9))
            
            painter.drawLine(x1, y1, x2, y2)


class AudioGenWorker(QThread):
    progress = Signal(str)
    finished = Signal(object, int)
    error = Signal(str)

    def __init__(self, prompt, model_path, duration, sample_rate):
        super().__init__()
        self.prompt = prompt
        self.model_path = model_path
        self.duration = duration
        self.sample_rate = sample_rate

    def run(self):
        try:
            try:
                from audiocraft.models import MusicGen
            except ImportError:
                self.error.emit("ERROR: audiocraft not installed. pip install audiocraft")
                return
            import torchaudio
            import torch
            
            self.progress.emit("Loading model...")
            
            model = MusicGen.get_pretrained(self.model_path)
            model.set_generation_params(duration=self.duration)
            
            self.progress.emit("Generating audio...")
            
            wav = model.generate([self.prompt])
            
            audio_array = wav[0].cpu().numpy()
            
            self.finished.emit(audio_array, self.sample_rate)
            
        except Exception as e:
            self.error.emit(str(e))


class AudioGenModule(QWidget):
    def __init__(self):
        super().__init__()
        import core.style as s

        self.config_path = Path("config/audiogen_config.json")
        self.artifacts_dir = Path("artifacts/audio")
        self.artifacts_dir.mkdir(parents=True, exist_ok=True)
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.config = self._load_config()
        self.model_path = self.config.get("model_path", "")
        self.current_audio = None
        self.current_sample_rate = None
        self.current_filepath = None
        self.worker = None
        self._config_timer = QTimer(self)
        self._config_timer.setInterval(1000)
        self._config_timer.setSingleShot(True)
        self._config_timer.timeout.connect(self._save_config)
        self._status_reset_timer = QTimer(self)
        self._status_reset_timer.setInterval(1000)
        self._status_reset_timer.setSingleShot(True)
        self._status_reset_timer.timeout.connect(self._reset_status)
        
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)

        grp = MonoGroupBox("AUDIO")
        inner = QVBoxLayout()
        inner.setSpacing(12)

        # Config Section
        config_section = CollapsibleSection("⚙ CONFIGURATION")
        config_layout = QVBoxLayout()
        config_layout.setSpacing(8)

        grp_model = MonoGroupBox("MODEL LOADER")
        model_layout = QVBoxLayout()
        model_path_row = QHBoxLayout()
        lbl_model_path = QLabel("MODEL PATH")
        lbl_model_path.setStyleSheet(f"color: {s.FG_DIM}; font-size: 10px;")
        lbl_model_path.setFixedWidth(80)
        self.inp_model_path = QLineEdit(self.model_path)
        self.inp_model_path.setReadOnly(True)
        self.inp_model_path.setPlaceholderText("Select an AudioGen model file...")
        self.inp_model_path.setToolTip(self.model_path)
        self.inp_model_path.setStyleSheet(f"""
            QLineEdit {{
                background: {s.BG_INPUT}; color: {s.FG_TEXT};
                border: 1px solid {s.BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_browse = MonoButton("BROWSE...")
        btn_browse.setFixedWidth(90)
        btn_browse.clicked.connect(self._browse_model)
        model_path_row.addWidget(lbl_model_path)
        model_path_row.addWidget(self.inp_model_path)
        model_path_row.addWidget(btn_browse)
        model_layout.addLayout(model_path_row)

        model_row = QHBoxLayout()
        lbl_model = QLabel("MODEL ID")
        lbl_model.setStyleSheet(f"color: {s.FG_DIM}; font-size: 10px;")
        lbl_model.setFixedWidth(80)
        self.inp_model_id = QLineEdit()
        self.inp_model_id.setPlaceholderText("facebook/musicgen-small")
        self.inp_model_id.setText(self.config.get("model_id", "facebook/musicgen-small"))
        self.inp_model_id.setReadOnly(True)
        self.inp_model_id.setStyleSheet(f"""
            QLineEdit {{
                background: {s.BG_INPUT}; color: {s.FG_TEXT};
                border: 1px solid {s.BORDER_DARK}; padding: 4px;
            }}
        """)
        model_row.addWidget(lbl_model)
        model_row.addWidget(self.inp_model_id)
        model_layout.addLayout(model_row)
        grp_model.add_layout(model_layout)
        config_layout.addWidget(grp_model)

        grp_audio = MonoGroupBox("AUDIO CONFIG")
        audio_layout = QVBoxLayout()

        duration_row = QHBoxLayout()
        lbl_duration = QLabel("Duration (s)")
        lbl_duration.setStyleSheet(f"color: {s.FG_DIM}; font-size: 10px;")
        lbl_duration.setFixedWidth(80)
        self.inp_duration = QDoubleSpinBox()
        self.inp_duration.setRange(1.0, 30.0)
        self.inp_duration.setValue(self.config.get("duration", 5.0))
        self.inp_duration.setSingleStep(0.5)
        self.inp_duration.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_duration.setStyleSheet(f"""
            QDoubleSpinBox {{
                background: {s.BG_INPUT}; color: {s.FG_TEXT};
                border: 1px solid {s.BORDER_DARK}; padding: 4px;
            }}
        """)
        duration_row.addWidget(lbl_duration)
        btn_duration_down = MonoTriangleButton("◀")
        btn_duration_down.clicked.connect(self.inp_duration.stepDown)
        btn_duration_up = MonoTriangleButton("▶")
        btn_duration_up.clicked.connect(self.inp_duration.stepUp)
        duration_row.addWidget(btn_duration_down)
        duration_row.addWidget(self.inp_duration)
        duration_row.addWidget(btn_duration_up)
        duration_row.addStretch()
        audio_layout.addLayout(duration_row)

        sr_row = QHBoxLayout()
        lbl_sr = QLabel("Sample Rate")
        lbl_sr.setStyleSheet(f"color: {s.FG_DIM}; font-size: 10px;")
        lbl_sr.setFixedWidth(80)
        self.cmb_sr = QComboBox()
        self.cmb_sr.addItems(["32000", "44100", "48000"])
        self.cmb_sr.setCurrentText(str(self.config.get("sample_rate", 32000)))
        self.cmb_sr.setStyleSheet(f"""
            QComboBox {{
                background: {s.BG_INPUT}; color: {s.FG_TEXT};
                border: 1px solid {s.BORDER_DARK}; padding: 4px;
            }}
        """)
        sr_row.addWidget(lbl_sr)
        sr_row.addWidget(self.cmb_sr)
        sr_row.addStretch()
        audio_layout.addLayout(sr_row)

        grp_audio.add_layout(audio_layout)
        config_layout.addWidget(grp_audio)
        
        config_section.set_content_layout(config_layout)
        inner.addWidget(config_section)

        # Prompt
        lbl_prompt = QLabel("Prompt")
        lbl_prompt.setStyleSheet(f"color: {s.FG_DIM}; font-size: 10px;")

        self.inp_prompt = QLineEdit()
        self.inp_prompt.setPlaceholderText("Describe a sound to generate...")
        self.inp_prompt.setStyleSheet(f"""
            QLineEdit {{
                background: {s.BG_INPUT}; color: {s.FG_TEXT};
                border: 1px solid {s.BORDER_DARK}; padding: 6px;
            }}
        """)

        # Buttons
        btn_row = QHBoxLayout()
        self.btn_generate = MonoButton("GENERATE", accent=True)
        self.btn_generate.clicked.connect(self._start_generate)
        self.btn_play = MonoButton("PLAY")
        self.btn_play.clicked.connect(self._play_audio)
        self.btn_play.setEnabled(False)
        self.btn_save = MonoButton("SAVE AUDIO")
        self.btn_save.clicked.connect(self._save_audio)
        self.btn_save.setEnabled(False)
        btn_row.addWidget(self.btn_generate)
        btn_row.addWidget(self.btn_play)
        btn_row.addWidget(self.btn_save)
        btn_row.addStretch()

        # Waveform Display
        self.waveform_widget = WaveformWidget()

        # Status
        status_row = QHBoxLayout()
        lbl_status_title = QLabel("Status")
        lbl_status_title.setStyleSheet(f"color: {s.FG_DIM}; font-size: 10px;")
        self.lbl_status = QLabel("IDLE")
        self.lbl_status.setStyleSheet(f"color: {s.FG_TEXT}; font-size: 10px; font-weight: bold;")
        status_row.addWidget(lbl_status_title)
        status_row.addStretch()
        status_row.addWidget(self.lbl_status)

        inner.addWidget(lbl_prompt)
        inner.addWidget(self.inp_prompt)
        inner.addLayout(btn_row)
        inner.addWidget(self.waveform_widget)
        inner.addLayout(status_row)
        inner.addStretch()

        grp.add_layout(inner)
        layout.addWidget(grp)

        self.inp_duration.valueChanged.connect(self._queue_save_config)
        self.cmb_sr.currentTextChanged.connect(self._queue_save_config)

    def _load_config(self):
        if self.config_path.exists():
            try:
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                return config
            except:
                pass
        return {
            "model_path": "",
            "model_id": "facebook/musicgen-small",
            "duration": 5.0,
            "sample_rate": 32000
        }

    def _queue_save_config(self):
        self._status_reset_timer.stop()
        self._config_timer.start()

    def _save_config(self):
        import core.style as s
        config = {
            "model_path": self.model_path,
            "model_id": self.inp_model_id.text().strip() or self.inp_model_id.placeholderText(),
            "duration": self.inp_duration.value(),
            "sample_rate": int(self.cmb_sr.currentText())
        }
        with open(self.config_path, 'w') as f:
            json.dump(config, f, indent=2)
        self.config = config
        self._set_status("CONFIG SAVED", s.FG_ACCENT)
        self._status_reset_timer.start()

    def _browse_model(self):
        import core.style as s
        path, _ = QFileDialog.getOpenFileName(self, "Select Audio Model", "", "All Files (*)")
        if not path:
            return
        path = os.path.abspath(path)
        try:
            if not AUDIOCRAFT_AVAILABLE:
                self._set_status("ERROR: audiocraft not installed. pip install audiocraft", s.FG_ERROR)
                self.inp_model_path.setText(self.model_path)
                self.inp_model_path.setToolTip(self.model_path)
                return
            try:
                from audiocraft.models import MusicGen
            except ImportError:
                self._set_status("ERROR: audiocraft not installed. pip install audiocraft", s.FG_ERROR)
                self.inp_model_path.setText(self.model_path)
                self.inp_model_path.setToolTip(self.model_path)
                return
            MusicGen.get_pretrained(path)
        except Exception as exc:
            self._set_status(f"ERROR: {str(exc)}", s.FG_ERROR)
            self.inp_model_path.setText(self.model_path)
            self.inp_model_path.setToolTip(self.model_path)
            return
        self.model_path = path
        self.inp_model_path.setText(path)
        self.inp_model_path.setToolTip(path)
        self._queue_save_config()

    def _set_status(self, status, color=None):
        import core.style as s
        self.lbl_status.setText(status)
        self.lbl_status.setStyleSheet(f"color: {color or s.FG_TEXT}; font-size: 10px; font-weight: bold;")

    def _reset_status(self):
        self._set_status("IDLE")

    def _start_generate(self):
        import core.style as s
        if not AUDIOCRAFT_AVAILABLE:
            self._set_status("ERROR: audiocraft not installed. pip install audiocraft", s.FG_ERROR)
            return

        prompt = self.inp_prompt.text().strip()
        if not prompt:
            self._set_status("ERROR: No prompt", s.FG_ERROR)
            return

        self.btn_generate.setEnabled(False)
        self.btn_play.setEnabled(False)
        self.btn_save.setEnabled(False)
        self._set_status("INITIALIZING", s.FG_ACCENT)

        model_path = self.model_path
        if not model_path:
            self._set_status("ERROR: No model selected", s.FG_ERROR)
            return

        self.worker = AudioGenWorker(
            prompt,
            model_path,
            self.inp_duration.value(),
            int(self.cmb_sr.currentText())
        )
        self.worker.progress.connect(self._on_progress)
        self.worker.finished.connect(self._on_finished)
        self.worker.error.connect(self._on_error)
        self.worker.start()

    def _on_progress(self, msg):
        import core.style as s
        self._set_status(msg, s.FG_ACCENT)

    def _on_finished(self, audio_array, sample_rate):
        self.current_audio = audio_array
        self.current_sample_rate = sample_rate
        
        # Save temporarily for playback
        import time
        temp_filename = f"temp_audio_{int(time.time())}.wav"
        self.current_filepath = self.artifacts_dir / temp_filename
        
        try:
            import torch
            import torchaudio
            audio_tensor = torch.from_numpy(audio_array).unsqueeze(0)
            torchaudio.save(str(self.current_filepath), audio_tensor, sample_rate)
        except Exception as e:
            import core.style as s
            self._set_status(f"SAVE ERROR: {str(e)}", s.FG_ERROR)
            return

        # Display waveform (use mono channel)
        if len(audio_array.shape) > 1:
            display_data = audio_array[0]
        else:
            display_data = audio_array
        self.waveform_widget.set_waveform(display_data)

        self._set_status("DONE")
        self.btn_generate.setEnabled(True)
        self.btn_play.setEnabled(True)
        self.btn_save.setEnabled(True)

    def _on_error(self, err_msg):
        import core.style as s
        self._set_status(f"ERROR: {err_msg}", s.FG_ERROR)
        self.btn_generate.setEnabled(True)

    def _play_audio(self):
        if not self.current_filepath or not self.current_filepath.exists():
            return
            
        self.player.setSource(QUrl.fromLocalFile(str(self.current_filepath)))
        self.player.play()
        import core.style as s
        self._set_status("PLAYING", s.FG_ACCENT)

    def _save_audio(self):
        if self.current_audio is None:
            return
        
        if not self.current_filepath or not self.current_filepath.exists():
            return
            
        import time
        filename = f"audio_{int(time.time())}.wav"
        filepath = self.artifacts_dir / filename
        
        try:
            import shutil
            shutil.copy(self.current_filepath, filepath)
            import core.style as s
            self._set_status(f"SAVED: {filename}", s.FG_ACCENT)
        except Exception as e:
            import core.style as s
            self._set_status(f"SAVE ERROR: {str(e)}", s.FG_ERROR)



================================================================================
FILE: .\ui\modules\injector.py
================================================================================

import sys
import os
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
    QPushButton, QPlainTextEdit, QSplitter, QFrame
)
from PySide6.QtCore import Qt, Signal, QProcess, QUrl
from PySide6.QtGui import QTextCursor, QDragEnterEvent, QDropEvent


class InjectorWidget(QWidget):
    sig_closed = Signal()
    sig_finished = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        import core.style as s
        self.setAcceptDrops(True)
        self.setObjectName("InjectorRoot")

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Toolbar
        toolbar = QFrame()
        toolbar.setFixedHeight(35)
        toolbar.setStyleSheet(f"background: {s.BG_GROUP}; border-bottom: 1px solid {s.BORDER_DARK};")
        tb_layout = QHBoxLayout(toolbar)
        tb_layout.setContentsMargins(10, 0, 10, 0)

        lbl_title = QLabel("RUNTIME")
        lbl_title.setStyleSheet(f"color: {s.ACCENT_PRIMARY}; font-weight: bold; font-size: 11px;")

        self.btn_run = QPushButton("▶ EXECUTE")
        self.btn_run.setCursor(Qt.PointingHandCursor)
        self.btn_run.setStyleSheet(f"""
            QPushButton {{ background: {s.BG_BUTTON}; color: {s.FG_ACCENT}; border: 1px solid {s.BORDER_LIGHT}; padding: 4px 10px; font-weight:bold; font-size: 10px;}}
            QPushButton:hover {{ background: {s.BG_BUTTON_HOVER}; border-color: {s.FG_ACCENT}; }}
        """)
        self.btn_run.clicked.connect(self.run_code)

        btn_close = QPushButton("×")
        btn_close.setFixedSize(20, 20)
        btn_close.setCursor(Qt.PointingHandCursor)
        btn_close.setStyleSheet(f"background: transparent; color: {s.FG_PLACEHOLDER}; border: none; font-weight: bold; font-size: 14px;")
        btn_close.clicked.connect(self.close_addon)

        tb_layout.addWidget(lbl_title)
        tb_layout.addStretch()
        tb_layout.addWidget(self.btn_run)
        tb_layout.addWidget(btn_close)

        layout.addWidget(toolbar)

        # Splitter (Code | Console)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setHandleWidth(1)
        splitter.setStyleSheet(f"QSplitter::handle {{ background: {s.BORDER_DARK}; }}")

        self.editor = QPlainTextEdit()
        self.editor.setPlaceholderText("# Drag .py file here or write code...")
        self.editor.setStyleSheet(f"""
            QPlainTextEdit {{
                background: {s.BG_INPUT}; color: {s.FG_TEXT};
                border: none; font-family: 'Consolas', monospace; font-size: 12px; padding: 10px;
            }}
        """)

        self.console = QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setPlaceholderText("Output...")
        self.console.setStyleSheet(f"""
            QPlainTextEdit {{
                background: {s.OVERSEER_BG}; color: {s.FG_DIM};
                border: none; border-left: 1px solid {s.BORDER_DARK};
                font-family: 'Consolas', monospace; font-size: 11px; padding: 10px;
            }}
        """)
        
        splitter.addWidget(self.editor)
        splitter.addWidget(self.console)
        splitter.setSizes([400, 400])
        
        layout.addWidget(splitter)

        self.process = QProcess(self)
        self.process.setProcessChannelMode(QProcess.MergedChannels)
        self.process.readyReadStandardOutput.connect(self._read_output)
        self.process.finished.connect(self._process_finished)

    def dragEnterEvent(self, event: QDragEnterEvent):
        # Accept if files (Explorer) or Text (Qt Tree View default drag)
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event: QDropEvent):
        file_path = None
        
        # Case 1: Dragged from Explorer (MimeType: text/uri-list)
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls:
                file_path = urls[0].toLocalFile()

        # Case 2: Dragged from Databank Tree (MimeType: text/plain usually)
        # The tree might just pass the path string
        elif event.mimeData().hasText():
            text = event.mimeData().text()
            # Clean up if it has file:/// prefix even in text mode
            if text.startswith("file:///"):
                file_path = QUrl(text).toLocalFile()
            elif os.path.exists(text):
                file_path = text

        if file_path and os.path.exists(file_path):
            self._load_file(file_path)
        else:
            self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: Could not resolve file path.</span>")

    def _load_file(self, path):
        if os.path.isfile(path) and path.endswith(".py"):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    self.editor.setPlainText(f.read())
                self.console.appendHtml(f"<span style='color:{FG_ACCENT}'>→ LOADED: {os.path.basename(path)}</span>")
            except Exception as e:
                self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: {e}</span>")
        else:
             self.console.appendHtml(f"<span style='color:{FG_ERROR}'>ERROR: Not a .py file</span>")

    def run_code(self):
        code = self.editor.toPlainText()
        if not code.strip(): return
        
        if self.process.state() != QProcess.NotRunning:
            self.console.appendHtml(f"<span style='color:{FG_ERROR}'>BUSY: Process running...</span>")
            return

        self.console.clear()
        self.console.appendHtml(f"<span style='color:{FG_ACCENT}'>→ EXECUTING SCRIPT...</span>")
        self.process.start(sys.executable, ["-c", code])

    def _read_output(self):
        data = self.process.readAllStandardOutput().data().decode()
        self.console.moveCursor(QTextCursor.End)
        self.console.insertPlainText(data)

    def _process_finished(self):
        self.console.appendHtml(f"<br><span style='color:{FG_DIM}'>→ PROCESS TERMINATED</span>")
        self.sig_finished.emit()

    def close_addon(self):
        if self.process.state() != QProcess.NotRunning:
            self.process.kill()
        self.sig_closed.emit()
        self.deleteLater()

    def closeEvent(self, event):
        if self.process.state() != QProcess.NotRunning:
            self.process.kill()
            self.process.waitForFinished(300)
        event.accept()



================================================================================
FILE: .\ui\modules\manager.py
================================================================================

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QScrollArea
from PySide6.QtCore import Signal, Qt

from ui.components.atoms import MonoGroupBox, MonoButton
import core.style as _s  # dynamic theme bridge

class PageAddons(QWidget):
    sig_launch_addon = Signal(str)
    sig_open_vitals = Signal()
    sig_open_overseer = Signal()

    def __init__(self, state):
        super().__init__()
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)

        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(0, 0, 0, 0)

        grp_modules = MonoGroupBox("AVAILABLE MODULES")
        
        mod_layout = QVBoxLayout()
        mod_layout.setSpacing(15)
        
        lbl_info = QLabel("Select a runtime module to attach to the workspace.")
        lbl_info.setStyleSheet(f"color: {_s.FG_DIM}; font-size: 11px;")

        btn_terminal = MonoButton("CHAT")
        btn_terminal.clicked.connect(lambda: self.sig_launch_addon.emit("terminal"))

        btn_databank = MonoButton("FILES")
        btn_databank.clicked.connect(lambda: self.sig_launch_addon.emit("databank"))

        btn_injector = MonoButton("RUNTIME")
        btn_injector.clicked.connect(lambda: self.sig_launch_addon.emit("injector"))

        btn_sd = MonoButton("VISION")
        btn_sd.clicked.connect(lambda: self.sig_launch_addon.emit("sd"))

        btn_audiogen = MonoButton("AUDIO")
        btn_audiogen.clicked.connect(lambda: self.sig_launch_addon.emit("audiogen"))

        mod_layout.addWidget(lbl_info)
        mod_layout.addWidget(btn_terminal)
        mod_layout.addWidget(btn_databank)
        mod_layout.addWidget(btn_injector)
        mod_layout.addWidget(btn_sd)
        mod_layout.addWidget(btn_audiogen)
        mod_layout.addStretch()
        
        grp_modules.add_layout(mod_layout)
        scroll_layout.addWidget(grp_modules)
        
        grp_system = MonoGroupBox("SYSTEM")
        system_layout = QVBoxLayout()
        system_layout.setSpacing(10)

        btn_vitals = MonoButton("VITALS")
        btn_vitals.clicked.connect(self.sig_open_vitals.emit)

        btn_overseer = MonoButton("MONITOR")
        btn_overseer.clicked.connect(self.sig_open_overseer.emit)

        system_layout.addWidget(btn_vitals)
        system_layout.addWidget(btn_overseer)
        grp_system.add_layout(system_layout)
        scroll_layout.addWidget(grp_system)
        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_content)
        layout.addWidget(scroll_area)

        # Keep refs for theme refresh
        self._lbl_info = lbl_info

    def apply_theme_refresh(self):
        import core.style as s
        self._lbl_info.setStyleSheet(f"color: {s.FG_DIM}; font-size: 11px;")
        # Refresh all atom widgets (MonoButton, MonoGroupBox, etc.)
        for child in self.findChildren(QWidget):
            if hasattr(child, "refresh_style"):
                child.refresh_style()



================================================================================
FILE: .\ui\modules\sd.py
================================================================================

import json

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QScrollArea, QFileDialog, QSpinBox, QDoubleSpinBox,
    QAbstractSpinBox
)
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QPixmap, QImage

from core.state import SystemStatus
from core.paths import CONFIG_DIR, MONOLITH_ROOT
from monokernel.bridge import MonoBridge
from monokernel.guard import MonoGuard
from ui.components.atoms import MonoGroupBox, MonoButton, MonoTriangleButton, CollapsibleSection

class SDModule(QWidget):
    def __init__(self, bridge: MonoBridge, guard: MonoGuard):
        super().__init__()
        import core.style as s
        BG_INPUT, BORDER_DARK, FG_DIM, FG_TEXT, FG_ACCENT, FG_ERROR = (
            s.BG_INPUT, s.BORDER_DARK, s.FG_DIM, s.FG_TEXT, s.FG_ACCENT, s.FG_ERROR
        )
        self.bridge = bridge
        self.guard = guard

        self.config_path = CONFIG_DIR / "vision_config.json"
        self.legacy_config_path = CONFIG_DIR / "sd_config.json"
        self.artifacts_dir = MONOLITH_ROOT / "artifacts" / "vision"
        self.artifacts_dir.mkdir(parents=True, exist_ok=True)
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.config = self._load_config()
        self.model_path = self.config.get("model_path", "")
        self.is_model_loaded = False
        self.current_image = None
        self._engine_status = SystemStatus.READY
        self._config_timer = QTimer(self)
        self._config_timer.setInterval(1000)
        self._config_timer.setSingleShot(True)
        self._config_timer.timeout.connect(self._save_config)
        self._status_reset_timer = QTimer(self)
        self._status_reset_timer.setInterval(1000)
        self._status_reset_timer.setSingleShot(True)
        self._status_reset_timer.timeout.connect(self._reset_status)
        if self.model_path:
            self.bridge.submit(
                self.bridge.wrap(
                    "vision",
                    "set_path",
                    "vision",
                    payload={"path": self.model_path},
                )
            )

        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)

        grp = MonoGroupBox("VISION")
        inner = QVBoxLayout()
        inner.setSpacing(12)

        # Config Section
        config_section = CollapsibleSection("⚙ CONFIGURATION")
        config_layout = QVBoxLayout()
        config_layout.setSpacing(8)
        
        # Model Loader
        grp_loader = MonoGroupBox("MODEL LOADER")
        loader_layout = QVBoxLayout()
        loader_row = QHBoxLayout()
        lbl_model = QLabel("Model Path")
        lbl_model.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        self.inp_model = QLineEdit(self.model_path)
        self.inp_model.setReadOnly(True)
        self.inp_model.setPlaceholderText("Select a model file (.ckpt or .safetensors)...")
        self.inp_model.setToolTip(self.model_path)
        self.inp_model.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_browse = MonoButton("BROWSE...")
        btn_browse.setFixedWidth(90)
        btn_browse.clicked.connect(self._browse_model)
        loader_row.addWidget(lbl_model, 0)
        loader_row.addWidget(self.inp_model, 1)
        loader_row.addWidget(btn_browse, 0)
        self.btn_load = MonoButton("LOAD MODEL")
        self.btn_load.setCheckable(True)
        self.btn_load.setChecked(False)
        self.btn_load.clicked.connect(self._load_model)
        loader_layout.addLayout(loader_row)
        loader_layout.addWidget(self.btn_load)
        grp_loader.add_layout(loader_layout)
        config_layout.addWidget(grp_loader)
        
        # Steps
        steps_row = QHBoxLayout()
        lbl_steps = QLabel("Steps")
        lbl_steps.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_steps.setFixedWidth(80)
        self.inp_steps = QSpinBox()
        self.inp_steps.setRange(1, 150)
        self.inp_steps.setValue(self.config.get("steps", 25))
        self.inp_steps.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_steps.setStyleSheet(f"""
            QSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        steps_row.addWidget(lbl_steps)
        btn_steps_down = MonoTriangleButton("◀")
        btn_steps_down.clicked.connect(self.inp_steps.stepDown)
        btn_steps_up = MonoTriangleButton("▶")
        btn_steps_up.clicked.connect(self.inp_steps.stepUp)
        steps_row.addWidget(btn_steps_down)
        steps_row.addWidget(self.inp_steps)
        steps_row.addWidget(btn_steps_up)
        steps_row.addStretch()
        config_layout.addLayout(steps_row)
        
        # Strength
        strength_row = QHBoxLayout()
        lbl_strength = QLabel("Strength")
        lbl_strength.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_strength.setFixedWidth(80)
        self.inp_strength = QDoubleSpinBox()
        self.inp_strength.setRange(1.0, 20.0)
        self.inp_strength.setValue(self.config.get("guidance_scale", 7.5))
        self.inp_strength.setSingleStep(0.5)
        self.inp_strength.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_strength.setStyleSheet(f"""
            QDoubleSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_strength_down = MonoTriangleButton("◀")
        btn_strength_down.clicked.connect(self.inp_strength.stepDown)
        btn_strength_up = MonoTriangleButton("▶")
        btn_strength_up.clicked.connect(self.inp_strength.stepUp)
        strength_row.addWidget(lbl_strength)
        strength_row.addWidget(btn_strength_down)
        strength_row.addWidget(self.inp_strength)
        strength_row.addWidget(btn_strength_up)
        strength_row.addStretch()
        config_layout.addLayout(strength_row)
        
        # Seed
        seed_row = QHBoxLayout()
        lbl_seed = QLabel("Seed")
        lbl_seed.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        lbl_seed.setFixedWidth(80)
        self.inp_seed = QSpinBox()
        self.inp_seed.setRange(-1, 2147483647)
        self.inp_seed.setSpecialValueText("RANDOM")
        self.inp_seed.setValue(self.config.get("seed", -1))
        self.inp_seed.setButtonSymbols(QAbstractSpinBox.NoButtons)
        self.inp_seed.setStyleSheet(f"""
            QSpinBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 4px;
            }}
        """)
        btn_seed_down = MonoTriangleButton("◀")
        btn_seed_down.clicked.connect(self.inp_seed.stepDown)
        btn_seed_up = MonoTriangleButton("▶")
        btn_seed_up.clicked.connect(self.inp_seed.stepUp)
        seed_row.addWidget(lbl_seed)
        seed_row.addWidget(btn_seed_down)
        seed_row.addWidget(self.inp_seed)
        seed_row.addWidget(btn_seed_up)
        seed_row.addStretch()
        config_layout.addLayout(seed_row)
        
        config_section.set_content_layout(config_layout)
        inner.addWidget(config_section)

        # Prompt
        lbl_prompt = QLabel("Prompt")
        lbl_prompt.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")

        self.inp_prompt = QLineEdit()
        self.inp_prompt.setPlaceholderText("Describe an image to generate...")
        self.inp_prompt.setStyleSheet(f"""
            QLineEdit {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_DARK}; padding: 6px;
            }}
        """)

        # Buttons
        btn_row = QHBoxLayout()
        self.btn_generate = MonoButton("GENERATE", accent=True)
        self.btn_generate.clicked.connect(self._start_generate)
        self.btn_generate.setEnabled(self.is_model_loaded)
        self.btn_stop = MonoButton("STOP")
        self.btn_stop.clicked.connect(lambda: self.bridge.stop("vision"))
        self.btn_stop.setEnabled(False)
        self.btn_save = MonoButton("SAVE IMAGE")
        self.btn_save.clicked.connect(self._save_image)
        self.btn_save.setEnabled(False)
        btn_row.addWidget(self.btn_generate)
        btn_row.addWidget(self.btn_stop)
        btn_row.addWidget(self.btn_save)
        btn_row.addStretch()

        # Preview
        preview_scroll = QScrollArea()
        preview_scroll.setWidgetResizable(True)
        preview_scroll.setFixedHeight(400)
        preview_scroll.setStyleSheet(f"background: {BG_INPUT}; border: 1px solid {BORDER_DARK};")
        
        self.lbl_preview = QLabel("NO IMAGE")
        self.lbl_preview.setAlignment(Qt.AlignCenter)
        self.lbl_preview.setStyleSheet(f"color: {FG_DIM}; font-size: 12px;")
        preview_scroll.setWidget(self.lbl_preview)

        # Status
        status_row = QHBoxLayout()
        lbl_status_title = QLabel("Status")
        lbl_status_title.setStyleSheet(f"color: {FG_DIM}; font-size: 10px;")
        self.lbl_status = QLabel("IDLE")
        self.lbl_status.setStyleSheet(f"color: {FG_TEXT}; font-size: 10px; font-weight: bold;")
        status_row.addWidget(lbl_status_title)
        status_row.addStretch()
        status_row.addWidget(self.lbl_status)

        inner.addWidget(lbl_prompt)
        inner.addWidget(self.inp_prompt)
        inner.addLayout(btn_row)
        inner.addWidget(preview_scroll)
        inner.addLayout(status_row)
        inner.addStretch()

        grp.add_layout(inner)
        layout.addWidget(grp)

        self.inp_steps.valueChanged.connect(self._queue_save_config)
        self.inp_strength.valueChanged.connect(self._queue_save_config)
        self.inp_seed.valueChanged.connect(self._queue_save_config)
        self.guard.sig_image.connect(self._on_image)
        self.guard.sig_status.connect(self._on_status)
        self.guard.sig_trace.connect(lambda _engine_key, message: self._on_trace(message))

    def _load_config(self):
        if self.config_path.exists():
            try:
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                return self._normalize_config(config)
            except Exception:
                pass
        if self.legacy_config_path.exists():
            try:
                with open(self.legacy_config_path, 'r') as f:
                    config = json.load(f)
                config = self._normalize_config(config)
                with open(self.config_path, 'w') as f:
                    json.dump(config, f, indent=2)
                return config
            except Exception:
                pass
        return {
            "model_path": "",
            "steps": 25,
            "guidance_scale": 7.5,
            "seed": -1
        }

    def _normalize_config(self, config):
        use_seed = config.get("use_seed")
        if use_seed is False:
            config["seed"] = -1
        config.pop("use_seed", None)
        if "seed" not in config:
            config["seed"] = -1
        return config

    def _save_config(self):
        config = {
            "model_path": self.model_path,
            "steps": self.inp_steps.value(),
            "guidance_scale": self.inp_strength.value(),
            "seed": self.inp_seed.value()
        }
        with open(self.config_path, 'w') as f:
            json.dump(config, f, indent=2)
        self.config = config
        if self._engine_status not in (
            SystemStatus.LOADING,
            SystemStatus.RUNNING,
            SystemStatus.UNLOADING,
        ):
            import core.style as s
            self._set_status("CONFIG SAVED", s.FG_ACCENT)
            self._status_reset_timer.start()

    def _browse_model(self):
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Vision Model",
            "",
            "Model Files (*.ckpt *.safetensors);;All Files (*)"
        )
        if path:
            self.inp_model.setText(path)
            self.inp_model.setToolTip(path)
            self.btn_load.setChecked(False)
            self.btn_load.setText("LOAD MODEL")
            self.is_model_loaded = False

    def _load_model(self):
        import core.style as s
        if self.btn_load.isChecked():
            path = self.inp_model.text().strip()
            if not path:
                self._set_status("ERROR: No model selected", s.FG_ERROR)
                self.btn_load.setChecked(False)
                return
            self.model_path = path
            self._queue_save_config()
            self.bridge.submit(
                self.bridge.wrap(
                    "vision",
                    "set_path",
                    "vision",
                    payload={"path": path},
                )
            )
            self.bridge.submit(self.bridge.wrap("vision", "load", "vision"))
        else:
            self.bridge.submit(self.bridge.wrap("vision", "unload", "vision"))

    def _queue_save_config(self):
        self._status_reset_timer.stop()
        self._config_timer.start()

    def _set_status(self, status, color=None):
        import core.style as s
        self.lbl_status.setText(status)
        self.lbl_status.setStyleSheet(f"color: {color or s.FG_TEXT}; font-size: 10px; font-weight: bold;")

    def _reset_status(self):
        self._set_status("IDLE")

    def _start_generate(self):
        import core.style as s
        prompt = self.inp_prompt.text().strip()
        if not prompt:
            self._set_status("ERROR: No prompt", s.FG_ERROR)
            return

        self.btn_generate.setEnabled(False)
        self.btn_save.setEnabled(False)
        self._set_status("REQUESTED", s.FG_ACCENT)

        seed_value = self.inp_seed.value()
        seed = None if seed_value < 0 else seed_value
        config = {
            "steps": self.inp_steps.value(),
            "guidance_scale": self.inp_strength.value(),
            "seed": seed,
        }
        self.bridge.submit(
            self.bridge.wrap(
                "vision",
                "generate",
                "vision",
                payload={"prompt": prompt, "config": config},
            )
        )

    def _save_image(self):
        if not self.current_image:
            return

        import time
        import core.style as s
        filename = f"vision_{int(time.time())}.png"
        filepath = self.artifacts_dir / filename

        try:
            if isinstance(self.current_image, QImage):
                self.current_image.save(str(filepath))
            else:
                self.current_image.save(filepath)
            self._set_status(f"SAVED: {filename}", s.FG_ACCENT)
        except Exception as e:
            self._set_status(f"SAVE ERROR: {str(e)}", s.FG_ERROR)

    def _on_image(self, image):
        self.current_image = image
        if isinstance(image, QImage):
            qimage = image
        else:
            pil_image = image.convert("RGB")
            data = pil_image.tobytes("raw", "RGB")
            qimage = QImage(
                data,
                pil_image.width,
                pil_image.height,
                QImage.Format_RGB888,
            ).copy()

        pixmap = QPixmap.fromImage(qimage)
        self.lbl_preview.setPixmap(pixmap.scaled(
            self.lbl_preview.width() - 20,
            self.lbl_preview.height() - 20,
            Qt.KeepAspectRatio,
            Qt.SmoothTransformation,
        ))
        self._set_status("DONE")
        self.btn_save.setEnabled(True)

    def _on_status(self, engine_key: str, status: SystemStatus) -> None:
        if engine_key != "vision":
            return
        import core.style as s
        self._engine_status = status
        is_busy = status in (
            SystemStatus.LOADING,
            SystemStatus.RUNNING,
            SystemStatus.UNLOADING,
        )
        self.btn_generate.setEnabled(not is_busy and self.is_model_loaded)
        self.btn_load.setEnabled(not is_busy)
        self.btn_stop.setEnabled(is_busy)
        if status == SystemStatus.LOADING:
            self._set_status("LOADING", s.FG_ACCENT)
            self.btn_load.setText("LOADING...")
        elif status == SystemStatus.RUNNING:
            self._set_status("RUNNING", s.FG_ACCENT)
        elif status == SystemStatus.UNLOADING:
            self._set_status("UNLOADING", s.FG_ACCENT)
        elif status == SystemStatus.READY:
            self._set_status("READY")
            if self.btn_load.isChecked() and self.model_path:
                self.is_model_loaded = True
                self.btn_load.setText("UNLOAD MODEL")
            else:
                self.is_model_loaded = False
                self.btn_load.setChecked(False)
                self.btn_load.setText("LOAD MODEL")
            self.btn_generate.setEnabled(self.is_model_loaded and not is_busy)
        elif status == SystemStatus.ERROR:
            self._set_status("ERROR", s.FG_ERROR)
            self.is_model_loaded = False
            self.btn_load.setChecked(False)
            self.btn_load.setText("LOAD MODEL")
            self.btn_generate.setEnabled(False)

    def _on_trace(self, message: str) -> None:
        if "VISION: ERROR:" in message:
            import core.style as s
            self._set_status(message.replace("VISION: ", ""), s.FG_ERROR)



================================================================================
FILE: .\ui\pages\chat.py
================================================================================

import json
import re
from datetime import datetime, timezone
from pathlib import Path

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTextEdit,
    QLineEdit, QPushButton, QLabel, QFileDialog,
    QSplitter, QListWidget, QListWidgetItem, QStackedWidget,
    QMessageBox, QButtonGroup, QMenu
)
from PySide6.QtCore import Signal, Qt, QTimer, QDateTime
from PySide6.QtGui import QActionGroup

from core.state import SystemStatus
import core.style as _s  # dynamic theme bridge
from ui.components.atoms import MonoGroupBox, MonoButton, MonoSlider
from ui.components.complex import BehaviorTagInput
from ui.components.message_widget import MessageWidget
from core.llm_config import DEFAULT_CONFIG, MASTER_PROMPT, load_config, save_config
from core.paths import ARCHIVE_DIR

class PageChat(QWidget):
    sig_generate = Signal(str, bool)
    sig_load = Signal()
    sig_unload = Signal()
    sig_stop = Signal()
    sig_sync_history = Signal(list)
    sig_set_model_path = Signal(str)
    sig_set_ctx_limit = Signal(int)
    sig_operator_loaded = Signal(str)
    sig_debug = Signal(str)

    def __init__(self, state, ui_bridge):
        super().__init__()
        self.state = state
        self.ui_bridge = ui_bridge
        self.config = load_config()
        self._token_buf: list[str] = []
        self._flush_timer = QTimer(self)
        self._flush_timer.setInterval(25)
        self._flush_timer.timeout.connect(self._flush_tokens)
        self._archive_dir = self._get_archive_dir()
        self._archive_dir.mkdir(parents=True, exist_ok=True)
        self._session_counter = 0
        self._current_session = self._create_session()
        self._undo_snapshot = None
        self._title_generated = False
        self._suppress_title_regen = False
        self._active_assistant_index = None
        self._rewrite_assistant_index = None
        self._active_widget: MessageWidget | None = None
        self._last_status = None
        self._is_running = False
        self._is_model_loaded = False
        self._pending_update_text = None
        self._awaiting_update_restart = False
        self._update_trace_state = None
        self._update_token_count = 0
        self._update_progress_index = 0
        self._config_dirty = False
        self._thinking_mode = bool(self.config.get("thinking_mode", False))
        # When user clicks Edit/Regen/Delete while a generation is running, we STOP first,
        # then apply the mutation on the next READY.
        self._pending_mutation = None  # type: ignore[assignment]


        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(20)

        main_split = QSplitter(Qt.Horizontal)
        main_split.setChildrenCollapsible(False)
        layout.addWidget(main_split)

        # === MODEL LOADER (lives in CONTROL tab) ===
        grp_load = MonoGroupBox("MODEL LOADER")
        self.path_display = QLineEdit()
        self.path_display.setReadOnly(True)
        self.path_display.setPlaceholderText("No GGUF Selected")
        self.path_display.setStyleSheet(
            f"background: {_s.BG_INPUT}; color: {_s.FG_PLACEHOLDER}; border: 1px solid {_s.BORDER_LIGHT}; padding: 5px;"
        )
        btn_browse = MonoButton("...")
        btn_browse.setFixedWidth(30)
        btn_browse.clicked.connect(self.pick_file)
        row_file = QHBoxLayout()
        row_file.addWidget(self.path_display)
        row_file.addWidget(btn_browse)
        self.btn_load = MonoButton("LOAD MODEL")
        self.btn_load.clicked.connect(self.toggle_load)
        grp_load.add_layout(row_file)
        grp_load.add_widget(self.btn_load)

        # === AI CONFIGURATION (lives in SETTINGS tab) ===
        self.s_temp = MonoSlider("Temperature", 0.1, 2.0, self.config.get("temp", 0.7))
        self.s_temp.valueChanged.connect(lambda v: self._update_config_value("temp", v))
        self.s_top = MonoSlider("Top-P", 0.1, 1.0, self.config.get("top_p", 0.9))
        self.s_top.valueChanged.connect(lambda v: self._update_config_value("top_p", v))
        self.s_tok = MonoSlider(
            "Max Tokens", 512, 8192, self.config.get("max_tokens", 2048), is_int=True
        )
        self.s_tok.valueChanged.connect(
            lambda v: self._update_config_value("max_tokens", int(v))
        )
        self.s_ctx = MonoSlider(
            "Context Limit", 1024, 16384, self.config.get("ctx_limit", 8192), is_int=True
        )
        self.s_ctx.valueChanged.connect(self._on_ctx_limit_changed)

        save_row = QHBoxLayout()
        self.lbl_config_state = QLabel("SAVED")
        self.lbl_config_state.setStyleSheet(f"color: {_s.FG_DIM}; font-size: 10px; font-weight: bold;")
        self.btn_save_config = MonoButton("SAVE SETTINGS")
        self.btn_save_config.clicked.connect(self._save_config)
        btn_reset_config = MonoButton("RESET")
        btn_reset_config.clicked.connect(self._reset_config)
        save_row.addWidget(self.lbl_config_state)
        save_row.addStretch()
        save_row.addWidget(btn_reset_config)
        save_row.addWidget(self.btn_save_config)

        # === OPERATIONS GROUP with 3 tabs ===
        operations_group = MonoGroupBox("OPERATIONS")
        operations_layout = QVBoxLayout()
        operations_layout.setSpacing(10)

        tab_row = QHBoxLayout()
        tab_style = f"""
            QPushButton {{
                background: {_s.BG_BUTTON}; border: 1px solid {_s.BORDER_LIGHT}; color: {_s.FG_DIM};
                padding: 6px 12px; font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:checked {{
                background: {_s.BG_BUTTON_HOVER}; color: {_s.ACCENT_PRIMARY}; border: 1px solid {_s.ACCENT_PRIMARY};
            }}
            QPushButton:hover {{ color: {_s.FG_TEXT}; border: 1px solid {_s.FG_TEXT}; }}
        """
        self.btn_tab_control = MonoButton("CONTROL")
        self.btn_tab_control.setCheckable(True)
        self.btn_tab_control.setChecked(True)
        self.btn_tab_control.setStyleSheet(tab_style)
        self.btn_tab_archive = MonoButton("ARCHIVE")
        self.btn_tab_archive.setCheckable(True)
        self.btn_tab_archive.setStyleSheet(tab_style)
        self.btn_tab_settings = MonoButton("SETTINGS")
        self.btn_tab_settings.setCheckable(True)
        self.btn_tab_settings.setStyleSheet(tab_style)
        tab_group = QButtonGroup(self)
        tab_group.setExclusive(True)
        tab_group.addButton(self.btn_tab_control)
        tab_group.addButton(self.btn_tab_archive)
        tab_group.addButton(self.btn_tab_settings)
        tab_row.addWidget(self.btn_tab_control)
        tab_row.addWidget(self.btn_tab_archive)
        tab_row.addWidget(self.btn_tab_settings)
        tab_row.addStretch()
        operations_layout.addLayout(tab_row)

        self.ops_stack = QStackedWidget()
        operations_layout.addWidget(self.ops_stack)

        # --- CONTROL tab: Model Loader (top-level, no collapsible) ---
        control_tab = QWidget()
        control_layout = QVBoxLayout(control_tab)
        control_layout.setSpacing(12)
        control_layout.addWidget(grp_load)

        # --- Collapsible OPTIONS panel ---
        self._options_expanded = False
        self.btn_options_toggle = QPushButton("▸ OPTIONS")
        self.btn_options_toggle.setCursor(Qt.PointingHandCursor)
        self.btn_options_toggle.setStyleSheet(f"""
            QPushButton {{
                background: transparent; border: none;
                color: {_s.FG_DIM}; font-size: 9px; font-weight: bold;
                letter-spacing: 1px; text-align: left; padding: 4px 0;
            }}
            QPushButton:hover {{ color: {_s.ACCENT_PRIMARY}; }}
        """)
        self.btn_options_toggle.clicked.connect(self._toggle_options_panel)
        control_layout.addWidget(self.btn_options_toggle)

        self.options_panel = QWidget()
        self.options_panel.setVisible(False)
        options_layout = QVBoxLayout(self.options_panel)
        options_layout.setContentsMargins(0, 0, 0, 0)
        options_layout.setSpacing(8)

        # Attach file button
        self.btn_attach = MonoButton("📎  ATTACH FILE")
        self.btn_attach.clicked.connect(self._attach_file_placeholder)
        options_layout.addWidget(self.btn_attach)

        # Think mode toggle row
        think_row = QHBoxLayout()
        think_row.setSpacing(4)
        lbl_think = QLabel("THINK")
        lbl_think.setStyleSheet(f"color: {_s.FG_DIM}; font-size: 9px; font-weight: bold; letter-spacing: 1px;")
        think_row.addWidget(lbl_think)

        think_style = f"""
            QPushButton {{
                background: {_s.BG_BUTTON}; border: 1px solid {_s.BORDER_LIGHT}; color: {_s.FG_DIM};
                padding: 4px 10px; font-size: 9px; font-weight: bold; border-radius: 2px;
            }}
            QPushButton:checked {{
                background: {_s.BG_BUTTON_HOVER}; color: {_s.ACCENT_PRIMARY}; border: 1px solid {_s.ACCENT_PRIMARY};
            }}
            QPushButton:hover {{ color: {_s.FG_TEXT}; border: 1px solid {_s.FG_TEXT}; }}
        """
        self.btn_think_off = QPushButton("OFF")
        self.btn_think_off.setCheckable(True)
        self.btn_think_off.setStyleSheet(think_style)
        self.btn_think_std = QPushButton("STD")
        self.btn_think_std.setCheckable(True)
        self.btn_think_std.setStyleSheet(think_style)
        self.btn_think_ext = QPushButton("EXT")
        self.btn_think_ext.setCheckable(True)
        self.btn_think_ext.setStyleSheet(think_style)

        self._think_group = QButtonGroup(self)
        self._think_group.setExclusive(True)
        self._think_group.addButton(self.btn_think_off)
        self._think_group.addButton(self.btn_think_std)
        self._think_group.addButton(self.btn_think_ext)
        if self._thinking_mode:
            self.btn_think_std.setChecked(True)
        else:
            self.btn_think_off.setChecked(True)
        self.btn_think_off.clicked.connect(lambda: self._set_thinking_mode(False, "Off"))
        self.btn_think_std.clicked.connect(lambda: self._set_thinking_mode(True, "Standard"))
        self.btn_think_ext.clicked.connect(lambda: self._set_thinking_mode(True, "Extended"))

        think_row.addWidget(self.btn_think_off)
        think_row.addWidget(self.btn_think_std)
        think_row.addWidget(self.btn_think_ext)
        think_row.addStretch()
        options_layout.addLayout(think_row)

        control_layout.addWidget(self.options_panel)
        control_layout.addStretch()

        # --- ARCHIVE tab ---
        archive_tab = QWidget()
        archive_layout = QVBoxLayout(archive_tab)
        archive_layout.setSpacing(10)

        archive_controls = QHBoxLayout()
        self.btn_save_chat = MonoButton("SAVE")
        self.btn_save_chat.clicked.connect(self._save_chat_archive)
        self.btn_load_chat = MonoButton("LOAD")
        self.btn_load_chat.clicked.connect(self._load_chat_archive)
        self.btn_delete_chat = MonoButton("DELETE")
        self.btn_delete_chat.clicked.connect(self._delete_selected_archive)
        self.btn_clear_chat = MonoButton("CLEAR")
        self.btn_clear_chat.clicked.connect(lambda: self._clear_current_session(delete_archive=False))
        archive_controls.addWidget(self.btn_save_chat)
        archive_controls.addWidget(self.btn_load_chat)
        archive_controls.addWidget(self.btn_delete_chat)
        archive_controls.addWidget(self.btn_clear_chat)
        archive_controls.addStretch()
        archive_layout.addLayout(archive_controls)

        self.archive_list = QListWidget()
        self.archive_list.setStyleSheet(f"""
            QListWidget {{
                background: {_s.BG_INPUT}; color: {_s.FG_TEXT}; border: 1px solid {_s.BORDER_SUBTLE};
                font-family: 'Consolas', monospace; font-size: 10px;
            }}
            QListWidget::item {{ padding: 6px; }}
            QListWidget::item:selected {{ background: {_s.BG_BUTTON_HOVER}; color: {_s.ACCENT_PRIMARY}; }}
            {_s.SCROLLBAR_STYLE}
        """)
        archive_layout.addWidget(self.archive_list)

        self.lbl_behavior = QLabel("BEHAVIOR TAGS")
        self.lbl_behavior.setStyleSheet(
            f"color: {_s.FG_INFO}; font-size: 8px; font-weight: bold; letter-spacing: 1px;"
        )
        self.behavior_tags = BehaviorTagInput([])
        self.behavior_tags.tagsChanged.connect(self._on_behavior_tags_changed)
        self.behavior_tags.setStyleSheet(
            f"background: {_s.BG_SIDEBAR}; border: 1px solid {_s.BORDER_SUBTLE}; border-radius: 2px;"
        )
        self.behavior_tags.setMaximumHeight(36)

        # --- SETTINGS tab: AI Configuration + Save/Reset ---
        settings_tab = QWidget()
        settings_layout = QVBoxLayout(settings_tab)
        settings_layout.setSpacing(10)
        settings_layout.addWidget(self.s_temp)
        settings_layout.addWidget(self.s_top)
        settings_layout.addWidget(self.s_tok)
        settings_layout.addWidget(self.s_ctx)
        settings_layout.addWidget(self.lbl_behavior)
        settings_layout.addWidget(self.behavior_tags)
        settings_layout.addLayout(save_row)
        settings_layout.addStretch()

        self.ops_stack.addWidget(control_tab)
        self.ops_stack.addWidget(archive_tab)
        self.ops_stack.addWidget(settings_tab)
        self.btn_tab_control.toggled.connect(lambda checked: self._switch_ops_tab(0, checked))
        self.btn_tab_archive.toggled.connect(lambda checked: self._switch_ops_tab(1, checked))
        self.btn_tab_settings.toggled.connect(lambda checked: self._switch_ops_tab(2, checked))

        operations_group.add_layout(operations_layout)

        chat_group = MonoGroupBox("CHAT")
        chat_layout = QVBoxLayout()
        chat_layout.setSpacing(10)

        self.message_list = QListWidget()
        self.message_list.setVerticalScrollMode(QListWidget.ScrollPerPixel)
        self.message_list.setStyleSheet(f"""
            QListWidget {{
                background: transparent; color: {_s.FG_TEXT}; border: 1px solid {_s.BORDER_SUBTLE};
                font-family: 'Consolas', monospace; font-size: 12px;
            }}
            QListWidget::item {{
                border: none;
                background: transparent;
                padding: 0px;
            }}
            {_s.SCROLLBAR_STYLE}
        """)
        chat_layout.addWidget(self.message_list)
        
        # --- Input toolbar (between separator and input box) ---
        # --- Input row ---
        input_row = QHBoxLayout()
        self.input = QLineEdit()
        self.input.setPlaceholderText("Enter command...")
        self.input.returnPressed.connect(self.handle_send_click)
        self.input.textChanged.connect(self._on_input_changed)
        self.input.setStyleSheet(f"""
            QLineEdit {{
                background: {_s.BG_INPUT}; color: white; border: 1px solid {_s.BORDER_LIGHT};
                padding: 8px; font-family: 'Verdana'; font-size: 11px;
            }}
            QLineEdit:focus {{ border: 1px solid {_s.ACCENT_PRIMARY}; }}
        """)
        
        self.btn_send = QPushButton("SEND")
        self.btn_send.setCursor(Qt.PointingHandCursor)
        self.btn_send.setFixedWidth(80)
        self._btn_style_template = f"""
            QPushButton {{{{
                background: {{bg}};
                border: 1px solid {{color}};
                color: {{color}};
                padding: 8px;
                font-size: 11px;
                font-weight: bold;
                border-radius: 2px;
            }}}}
            QPushButton:hover {{{{ background: {{color}}; color: black; }}}}
            QPushButton:pressed {{{{ background: {_s.ACCENT_PRIMARY_DARK}; }}}}
        """
        self._set_send_button_state(is_running=False)
        self.btn_send.clicked.connect(self.handle_send_click)

        input_row.addWidget(self.input)
        input_row.addWidget(self.btn_send)
        chat_layout.addLayout(input_row)
        
        chat_group.add_layout(chat_layout)

        right_stack = QSplitter(Qt.Vertical)
        right_stack.setChildrenCollapsible(False)

        trace_group = MonoGroupBox("REASONING TRACE")
        self.trace = QTextEdit()
        self.trace.setReadOnly(True)
        self.trace.setStyleSheet(f"""
            QTextEdit {{
                background-color: {_s.BG_INPUT};
                color: {_s.FG_TEXT};
                border: 1px solid {_s.BORDER_SUBTLE};
                font-family: 'Consolas', monospace;
                font-size: 10px;
            }}
            QTextEdit::viewport {{
                background-color: {_s.BG_INPUT};
            }}
            {_s.SCROLLBAR_STYLE}
        """)
        self.lbl_config_update = QLabel("")
        self.lbl_config_update.setStyleSheet(f"color: {_s.ACCENT_PRIMARY}; font-size: 10px; font-weight: bold;")
        self.lbl_config_update.hide()
        self._config_update_fade = QTimer(self)
        self._config_update_fade.setSingleShot(True)
        self._config_update_fade.timeout.connect(self.lbl_config_update.hide)
        trace_group.add_widget(self.trace)
        trace_group.add_widget(self.lbl_config_update)

        right_stack.addWidget(trace_group)
        right_stack.addWidget(operations_group)
        right_stack.setStretchFactor(0, 1)
        right_stack.setStretchFactor(1, 1)
        right_stack.setSizes([200, 200])

        main_split.addWidget(chat_group)
        main_split.addWidget(right_stack)
        main_split.setStretchFactor(0, 3)
        main_split.setStretchFactor(1, 2)
        self._active_assistant_started = False
        self._active_assistant_token_count = 0

        self._sync_path_display()
        self._update_load_button_text()
        self._refresh_archive_list()
        self._apply_behavior_prompt(self.config.get("behavior_tags", []))
        self.behavior_tags.set_tags(self.config.get("behavior_tags", []))
        self._set_config_dirty(False)
        if not self._is_model_loaded:
            self._apply_default_limits()

    def send(self):
        txt = self.input.text().strip()
        if not txt:
            return
        self.sig_debug.emit(f"[CHAT] send: text={repr(txt[:60])}, msgs={len(self._current_session['messages'])}")
        self._set_send_button_state(is_running=True)
        self.input.clear()
        user_idx = self._add_message("user", txt)
        self._append_message_widget(user_idx)
        self._start_assistant_stream()
        self.message_list.scrollToBottom()
        self.sig_debug.emit(f"[CHAT] about to emit sig_generate: txt={repr(txt[:60])}")
        self.sig_generate.emit(txt, self._thinking_mode)
        self.sig_debug.emit(f"[CHAT] sig_generate emitted")

    def handle_send_click(self):
        txt = self.input.text().strip()

        if not self._is_running:
            self.send()
            return

        if not txt:
            self._set_send_button_state(is_running=True, stopping=True)
            self.sig_stop.emit()
            return

        self._pending_update_text = txt
        self._awaiting_update_restart = True
        self.btn_send.setEnabled(False)
        self._begin_update_trace(txt)
        self.sig_stop.emit()

    def _set_send_button_state(self, is_running: bool, stopping: bool = False):
        self._is_running = is_running
        if is_running:
            has_input = bool(self.input.text().strip())
            if has_input:
                self.btn_send.setText("UPDATE")
                color = _s.ACCENT_PRIMARY
            else:
                self.btn_send.setText("■")
                color = _s.FG_ERROR
            self.btn_send.setStyleSheet(
                self._btn_style_template.format(
                    bg=_s.BG_INPUT,
                    color=color,
                )
            )
            self.btn_send.setEnabled(not stopping)
        else:
            self.btn_send.setText("SEND")
            self.btn_send.setStyleSheet(
                self._btn_style_template.format(
                    bg=_s.BG_INPUT,
                    color=_s.ACCENT_PRIMARY,
                )
            )
            self.btn_send.setEnabled(True)

    def _on_input_changed(self, text):
        if not self._is_running:
            return
        self._set_send_button_state(is_running=True)

    def _send_message(self, text):
        self.input.setText(text)
        self.send()

    def _submit_update(self, update_text):
        self._set_send_button_state(is_running=True)
        self._rewrite_assistant_index = self._active_assistant_index
        partial = "(no output yet)"
        if self._active_assistant_index is not None:
            txt = self._current_session["messages"][self._active_assistant_index]["text"]
            if txt:
                partial = txt

        original = ""
        for msg in reversed(self._current_session["messages"]):
            if msg["role"] == "user":
                original = msg["text"]
                break

        injected = f"""
You were interrupted mid-generation.

Original user request:
{original}

Partial assistant output so far:
{partial}

User update:
{update_text}

Continue from the interruption point. Do not repeat earlier content. Prioritize the user update.
"""

        self.input.clear()
        self._start_update_streaming()
        self.sig_generate.emit(injected, self._thinking_mode)

    def _start_assistant_stream(self):
        self.sig_debug.emit(f"[CHAT] _start_assistant_stream: msgs_before={len(self._current_session['messages'])}")
        self._active_assistant_started = True
        self._active_assistant_token_count = 0

        self._active_assistant_index = self._add_message("assistant", "")
        self._active_widget = self._append_message_widget(self._active_assistant_index)
    

    def _flush_tokens(self):
        if not self._token_buf:
            self._flush_timer.stop()
            return
        chunk = "".join(self._token_buf)
        self._token_buf.clear()
        if self._active_widget is None:
            target_index = self._rewrite_assistant_index
            if target_index is None:
                target_index = self._active_assistant_index
            if target_index is not None:
                self._active_widget = self._widget_for_index(target_index)
        if self._active_widget is None:
            return
        # Check if user is near the bottom before appending (so we don't yank them down)
        sb = self.message_list.verticalScrollBar()
        at_bottom = sb.value() >= sb.maximum() - 40

        self._active_widget.append_token(chunk)
        vw = self.message_list.viewport().width()
        for row in range(self.message_list.count()):
            item = self.message_list.item(row)
            widget = self.message_list.itemWidget(item)
            if widget is self._active_widget:
                if vw > 50:
                    widget.setFixedWidth(vw)
                item.setSizeHint(widget.sizeHint())
                break
        if at_bottom:
            self.message_list.scrollToBottom()

    def append_token(self, t):
        self._token_buf.append(t)
        self._append_assistant_token(t)
        self._update_progress_markers()
        if not self._flush_timer.isActive():
            self._flush_timer.start()

    def on_guard_finished(self, engine_key, task_id):
        if engine_key != getattr(self, "_engine_key", "llm"):
            return
        if not self._current_session.get("messages"):
            return
        try:
            self._save_chat_archive()
        except Exception:
            pass

    def append_trace(self, trace_msg):
        lowered = trace_msg.lower()

        # --- Filter: only show LLM-relevant trace info ---
        # Skip guard internals, status transitions, and noise
        skip_patterns = [
            "guard", "dispatch", "route", "bridge", "dock",
            "addon", "registry", "host", "mount",
        ]
        for pat in skip_patterns:
            if pat in lowered and "error" not in lowered:
                return

        # Categorize what we show
        if "system online" in lowered:
            self._is_model_loaded = True
        elif "model unloaded" in lowered:
            self._is_model_loaded = False

        if "error" in lowered:
            state = "ERROR"
        elif "token" in lowered:
            state = "TOKENIZING"
        elif "inference started" in lowered:
            state = "INFERENCE"
        elif "inference" in lowered and ("complete" in lowered or "aborted" in lowered):
            state = "COMPLETE"
        elif "init backend" in lowered or "system online" in lowered:
            state = "MODEL"
        elif "unload" in lowered or "cancel" in lowered:
            state = "MODEL"
        elif "ctx" in lowered or "context" in lowered:
            state = "CTX"
        else:
            state = "INFO"

        display_msg = trace_msg
        if "→" in display_msg:
            display_msg = display_msg[display_msg.index("→") + 1:].strip()
        elif display_msg.startswith("ERROR"):
            display_msg = display_msg.replace("ERROR:", "").strip()

        self._trace_html(display_msg, state, error=(state == "ERROR"))

    def clear_chat(self):
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)

    def _sync_path_display(self):
        gguf_path = self.config.get("gguf_path")
        if gguf_path:
            self.path_display.setText(gguf_path)
            self.path_display.setToolTip(str(gguf_path))
        else:
            self.path_display.clear()
            self.path_display.setToolTip("")

    def _set_config_dirty(self, dirty=True):
        self._config_dirty = dirty
        self.lbl_config_state.setText("UNSAVED" if dirty else "SAVED")
        self.lbl_config_state.setStyleSheet(
            f"color: {_s.ACCENT_PRIMARY if dirty else _s.FG_DIM}; font-size: 10px; font-weight: bold;"
        )
        # Save button: gold when dirty (action needed), gray when clean
        if dirty:
            self.btn_save_config.setStyleSheet(f"""
                QPushButton {{ background: {_s.BG_BUTTON}; border: 1px solid {_s.ACCENT_PRIMARY}; color: {_s.ACCENT_PRIMARY}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                QPushButton:hover {{ background: {_s.ACCENT_PRIMARY}; color: black; }}
                QPushButton:pressed {{ background: {_s.ACCENT_PRIMARY_DARK}; color: black; }}
            """)
        else:
            self.btn_save_config.setStyleSheet(f"""
                QPushButton {{ background: {_s.BG_BUTTON}; border: 1px solid {_s.BORDER_LIGHT}; color: {_s.FG_DIM}; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 2px; }}
                QPushButton:hover {{ background: {_s.BG_BUTTON_HOVER}; color: {_s.FG_DIM}; }}
            """)

    def _save_config(self):
        save_config(self.config)
        self._last_config_update = QDateTime.currentDateTime()
        stamp = self._last_config_update.toString("HH:mm:ss")
        self.lbl_config_update.setText(f"USER (UPDATED): {stamp}")
        self.lbl_config_update.show()
        self._config_update_fade.start(2500)
        self._set_config_dirty(False)

    def _update_config_value(self, key, value):
        self.config[key] = value
        self._set_config_dirty(True)

    def _set_slider_limits(self, slider, max_value, value):
        qt_slider = slider.slider
        qt_slider.blockSignals(True)
        if slider.is_int:
            min_value = qt_slider.minimum()
            if max_value < min_value:
                min_value = max_value
            qt_slider.setRange(int(min_value), int(max_value))
            qt_slider.setValue(int(value))
            slider.val_lbl.setText(str(int(value)))
        else:
            min_value = qt_slider.minimum()
            max_scaled = int(max_value * 100)
            if max_scaled < min_value:
                min_value = max_scaled
            qt_slider.setRange(min_value, max_scaled)
            qt_slider.setValue(int(value * 100))
            slider.val_lbl.setText(f"{value:.2f}")
        qt_slider.blockSignals(False)

    def _apply_default_limits(self):
        self._set_slider_limits(
            self.s_ctx,
            DEFAULT_CONFIG["ctx_limit"],
            DEFAULT_CONFIG["ctx_limit"],
        )
        self._set_slider_limits(
            self.s_tok,
            DEFAULT_CONFIG["max_tokens"],
            DEFAULT_CONFIG["max_tokens"],
        )

    def _trace_html(self, msg, tag="INFO", error=False):
        arrow_color = _s.FG_ERROR if error else _s.ACCENT_PRIMARY
        tag_color = _s.FG_ERROR if error else _s.FG_PLACEHOLDER
        self.trace.append(
            f"<table width='100%' cellpadding='0' cellspacing='0'><tr>"
            f"<td><span style='color:{arrow_color}'>→</span> {msg}</td>"
            f"<td align='right' style='color:{tag_color}; white-space:nowrap'>[{tag}]</td>"
            f"</tr></table>"
        )

    def _trace_plain(self, msg):
        self.trace.append(f"<span style='color:{_s.FG_PLACEHOLDER}'>{msg}</span>")

    def _on_model_capabilities(self, payload):
        model_ctx_length = payload.get("model_ctx_length")
        if model_ctx_length is None:
            self._apply_default_limits()
            return
        configured_ctx = int(self.config.get("ctx_limit", 8192))
        self._set_slider_limits(self.s_ctx, model_ctx_length, model_ctx_length)
        self._set_slider_limits(
            self.s_tok,
            model_ctx_length,
            min(8192, model_ctx_length),
        )
        # Surface context capacity info in reasoning trace
        if configured_ctx < model_ctx_length:
            pct = int((configured_ctx / model_ctx_length) * 100)
            self._trace_html(
                f"Context: {configured_ctx:,} / {model_ctx_length:,} tokens "
                f"({pct}% of model capacity)",
                "CTX",
            )
            self._trace_html(
                f"Increase context limit in SETTINGS to use full {model_ctx_length:,} capacity",
                "CTX",
            )
        else:
            self._trace_html(
                f"Context: {model_ctx_length:,} tokens (full capacity)",
                "CTX",
            )

    def _on_ctx_limit_changed(self, value):
        self._update_config_value("ctx_limit", int(value))
        self.sig_set_ctx_limit.emit(int(value))

    def _on_behavior_tags_changed(self, tags):
        self._apply_behavior_prompt(tags)

    def _on_thinking_mode_toggled(self, checked):
        self._thinking_mode = bool(checked)
        self.config["thinking_mode"] = self._thinking_mode
        self._set_config_dirty(True)
        self._update_thinking_button_style()

    def _set_thinking_mode(self, enabled, label="Off"):
        self._thinking_mode = enabled
        self.config["thinking_mode"] = enabled
        self._set_config_dirty(True)
        self._update_thinking_button_style()

    def _toggle_options_panel(self):
        self._options_expanded = not self._options_expanded
        self.options_panel.setVisible(self._options_expanded)
        self.btn_options_toggle.setText("▾ OPTIONS" if self._options_expanded else "▸ OPTIONS")

    def _update_thinking_button_style(self):
        # Update the think toggle buttons in the OPTIONS panel
        if hasattr(self, 'btn_think_off'):
            if self._thinking_mode:
                self.btn_think_std.setChecked(True)
            else:
                self.btn_think_off.setChecked(True)

    def _attach_file_placeholder(self):
        """Placeholder for file attachment — backend will be implemented later."""
        pass

    def _reset_config(self):
        """Reset all settings to DEFAULT_CONFIG values."""
        for key, val in DEFAULT_CONFIG.items():
            self.config[key] = val
        self.s_temp.slider.blockSignals(True)
        self.s_top.slider.blockSignals(True)
        self.s_tok.slider.blockSignals(True)
        self.s_ctx.slider.blockSignals(True)
        self.s_temp.slider.setValue(int(DEFAULT_CONFIG["temp"] * 100))
        self.s_temp.val_lbl.setText(f"{DEFAULT_CONFIG['temp']:.2f}")
        self.s_top.slider.setValue(int(DEFAULT_CONFIG["top_p"] * 100))
        self.s_top.val_lbl.setText(f"{DEFAULT_CONFIG['top_p']:.2f}")
        self.s_tok.slider.setValue(int(DEFAULT_CONFIG["max_tokens"]))
        self.s_tok.val_lbl.setText(str(int(DEFAULT_CONFIG["max_tokens"])))
        self.s_ctx.slider.setValue(int(DEFAULT_CONFIG["ctx_limit"]))
        self.s_ctx.val_lbl.setText(str(int(DEFAULT_CONFIG["ctx_limit"])))
        self.s_temp.slider.blockSignals(False)
        self.s_top.slider.blockSignals(False)
        self.s_tok.slider.blockSignals(False)
        self.s_ctx.slider.blockSignals(False)
        self.sig_set_ctx_limit.emit(int(DEFAULT_CONFIG["ctx_limit"]))
        self.behavior_tags.set_tags(DEFAULT_CONFIG.get("behavior_tags", []))
        self._set_thinking_mode(False)
        self._set_config_dirty(True)

    def pick_file(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select GGUF", "", "GGUF (*.gguf)")
        if path:
            self.config["gguf_path"] = path
            self.sig_set_model_path.emit(path)
            self._sync_path_display()
            self._set_config_dirty(True)

    def toggle_load(self):
        if self._is_model_loaded:
            self.sig_unload.emit()
        else:
            self.sig_load.emit()

    def _update_load_button_text(self):
        self.btn_load.setText("UNLOAD MODEL" if self._is_model_loaded else "LOAD MODEL")

    def _request_mutation(self, fn):
        """Run a session mutation safely.

        If a generation is currently running, STOP first, then run `fn` on the next READY.
        This prevents stale indices / widgets during streaming.
        """
        if self._is_running:
            # Cancel any queued UPDATE-restart; mutation wins.
            self._awaiting_update_restart = False
            self._pending_update_text = None
            self._pending_mutation = fn
            self._set_send_button_state(is_running=True, stopping=True)
            self.sig_stop.emit()
            return
        fn()

    def update_status(self, engine_key: str, status: SystemStatus):
        ek_short = engine_key[-8:] if engine_key else "?"
        prev = getattr(self, '_last_status', None)
        transition = f"{prev.name if prev else '?'}→{status.name}" if hasattr(status, 'name') else str(status)
        self.sig_debug.emit(f"[CHAT:{ek_short}] status {transition}, running={self._is_running}, mutation={'yes' if self._pending_mutation else 'no'}")
        if engine_key != getattr(self, "_engine_key", "llm"):
            return
        is_processing = status in (SystemStatus.LOADING, SystemStatus.RUNNING, SystemStatus.UNLOADING)
        self.btn_load.setEnabled(not is_processing)
        if is_processing:
            self.btn_load.setText("PROCESSING...")
        else:
            self._update_load_button_text()
        if status == SystemStatus.READY and self._pending_mutation is not None:
            # Finish transition to READY (stop state) first, then mutate.
            # Keep this path above UPDATE-restart.
            self._set_send_button_state(is_running=False)
            self._rewrite_assistant_index = None
            if self._active_widget is not None:
                self._active_widget.finalize()
            self._active_widget = None
            if self._update_trace_state == "streaming":
                self._finalize_update_progress()
            # If generation ended before any tokens arrived, remove the empty assistant bubble.
            self._cleanup_empty_assistant_if_needed()
            # Reset assistant stream trackers after end-of-generation.
            self._active_assistant_started = False
            self._active_assistant_token_count = 0
            self._suppress_title_regen = False
            pending = self._pending_mutation
            self._pending_mutation = None
            try:
                pending()
            finally:
                self._last_status = status
            return

        if status == SystemStatus.READY and self._awaiting_update_restart:
            self._awaiting_update_restart = False
            self.btn_send.setEnabled(True)

            update_text = self._pending_update_text
            self._pending_update_text = None
            self._submit_update(update_text)
            return
        if status == SystemStatus.RUNNING:
            self._set_send_button_state(is_running=True)
        elif status == SystemStatus.READY:
            if self._last_status == SystemStatus.LOADING:
                self._is_model_loaded = True
                self._update_load_button_text()
            elif self._last_status == SystemStatus.UNLOADING:
                self._is_model_loaded = False
                self._update_load_button_text()
            self._set_send_button_state(is_running=False)
            self._rewrite_assistant_index = None
            if self._active_widget is not None:
                self._active_widget.finalize()
            self._active_widget = None
            if self._update_trace_state == "streaming":
                self._finalize_update_progress()
            # If generation ended before any tokens arrived, remove the empty assistant bubble.
            self._cleanup_empty_assistant_if_needed()
            # Reset assistant stream trackers after end-of-generation.
            self._active_assistant_started = False
            self._active_assistant_token_count = 0
            # Title generation is finalized ONLY on READY.

            # READY is emitted after _on_gen_finish completes and assistant text is final.
            # STOP also transitions to READY; _maybe_generate_title self-guards.
            # Do NOT call this method from token flush, send paths, or mutation handlers.
            if self._pending_mutation is None:
                self._maybe_generate_title()
            self._suppress_title_regen = False
        elif status == SystemStatus.LOADING:
            self._set_send_button_state(is_running=False)
            self.btn_send.setEnabled(False)
        elif status in (SystemStatus.UNLOADING, SystemStatus.ERROR):
            self._is_model_loaded = False
            if not is_processing:
                self._update_load_button_text()

        if status == SystemStatus.READY and not self._is_model_loaded:
            self._apply_default_limits()
        self._last_status = status

    def _switch_ops_tab(self, index, checked):
        if checked:
            self.ops_stack.setCurrentIndex(index)


    def apply_operator(self, operator_data: dict):
        if not isinstance(operator_data, dict):
            return
        config = operator_data.get("config")
        if not isinstance(config, dict):
            return

        slider_values = {
            "temp": float(config.get("temp", self.config.get("temp", 0.7))),
            "top_p": float(config.get("top_p", self.config.get("top_p", 0.9))),
            "max_tokens": int(config.get("max_tokens", self.config.get("max_tokens", 2048))),
            "ctx_limit": int(config.get("ctx_limit", self.config.get("ctx_limit", 8192))),
        }

        self.config.update(config)

        self.s_temp.slider.blockSignals(True)
        self.s_top.slider.blockSignals(True)
        self.s_tok.slider.blockSignals(True)
        self.s_ctx.slider.blockSignals(True)
        self.s_temp.slider.setValue(int(slider_values["temp"] * 100))
        self.s_temp.val_lbl.setText(f"{slider_values['temp']:.2f}")
        self.s_top.slider.setValue(int(slider_values["top_p"] * 100))
        self.s_top.val_lbl.setText(f"{slider_values['top_p']:.2f}")
        self.s_tok.slider.setValue(int(slider_values["max_tokens"]))
        self.s_tok.val_lbl.setText(str(int(slider_values["max_tokens"])))
        self.s_ctx.slider.setValue(int(slider_values["ctx_limit"]))
        self.s_ctx.val_lbl.setText(str(int(slider_values["ctx_limit"])))
        self.s_temp.slider.blockSignals(False)
        self.s_top.slider.blockSignals(False)
        self.s_tok.slider.blockSignals(False)
        self.s_ctx.slider.blockSignals(False)

        self.sig_set_ctx_limit.emit(int(slider_values["ctx_limit"]))

        tags = config.get("behavior_tags", [])
        self.behavior_tags.set_tags(tags if isinstance(tags, list) else [])

        thinking_mode = bool(config.get("thinking_mode", False))
        self._set_thinking_mode(thinking_mode, "Standard" if thinking_mode else "Off")

        gguf_path = config.get("gguf_path")
        if gguf_path:
            self.config["gguf_path"] = gguf_path
            self.sig_set_model_path.emit(str(gguf_path))
        self._sync_path_display()

        # Restore chat messages if snapshot included them, otherwise fresh session
        messages = operator_data.get("messages")
        if isinstance(messages, list) and messages:
            session = self._create_session(
                messages=messages,
                title=operator_data.get("session_title"),
                assistant_tokens=operator_data.get("assistant_tokens", 0),
            )
            self._set_current_session(session, show_reset=True, sync_history=True)
        else:
            self._start_new_session()

        self._set_config_dirty(True)
        self.sig_operator_loaded.emit(str(operator_data.get("name", "")))

    def _start_new_session(self):
        self._title_generated = False
        self._suppress_title_regen = False
        self.trace.clear()
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._trace_plain("--- TRACE RESET ---")

    def _prompt_clear_session(self):
        dialog = QMessageBox(self)
        dialog.setWindowTitle("Clear Session")
        dialog.setText("Choose how to clear the current session.")
        dialog.setStyleSheet(f"""
            QMessageBox {{
                background: {_s.BG_INPUT};
                color: {_s.FG_TEXT};
            }}
            QLabel {{
                color: {_s.FG_TEXT};
            }}
            QPushButton {{
                color: {_s.FG_TEXT};
                background: transparent;
                border: 1px solid {_s.BORDER_LIGHT};
                padding: 6px 12px;
                font-size: 10px;
                font-weight: bold;
                border-radius: 2px;
            }}
            QPushButton:hover {{
                border: 1px solid {_s.ACCENT_PRIMARY};
                color: {_s.ACCENT_PRIMARY};
            }}
            QPushButton:checked {{
                border: 1px solid {_s.ACCENT_PRIMARY};
                color: {_s.ACCENT_PRIMARY};
            }}
        """)
        btn_clear = dialog.addButton("Clear Logs", QMessageBox.AcceptRole)
        btn_delete = dialog.addButton("Delete Chat", QMessageBox.DestructiveRole)
        dialog.addButton("Cancel", QMessageBox.RejectRole)
        dialog.exec()
        clicked = dialog.clickedButton()
        if clicked == btn_clear:
            self._clear_current_session(delete_archive=False)
        elif clicked == btn_delete:
            self._clear_current_session(delete_archive=True)

    def _clear_current_session(self, delete_archive):
        archive_path = self._current_session.get("archive_path")
        if delete_archive and archive_path:
            try:
                Path(archive_path).unlink()
            except OSError:
                pass
        self.trace.clear()
        self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._refresh_archive_list()

    def _delete_selected_archive(self):
        item = self.archive_list.currentItem()
        if not item:
            return
        archive_path = Path(item.data(Qt.UserRole))
        try:
            archive_path.unlink()
        except OSError:
            return
        if self._current_session.get("archive_path") == str(archive_path):
            self._set_current_session(self._create_session(), show_reset=True, sync_history=True)
        self._refresh_archive_list()

    def _save_chat_archive(self):
        session = self._current_session
        messages = session["messages"]
        now = self._now_iso()
        created_at = session.get("created_at") or now
        updated_at = now
        title = self._current_session.get("title") or self._derive_title(messages)
        summary = self._build_summary(messages)
        message_payload = []
        for idx, msg in enumerate(messages, start=1):
            message_payload.append({
                "i": idx,
                "time": msg.get("time") or now,
                "role": msg.get("role", "user"),
                "text": msg.get("text", "")
            })
        meta = {
            "title": title,
            "created_at": created_at,
            "updated_at": updated_at,
            "message_count": len(message_payload),
            "assistant_tokens": int(session.get("assistant_tokens", 0)),
            "summary": summary
        }
        payload = {"meta": meta, "messages": message_payload}
        archive_path = session.get("archive_path")
        if not archive_path:
            slug = self._slugify(title)
            stamp = now.replace(":", "-").replace(".", "-")
            archive_path = self._archive_dir / f"{slug}_{stamp}.json"
        else:
            archive_path = Path(archive_path)
        archive_path.parent.mkdir(parents=True, exist_ok=True)
        with archive_path.open("w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2)
        session["archive_path"] = str(archive_path)
        session["created_at"] = created_at
        session["updated_at"] = updated_at
        session["summary"] = summary
        self._refresh_archive_list()

    def _load_chat_archive(self):
        item = self.archive_list.currentItem()
        if not item:
            return
        archive_path = Path(item.data(Qt.UserRole))
        try:
            with archive_path.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
        except Exception:
            QMessageBox.warning(self, "Load Failed", "Could not read archive file.")
            return
        meta = data.get("meta", {})
        messages = []
        for msg in data.get("messages", []):
            role = msg.get("role", "user")
            text = msg.get("text", "")
            time = msg.get("time", meta.get("updated_at", self._now_iso()))
            messages.append({"i": msg.get("i"), "time": time, "role": role, "text": text})
        session = self._create_session(
            messages=messages,
            created_at=meta.get("created_at"),
            updated_at=meta.get("updated_at"),
            archive_path=str(archive_path),
            summary=meta.get("summary", []),
            title=meta.get("title"),
            assistant_tokens=int(meta.get("assistant_tokens", meta.get("token_count", 0)))
        )
        self._set_current_session(session, show_reset=False, sync_history=True)
        self._notify_header_update()

    def _refresh_archive_list(self):
        self.archive_list.clear()
        items = []
        for path in sorted(self._archive_dir.glob("*.json")):
            try:
                with path.open("r", encoding="utf-8") as handle:
                    data = json.load(handle)
            except Exception:
                continue
            meta = data.get("meta", {})
            title = meta.get("title", path.stem)
            summary = meta.get("summary", [])
            tooltip = "\n".join(summary) if summary else title
            updated_at = meta.get("updated_at", "")
            message_count = meta.get("message_count", len(data.get("messages", [])))
            assistant_tokens = int(meta.get("assistant_tokens", meta.get("token_count", 0)))
            items.append((updated_at, title, message_count, assistant_tokens, str(path), tooltip))
        items.sort(key=lambda item: item[0], reverse=True)
        for updated_at, title, message_count, assistant_tokens, path, tooltip in items:
            date_label = updated_at.split("T")[0] if updated_at else "Unknown date"
            subtext = f"{date_label} • {message_count} msgs • {assistant_tokens} assistant tokens"
            list_item = QListWidgetItem(f"{title}\n{subtext}")
            list_item.setData(Qt.UserRole, path)
            list_item.setToolTip(tooltip)
            self.archive_list.addItem(list_item)

    def _create_session(self, messages=None, created_at=None, updated_at=None, archive_path=None, summary=None, title=None, assistant_tokens=0):
        self._session_counter += 1
        now = self._now_iso()
        return {
            "id": self._session_counter,
            "created_at": created_at or now,
            "updated_at": updated_at or now,
            "messages": messages or [],
            "archive_path": archive_path,
            "summary": summary or [],
            "title": title,
            "assistant_tokens": int(assistant_tokens),
        }

    def _set_current_session(self, session, show_reset=False, sync_history=False):
        self._current_session = session
        self._undo_snapshot = None
        self._active_assistant_index = None
        self._rewrite_assistant_index = None
        self._active_widget = None
        self._title_generated = bool(session.get("title"))
        self._suppress_title_regen = False
        self._render_session(session, show_reset=show_reset)
        if sync_history:
            history = self._build_engine_history_from_session()
            self.sig_sync_history.emit(history)
        self._notify_header_update()

    def _build_engine_history_from_session(self):
        """
        Convert _current_session["messages"] into engine-ready history.

        Always include:
          {"role": "system", "content": MASTER_PROMPT}

        Then append each session message as:
          {"role": msg["role"], "content": msg["text"]}

        Behavior tags are NOT included here.
        Engine recompiles system prompt at generation time.
        """
        history = [{"role": "system", "content": MASTER_PROMPT}]
        for msg in self._current_session.get("messages", []):
            if not isinstance(msg, dict):
                continue
            role = msg.get("role")
            text = msg.get("text")
            if not isinstance(role, str) or not isinstance(text, str):
                continue
            history.append({"role": role, "content": text})
        return history

    def _snapshot_session(self):
        self._undo_snapshot = [dict(m) for m in self._current_session["messages"]]

    def _undo_last_mutation(self):
        if not self._undo_snapshot:
            return
        self._current_session["messages"] = self._undo_snapshot
        self._undo_snapshot = None
        self._render_session()
        self.sig_sync_history.emit(
            self._build_engine_history_from_session()
        )

    def _delete_from_index(self, idx: int):
        self.sig_debug.emit(f"[CHAT] _delete_from_index: idx={idx}, msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_delete():
            self._snapshot_session()
            msgs = self._current_session["messages"]
            if idx < 0 or idx >= len(msgs):
                return
            del msgs[idx:]
            # Reset any stale streaming pointers.
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )

        self._request_mutation(_do_delete)

    def _edit_from_index(self, idx: int):
        self.sig_debug.emit(f"[CHAT] _edit_from_index: idx={idx}, msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_edit():
            msgs = self._current_session["messages"]
            if idx < 0 or idx >= len(msgs):
                return
            text = msgs[idx].get("text", "")
            self._suppress_title_regen = True
            # Inline delete to avoid nested mutation requests.
            self._snapshot_session()
            del msgs[idx:]
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )
            self.input.setText(text)

        self._request_mutation(_do_edit)

    def _regen_last_assistant(self):
        self.sig_debug.emit(f"[CHAT] _regen_last_assistant: msgs={len(self._current_session['messages'])}, is_running={self._is_running}")
        def _do_regen():
            msgs = self._current_session["messages"]
            if not msgs or msgs[-1].get("role") != "assistant":
                return
            self._snapshot_session()
            self._suppress_title_regen = True
            del msgs[-1]
            self._active_assistant_index = None
            self._rewrite_assistant_index = None
            self._active_widget = None
            self._token_buf.clear()
            if self._flush_timer.isActive():
                self._flush_timer.stop()
            self._render_session()
            self.sig_sync_history.emit(
                self._build_engine_history_from_session()
            )

            for m in reversed(msgs):
                if m.get("role") == "user":
                    self._set_send_button_state(is_running=True)
                    self._start_assistant_stream()
                    self.message_list.scrollToBottom()
                    self.sig_generate.emit(m.get("text", ""), self._thinking_mode)
                    break

        self._request_mutation(_do_regen)

    def _render_session(self, session=None, show_reset=False):
        if session is None:
            session = self._current_session
        self.sig_debug.emit(f"[CHAT] _render_session: msgs={len(session['messages'])}, show_reset={show_reset}")
        self.message_list.clear()
        self._active_widget = None
        if not session["messages"]:
            return
        for idx, _msg in enumerate(session["messages"]):
            self._append_message_widget(idx)
        self.message_list.scrollToBottom()

    def _append_message_widget(self, idx: int, role=None, text=None, timestamp=None):
        if idx >= 0:
            msg = self._current_session["messages"][idx]
            role = msg.get("role", "")
            text = msg.get("text", "")
            timestamp = msg.get("time", "")
        item = QListWidgetItem()
        widget = MessageWidget(idx, role or "", text or "", timestamp or "")
        widget.sig_delete.connect(self._delete_from_index)
        widget.sig_edit.connect(self._edit_from_index)
        widget.sig_regen.connect(lambda _idx: self._regen_last_assistant())
        vw = self.message_list.viewport().width()
        if vw > 50:
            widget.setFixedWidth(vw)
        item.setSizeHint(widget.sizeHint())
        self.message_list.addItem(item)
        self.message_list.setItemWidget(item, widget)
        return widget

    def _widget_for_index(self, idx: int):
        for row in range(self.message_list.count()):
            item = self.message_list.item(row)
            widget = self.message_list.itemWidget(item)
            if isinstance(widget, MessageWidget) and getattr(widget, "_index", None) == idx:
                return widget
        return None

    def _apply_behavior_prompt(self, tags):
        cleaned = [tag.strip() for tag in tags if tag.strip()]
        self.config["behavior_tags"] = cleaned
        self._set_config_dirty(True)

    def _begin_update_trace(self, update_text):
        self._update_trace_state = "requested"
        self._update_token_count = 0
        self._update_progress_index = 0
        self._trace_html("UPDATE REQUESTED", "UPDATE")
        self._trace_html(f'USER PATCH: "{update_text}"', "UPDATE")

    def _start_update_streaming(self):
        self._update_trace_state = "streaming"
        self._update_token_count = 0
        self._update_progress_index = 0

    def _update_progress_markers(self):
        if self._update_trace_state != "streaming":
            return
        self._update_token_count += 1
        thresholds = [25, 50, 100]
        pct = min(
            100,
            int((self._update_token_count / self.config["max_tokens"]) * 100),
        )
        while self._update_progress_index < len(thresholds):
            if pct >= thresholds[self._update_progress_index]:
                percent = thresholds[self._update_progress_index]
                self._trace_html(f"UPDATE PROGRESS {percent}%", "UPDATE")
                self._update_progress_index += 1
                continue
            break

    def _finalize_update_progress(self):
        if self._update_trace_state != "streaming":
            return
        thresholds = [25, 50, 100]
        while self._update_progress_index < len(thresholds):
            percent = thresholds[self._update_progress_index]
            self._trace_html(f"UPDATE PROGRESS {percent}%", "UPDATE")
            self._update_progress_index += 1
        self._update_trace_state = None

    def _add_message(self, role, text):
        now = self._now_iso()
        message = {
            "i": len(self._current_session["messages"]) + 1,
            "time": now,
            "role": role,
            "text": text
        }
        self._current_session["messages"].append(message)
        self._current_session["updated_at"] = now
        return len(self._current_session["messages"]) - 1

    def _append_assistant_token(self, token):
        target_index = self._rewrite_assistant_index
        if target_index is None:
            target_index = self._active_assistant_index
        if target_index is None:
            return

        msg = self._current_session["messages"][target_index]
        msg["text"] += token
        self._active_assistant_token_count += 1
        msg["time"] = self._now_iso()
        self._current_session["updated_at"] = msg["time"]
        self._current_session["assistant_tokens"] = int(self._current_session.get("assistant_tokens", 0)) + 1


    def _cleanup_empty_assistant_if_needed(self):
        """Remove a placeholder assistant message if generation ended before any tokens arrived."""
        idx = self._active_assistant_index
        if idx is None:
            return
        if not getattr(self, "_active_assistant_started", False):
            return
        if int(getattr(self, "_active_assistant_token_count", 0)) > 0:
            return

        msgs = self._current_session.get("messages", [])
        if 0 <= idx < len(msgs):
            msg = msgs[idx]
            if msg.get("role") == "assistant" and (msg.get("text") or "") == "":
                del msgs[idx]
                # After deletion, any stored indices are stale.
                self._active_assistant_index = None
                self._rewrite_assistant_index = None
                self._active_widget = None
                self._token_buf.clear()
                if self._flush_timer.isActive():
                    self._flush_timer.stop()
                self._render_session()
                self.sig_sync_history.emit(self._build_engine_history_from_session())
                return
    def _maybe_generate_title(self):
        if self._suppress_title_regen:
            return
        if self._title_generated:
            return
        if self._current_session.get("title"):
            self._title_generated = True
            return
        if not any(m.get("role") == "user" and m.get("text", "").strip() for m in self._current_session["messages"]):
            return
        title = self._derive_title(self._current_session["messages"])
        self._current_session["title"] = title
        self._title_generated = True
        self._notify_header_update()

    def _topic_dominant(self):
        user_text = " ".join([m.get("text", "") for m in self._current_session["messages"] if m.get("role") == "user"])
        words = [w.lower() for w in re.findall(r"[a-zA-Z]{4,}", user_text)]
        if not words:
            return False
        counts = {}
        for word in words:
            counts[word] = counts.get(word, 0) + 1
        return max(counts.values()) >= 3

    def _notify_header_update(self):
        dt = QDateTime.currentDateTime().toString("ddd • HH:mm")
        title = self._current_session.get("title") or self._derive_title(self._current_session.get("messages", []))
        self.ui_bridge.sig_terminal_header.emit(getattr(self, "_mod_id", ""), title, dt)

    def _derive_title(self, messages):
        stopwords = {
            "a", "an", "and", "are", "as", "at", "be", "but", "by", "for", "from",
            "how", "i", "if", "in", "into", "is", "it", "me", "my", "of", "on", "or",
            "our", "please", "so", "that", "the", "their", "them", "then", "there", "these",
            "this", "to", "us", "we", "what", "when", "where", "which", "who", "why", "with",
            "you", "your",
        }
        user_texts = []
        for msg in messages:
            if msg.get("role") != "user":
                continue
            text = " ".join((msg.get("text") or "").lower().split())
            if text:
                user_texts.append(text)
            if len(user_texts) == 3:
                break

        if not user_texts:
            return "chat"

        candidates = []
        counts = {}
        for text in user_texts:
            for token in re.findall(r"[a-z0-9]+", text):
                if token in stopwords or len(token) < 3:
                    continue
                if token not in counts:
                    candidates.append(token)
                    counts[token] = 0
                counts[token] += 1

        ranked = sorted(candidates, key=lambda token: (-counts[token], candidates.index(token)))
        title_tokens = ranked[:6]
        title = " ".join(title_tokens)
        title = re.sub(r"\s+", " ", title).strip()
        title = re.sub(r"[^a-z0-9\- ]+", "", title)
        if len(title) > 40:
            title = title[:40].rstrip()
        return title or "chat"

    def _build_summary(self, messages):
        summary = []
        title = self._current_session.get("title") or self._derive_title(messages)
        summary.append(f"Title: {title}")
        user_msgs = [m["text"] for m in messages if m.get("role") == "user" and m.get("text")]
        assistant_msgs = [m["text"] for m in messages if m.get("role") == "assistant" and m.get("text")]

        def _trim(text, limit=120):
            return text if len(text) <= limit else f"{text[:limit]}…"

        for msg in user_msgs[-3:]:
            summary.append(f"User: {_trim(msg)}")
        for msg in assistant_msgs[-3:]:
            summary.append(f"Assistant: {_trim(msg)}")
        if len(summary) < 3:
            summary.append(f"Messages: {len(messages)}")
        if len(summary) < 3:
            summary.append("Summary: Not enough messages yet.")
        return summary[:6]

    def _slugify(self, text):
        slug = re.sub(r"[^a-z0-9]+", "-", text.lower()).strip("-")
        return slug or "chat"

    def _now_iso(self):
        return datetime.now(timezone.utc).isoformat()

    def _get_archive_dir(self):
        return ARCHIVE_DIR


================================================================================
FILE: .\ui\pages\databank.py
================================================================================

import os
import shutil
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, 
    QTreeView, QHeaderView, QFileSystemModel, QInputDialog, 
    QLabel, QMessageBox, QMenu
)
from PySide6.QtCore import QDir, Qt
from PySide6.QtGui import QAction

from ui.components.atoms import MonoGroupBox, MonoButton
import core.style as _s  # dynamic theme bridge

class TerminalFileTree(QTreeView):
    def __init__(self, start_path):
        super().__init__()
        self.model = QFileSystemModel()
        
        self.model.setReadOnly(False)
        self.model.setFilter(QDir.AllEntries | QDir.NoDotAndDotDot)
        self.model.setNameFilterDisables(False)
        
        self.change_root(start_path)
        self.setModel(self.model)

        self.setDragEnabled(True) 
        self.setDragDropMode(QTreeView.DragOnly)

        self.setStyleSheet(f"""
            QTreeView {{
                background: {_s.BG_INPUT};
                color: {_s.FG_SECONDARY};
                border: 1px solid {_s.BORDER_DARK};
                font-family: 'Consolas', monospace;
                font-size: 12px;
                outline: 0;
            }}
            QTreeView::item {{ padding: 4px; }}
            QTreeView::item:hover {{ background: {_s.BG_BUTTON_HOVER}; }}
            QTreeView::item:selected {{ background: {_s.ACCENT_PRIMARY}; color: black; }}
            
            QHeaderView::section {{
                background: {_s.BG_SIDEBAR};
                color: {_s.FG_DIM};
                border: none;
                padding: 4px;
                font-weight: bold;
            }}
        """)
        
        self.header().setSectionResizeMode(0, QHeaderView.Stretch)
        self.setColumnWidth(1, 80)
        self.setColumnHidden(2, True) 
        self.setColumnHidden(3, True) 
        self.setAnimated(False)
        self.setIndentation(20)
        self.setSortingEnabled(False)
        self.setContextMenuPolicy(Qt.CustomContextMenu)

    def change_root(self, path):
        abs_path = os.path.abspath(path)
        if not os.path.exists(abs_path):
            try:
                os.makedirs(abs_path)
            except OSError:
                pass 
                
        self.model.setRootPath(abs_path)
        self.setRootIndex(self.model.index(abs_path))

class PageFiles(QWidget):
    def __init__(self, state):
        super().__init__()
        self.state = state
        
        base_dir = "C:\\Models\\knowledge_base"
        if not os.path.exists("C:\\Models"):
            base_dir = os.path.join(os.getcwd(), "knowledge_base")
            
        self.current_path = base_dir
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        
        grp = MonoGroupBox("FILES")
        gl = QVBoxLayout()
        gl.setSpacing(10)
        
        # --- TOP EXPLORER BAR ---
        nav_bar = QHBoxLayout()
        
        self.inp_path = QLineEdit()
        self.inp_path.setText(self.current_path)
        self.inp_path.setPlaceholderText("Path...")
        self.inp_path.setStyleSheet(f"""
            QLineEdit {{
                background: {_s.BG_INPUT}; color: {_s.ACCENT_PRIMARY}; 
                border: 1px solid {_s.BORDER_LIGHT}; padding: 6px; font-family: 'Consolas';
            }}
        """)
        self.inp_path.returnPressed.connect(self.navigate_to_path)
        
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText("Search files...")
        self.inp_search.setFixedWidth(200)
        self.inp_search.setStyleSheet(f"""
            QLineEdit {{
                background: {_s.BG_INPUT}; color: white; 
                border: 1px solid {_s.BORDER_LIGHT}; padding: 6px;
            }}
        """)
        self.inp_search.textChanged.connect(self.on_search)
        
        nav_bar.addWidget(QLabel("📂"))
        nav_bar.addWidget(self.inp_path)
        nav_bar.addSpacing(10)
        nav_bar.addWidget(QLabel("🔍"))
        nav_bar.addWidget(self.inp_search)
        gl.addLayout(nav_bar)
        
        # --- FILE TREE ---
        self.tree = TerminalFileTree(self.current_path)
        self.tree.customContextMenuRequested.connect(self.open_menu)
        self.tree.clicked.connect(self.on_click_item) 
        gl.addWidget(self.tree)
        
        # --- BOTTOM ACTION BAR ---
        actions = QHBoxLayout()
        
        btn_add = MonoButton("+ MKDIR")
        btn_add.clicked.connect(self.new_folder)
        
        btn_del = MonoButton("× DELETE")
        btn_del.clicked.connect(self.delete_item)
        
        btn_ref = MonoButton("⟳ REFRESH")
        btn_ref.clicked.connect(self.refresh)
        
        self.lbl_status = QLabel("Ready")
        self.lbl_status.setStyleSheet(f"color: {_s.FG_DIM}; font-size: 10px;")
        
        actions.addWidget(btn_add)
        actions.addWidget(btn_del)
        actions.addWidget(btn_ref)
        actions.addStretch()
        actions.addWidget(self.lbl_status)
        
        gl.addLayout(actions)
        grp.add_layout(gl)
        layout.addWidget(grp)

    def navigate_to_path(self):
        new_path = self.inp_path.text()
        if os.path.exists(new_path):
            self.current_path = new_path
            self.tree.change_root(new_path)
            self.lbl_status.setText(f"Navigated to: {new_path}")
        else:
            self.lbl_status.setText("Error: Path does not exist")

    def on_click_item(self, index):
        path = self.tree.model.filePath(index)
        if os.path.isdir(path):
            self.inp_path.setText(path)

    def refresh(self):
        self.tree.change_root(self.current_path)
        self.lbl_status.setText("Refreshed")

    def on_search(self, text):
        if text:
            self.tree.model.setNameFilters([f"*{text}*"])
        else:
            self.tree.model.setNameFilters([])

    def get_selected_path(self):
        indexes = self.tree.selectedIndexes()
        if indexes:
            return self.tree.model.filePath(indexes[0])
        return self.current_path

    def new_folder(self):
        target_path = self.get_selected_path()
        if os.path.isfile(target_path):
            target_path = os.path.dirname(target_path)
            
        name, ok = self.ask_input("New Folder", "Folder Name:")
        if ok and name:
            new_dir = os.path.join(target_path, name)
            try:
                os.makedirs(new_dir, exist_ok=True)
                self.lbl_status.setText(f"Created: {name}")
            except Exception as e:
                self.lbl_status.setText(f"Error: {e}")

    def delete_item(self):
        target = self.get_selected_path()
        if target == self.current_path:
            self.lbl_status.setText("Cannot delete root folder")
            return
            
        if os.path.exists(target):
            msg = QMessageBox(self)
            msg.setWindowTitle("Confirm Delete")
            msg.setText(f"Are you sure you want to delete:\\n{os.path.basename(target)}?")
            msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            msg.setStyleSheet(f"""
                QMessageBox {{ background: {_s.BG_MAIN}; }}
                QLabel {{ color: {_s.FG_TEXT}; }}
                QPushButton {{ background: {_s.BG_BUTTON_HOVER}; color: {_s.FG_SECONDARY}; border: 1px solid {_s.FG_INFO}; padding: 5px; }}
            """)
            if msg.exec() == QMessageBox.Yes:
                try:
                    if os.path.isdir(target):
                        shutil.rmtree(target)
                    else:
                        os.remove(target)
                    self.lbl_status.setText("Item deleted")
                except Exception as e:
                    self.lbl_status.setText(f"Delete Error: {e}")

    def open_menu(self, position):
        menu = QMenu()
        menu.setStyleSheet(f"""
            QMenu {{ background: {_s.BG_SIDEBAR}; color: {_s.FG_TEXT}; border: 1px solid {_s.ACCENT_PRIMARY}; }}
            QMenu::item:selected {{ background: {_s.ACCENT_PRIMARY}; color: black; }}
        """)
        
        act_del = QAction("Delete", self)
        act_del.triggered.connect(self.delete_item)
        
        act_new = QAction("New Folder", self)
        act_new.triggered.connect(self.new_folder)
        
        menu.addAction(act_new)
        menu.addAction(act_del)
        menu.exec(self.tree.viewport().mapToGlobal(position))

    def ask_input(self, title, label):
        dlg = QInputDialog(self)
        dlg.setWindowTitle(title)
        dlg.setLabelText(label)
        dlg.setStyleSheet(f"""
            QDialog {{ background: {_s.BG_MAIN}; border: 1px solid {_s.ACCENT_PRIMARY}; }}
            QLabel {{ color: {_s.FG_TEXT}; }}
            QLineEdit {{ background: {_s.BG_INPUT}; color: white; border: 1px solid {_s.BORDER_LIGHT}; }}
            QPushButton {{ background: {_s.BG_BUTTON_HOVER}; color: {_s.FG_SECONDARY}; border: 1px solid {_s.FG_INFO}; padding: 5px; }}
        """)
        ok = dlg.exec()
        return dlg.textValue(), (ok == 1)



================================================================================
FILE: .\ui\pages\hub.py
================================================================================

from PySide6.QtCore import Signal, Qt
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QLabel,
    QGridLayout,
    QFrame,
    QPushButton,
    QHBoxLayout,
    QDialog,
    QLineEdit,
    QMessageBox,
    QComboBox,
)

from core.operators import OperatorManager
from core.themes import list_themes, current_theme, apply_theme
from core.theme_config import save_theme_config
from ui.components.atoms import MonoButton


class _NameDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        import core.style as s
        self.setWindowTitle("New Operator")
        self.setModal(True)
        self.setStyleSheet(f"""
            QDialog {{ background: {s.BG_INPUT}; color: {s.FG_TEXT}; }}
            QLineEdit {{ background: {s.BG_INPUT}; color: {s.FG_TEXT}; border: 1px solid {s.BORDER_LIGHT}; padding: 6px; }}
            QPushButton {{ color: {s.FG_TEXT}; background: transparent; border: 1px solid {s.BORDER_LIGHT}; padding: 6px 12px; }}
            QPushButton:hover {{ border: 1px solid {s.ACCENT_PRIMARY}; color: {s.ACCENT_PRIMARY}; }}
        """)
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Operator name:"))
        self.input = QLineEdit()
        layout.addWidget(self.input)
        row = QHBoxLayout()
        row.addStretch()
        ok_btn = MonoButton("OK")
        cancel_btn = MonoButton("CANCEL")
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)
        row.addWidget(ok_btn)
        row.addWidget(cancel_btn)
        layout.addLayout(row)

    def value(self) -> str:
        return self.input.text().strip()

class _OperatorCard(QPushButton):
    """Glassmorphic operator card with structured info."""
    sig_double_clicked = Signal(str)

    def __init__(self, name: str, gguf_path: str, tag_count: int, module_count: int = 0):
        super().__init__()
        import core.style as s
        self.op_name = name
        self.setCursor(Qt.PointingHandCursor)
        self.setMinimumHeight(80)
        self.setMinimumWidth(180)
        self._selected = False

        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 10, 12, 10)
        layout.setSpacing(4)

        lbl_name = QLabel(name.upper())
        lbl_name.setStyleSheet(f"color: {s.FG_TEXT}; font-size: 11px; font-weight: bold; background: transparent; letter-spacing: 1px;")
        layout.addWidget(lbl_name)

        lbl_model = QLabel(gguf_path)
        lbl_model.setStyleSheet(f"color: {s.FG_DIM}; font-size: 9px; background: transparent;")
        lbl_model.setWordWrap(True)
        layout.addWidget(lbl_model)

        info_parts = []
        if module_count > 0:
            info_parts.append(f"{module_count} module{'s' if module_count != 1 else ''}")
        if tag_count > 0:
            info_parts.append(f"{tag_count} tag{'s' if tag_count != 1 else ''}")
        lbl_info = QLabel(" · ".join(info_parts) if info_parts else "empty")
        lbl_info.setStyleSheet(f"color: {s.FG_INFO}; font-size: 9px; background: transparent;")
        layout.addWidget(lbl_info)

        layout.addStretch()
        self._apply_style(False)

    def _apply_style(self, selected: bool):
        import core.style as s
        self._selected = selected
        border = s.ACCENT_PRIMARY if selected else s.BORDER_DARK
        bg = s.BORDER_SUBTLE if selected else s.BG_INPUT
        self.setStyleSheet(f"""
            _OperatorCard {{
                background: {bg};
                border: 1px solid {border};
                border-radius: 3px;
            }}
            _OperatorCard:hover {{
                border: 1px solid {s.ACCENT_PRIMARY};
                background: {s.BG_BUTTON_HOVER};
            }}
        """)

    def set_selected(self, selected: bool):
        self._apply_style(selected)

    def mouseDoubleClickEvent(self, event):
        self.sig_double_clicked.emit(self.op_name)


class PageHub(QWidget):
    sig_load_operator = Signal(str)
    sig_save_operator = Signal(str, dict)

    def __init__(self, config_provider=None, operator_manager: OperatorManager | None = None, ui_bridge=None):
        super().__init__()
        import core.style as s
        self._operator_manager = operator_manager or OperatorManager()
        self._config_provider = config_provider
        self._ui_bridge = ui_bridge
        self._selected_name: str | None = None
        self._cards: dict[str, _OperatorCard] = {}

        self.setStyleSheet(f"background: {s.BG_MAIN};")

        layout = QVBoxLayout(self)
        layout.setContentsMargins(30, 30, 30, 30)
        layout.setSpacing(0)

        # --- Welcome header ---
        header = QWidget()
        header.setStyleSheet("background: transparent;")
        header_layout = QVBoxLayout(header)
        header_layout.setContentsMargins(0, 0, 0, 20)
        header_layout.setSpacing(4)

        lbl_welcome = QLabel("MONOLITH")
        lbl_welcome.setStyleSheet(
            f"color: {s.ACCENT_PRIMARY}; font-size: 20px; font-weight: bold; "
            f"letter-spacing: 4px; background: transparent;"
        )
        header_layout.addWidget(lbl_welcome)

        lbl_sub = QLabel("Select an operator to restore your workspace, or create a new one.")
        lbl_sub.setStyleSheet(f"color: {s.FG_DIM}; font-size: 10px; background: transparent;")
        header_layout.addWidget(lbl_sub)

        layout.addWidget(header)

        # --- Separator ---
        sep = QFrame()
        sep.setFixedHeight(1)
        sep.setStyleSheet(f"background: {s.BORDER_DARK};")
        layout.addWidget(sep)
        layout.addSpacing(16)

        # --- Operator label ---
        ops_header = QHBoxLayout()
        lbl_ops = QLabel("OPERATORS")
        lbl_ops.setStyleSheet(
            f"color: {s.FG_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        ops_header.addWidget(lbl_ops)
        ops_header.addStretch()
        layout.addLayout(ops_header)
        layout.addSpacing(10)

        # --- Card grid ---
        self.grid_wrap = QWidget()
        self.grid_wrap.setStyleSheet("background: transparent;")
        self.grid = QGridLayout(self.grid_wrap)
        self.grid.setContentsMargins(0, 0, 0, 0)
        self.grid.setSpacing(10)
        layout.addWidget(self.grid_wrap, 1)

        # --- Empty state ---
        self.empty_label = QLabel("No operators saved yet.\nCreate one to snapshot your current workspace.")
        self.empty_label.setAlignment(Qt.AlignCenter)
        self.empty_label.setStyleSheet(f"color: {s.FG_INFO}; font-size: 11px; padding: 40px; background: transparent;")
        self.grid.addWidget(self.empty_label, 0, 0, 1, 3, Qt.AlignCenter)

        layout.addStretch()

        # --- Bottom action bar ---
        sep2 = QFrame()
        sep2.setFixedHeight(1)
        sep2.setStyleSheet(f"background: {s.BORDER_DARK};")
        layout.addWidget(sep2)
        layout.addSpacing(10)

        btn_row = QHBoxLayout()
        btn_row.setSpacing(8)
        self.btn_new = MonoButton("＋ NEW")
        self.btn_new.setFixedHeight(28)
        self.btn_new.clicked.connect(self._create_operator_from_current)
        self.btn_load = MonoButton("▶ LOAD")
        self.btn_load.setFixedHeight(28)
        self.btn_load.clicked.connect(self._load_selected)
        self.btn_load.setEnabled(False)
        self.btn_delete = MonoButton("— DELETE")
        self.btn_delete.setFixedHeight(28)
        self.btn_delete.clicked.connect(self._delete_selected)
        self.btn_delete.setEnabled(False)
        btn_row.addWidget(self.btn_new)
        btn_row.addWidget(self.btn_load)
        btn_row.addWidget(self.btn_delete)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        # --- Appearance section ---
        layout.addSpacing(16)
        sep3 = QFrame()
        sep3.setFixedHeight(1)
        sep3.setStyleSheet(f"background: {s.BORDER_DARK};")
        layout.addWidget(sep3)
        layout.addSpacing(10)

        lbl_appearance = QLabel("APPEARANCE")
        lbl_appearance.setStyleSheet(
            f"color: {s.FG_DIM}; font-size: 9px; font-weight: bold; "
            f"letter-spacing: 2px; background: transparent;"
        )
        layout.addWidget(lbl_appearance)
        layout.addSpacing(6)

        theme_row = QHBoxLayout()
        theme_row.setSpacing(8)
        lbl_theme = QLabel("Theme")
        lbl_theme.setStyleSheet(f"color: {s.FG_DIM}; font-size: 10px; background: transparent;")
        self.theme_combo = QComboBox()
        self.theme_combo.setFixedWidth(140)
        self.theme_combo.setFixedHeight(28)
        self.theme_combo.setStyleSheet(f"""
            QComboBox {{
                background: {s.BG_INPUT}; color: {s.FG_TEXT};
                border: 1px solid {s.BORDER_LIGHT}; padding: 4px 8px;
                font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QComboBox:hover {{ border: 1px solid {s.ACCENT_PRIMARY}; }}
            QComboBox::drop-down {{
                border: none; width: 20px;
            }}
            QComboBox::down-arrow {{
                image: none; border: none;
            }}
            QComboBox QAbstractItemView {{
                background: {s.BG_INPUT}; color: {s.FG_TEXT};
                border: 1px solid {s.BORDER_LIGHT};
                selection-background-color: {s.BG_BUTTON_HOVER};
                selection-color: {s.ACCENT_PRIMARY};
            }}
        """)
        for name in list_themes():
            self.theme_combo.addItem(name)
        # Set current theme in dropdown
        active = current_theme().name
        idx = self.theme_combo.findText(active)
        if idx >= 0:
            self.theme_combo.setCurrentIndex(idx)
        self.theme_combo.currentTextChanged.connect(self._on_theme_changed)

        theme_row.addWidget(lbl_theme)
        theme_row.addWidget(self.theme_combo)
        theme_row.addStretch()
        layout.addLayout(theme_row)

        self.refresh_cards()

    def refresh_cards(self):
        # Clear existing cards (but not empty_label — we control it separately)
        for card in self._cards.values():
            self.grid.removeWidget(card)
            card.deleteLater()
        self._cards.clear()

        operators = self._operator_manager.list_operators()

        self.empty_label.setVisible(len(operators) == 0)

        for idx, item in enumerate(operators):
            name = item["name"]
            try:
                data = self._operator_manager.load_operator(name)
            except Exception:
                continue
            # New format: modules list; legacy: top-level config
            modules = data.get("modules", [])
            module_count = len(modules)
            if modules:
                # Find first terminal's config for display
                term = next((m for m in modules if m.get("addon_id") == "terminal"), None)
                cfg = term.get("config", {}) if term else {}
            else:
                cfg = data.get("config", {})
            gguf_path = self._truncate_path(cfg.get("gguf_path"))
            tag_count = len(cfg.get("behavior_tags") or [])

            card = _OperatorCard(name, gguf_path, tag_count, module_count)
            card.clicked.connect(lambda _checked=False, op_name=name: self._on_card_clicked(op_name))
            card.sig_double_clicked.connect(self._load_operator)
            row, col = divmod(idx, 3)
            self.grid.addWidget(card, row + 1, col)  # +1 to skip row 0 (empty_label)
            self._cards[name] = card

        if self._selected_name not in self._cards:
            self._selected_name = None
            self.btn_load.setEnabled(False)
            self.btn_delete.setEnabled(False)

    def _on_card_clicked(self, name: str):
        self._selected_name = name
        for op_name, card in self._cards.items():
            card.set_selected(op_name == name)
        self.btn_load.setEnabled(True)
        self.btn_delete.setEnabled(True)

    def _load_selected(self):
        if self._selected_name:
            self.sig_load_operator.emit(self._selected_name)

    def _load_operator(self, name: str):
        self._on_card_clicked(name)
        self.sig_load_operator.emit(name)

    def _create_operator_from_current(self):
        if self._config_provider is None:
            QMessageBox.warning(self, "Operator", "Terminal page is not mounted.")
            return
        dialog = _NameDialog(self)
        if dialog.exec() != QDialog.Accepted:
            return
        clean_name = dialog.value()
        if not clean_name:
            return
        snapshot = dict(self._config_provider() or {})
        data = {"name": clean_name, "layout": {}, "geometry": {}}
        data.update(snapshot)  # merges "modules" and "module_order" into top level
        # Keep a "config" key for backward compat if snapshot has no modules
        if "modules" not in data:
            data["config"] = snapshot
        self.sig_save_operator.emit(clean_name, data)
        self.refresh_cards()

    def _delete_selected(self):
        if not self._selected_name:
            return
        if not self._operator_manager.delete_operator(self._selected_name):
            QMessageBox.warning(self, "Operator", "Delete failed.")
            return
        self._selected_name = None
        self.btn_load.setEnabled(False)
        self.btn_delete.setEnabled(False)
        self.refresh_cards()

    def _on_theme_changed(self, theme_name: str):
        key = theme_name.lower()
        apply_theme(key)
        save_theme_config({"theme": key})
        if self._ui_bridge:
            self._ui_bridge.sig_theme_changed.emit(key)

    def apply_theme_refresh(self):
        """Re-apply all stylesheets after theme change."""
        from core.style import (
            BG_MAIN, BG_INPUT, BG_BUTTON_HOVER, FG_TEXT, FG_DIM, FG_INFO,
            FG_PLACEHOLDER, ACCENT_GOLD, BORDER_DARK, BORDER_LIGHT, BORDER_SUBTLE,
        )
        self.setStyleSheet(f"background: {BG_MAIN};")

        # Welcome header MONOLITH label
        for child in self.findChildren(QLabel):
            if child.text() == "MONOLITH":
                child.setStyleSheet(
                    f"color: {ACCENT_GOLD}; font-size: 20px; font-weight: bold; "
                    f"letter-spacing: 4px; background: transparent;"
                )
            elif child.text().startswith("Select an operator"):
                child.setStyleSheet(f"color: {FG_DIM}; font-size: 10px; background: transparent;")

        # Operator cards
        for card in self._cards.values():
            card._apply_style(card._selected)

        # Theme combo
        self.theme_combo.setStyleSheet(f"""
            QComboBox {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_LIGHT}; padding: 4px 8px;
                font-size: 10px; font-weight: bold; border-radius: 2px;
            }}
            QComboBox:hover {{ border: 1px solid {ACCENT_GOLD}; }}
            QComboBox::drop-down {{ border: none; width: 20px; }}
            QComboBox::down-arrow {{ image: none; border: none; }}
            QComboBox QAbstractItemView {{
                background: {BG_INPUT}; color: {FG_TEXT};
                border: 1px solid {BORDER_LIGHT};
                selection-background-color: {BG_BUTTON_HOVER};
                selection-color: {ACCENT_GOLD};
            }}
        """)

    def _truncate_path(self, value) -> str:
        if not value:
            return "No model path"
        path = str(value)
        if len(path) <= 42:
            return path
        return f"...{path[-39:]}"


